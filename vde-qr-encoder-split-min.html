<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>QR File Transfer - Encoder with Auto-Split</title><script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script><style>*{margin:0;padding:0;box-sizing:border-box}
body{font-family:system-ui,-apple-system,sans-serif;line-height:1.5;background:#f5f5f5;color:#333;max-width:1200px;margin:0 auto;padding:20px}
h1{margin:20px 0;color:#2563eb}
.container{display:flex;flex-wrap:wrap;gap:20px}
.panel{background:#fff;padding:20px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,.1);flex:1;min-width:300px}
.control-panel{display:flex;flex-direction:column;gap:15px}
.control-group{display:flex;flex-direction:column;gap:8px}
.control-label{font-weight:700}
button{padding:12px;background:#2563eb;color:#fff;border:none;border-radius:4px;cursor:pointer;font-weight:700;margin-top:10px;transition:background .2s}
button:hover{background:#1d4ed8}
button:disabled{background:#94a3b8;cursor:not-allowed}
.display-container{display:flex;flex-direction:column;align-items:center;justify-content:center}
#qrDisplay{position:relative;margin:0 auto 20px;border:1px solid #ddd;padding:20px;border-radius:8px;background:#fff;max-width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center}
.progress-container{width:100%;background:#e5e7eb;border-radius:4px;overflow:hidden;height:10px;margin-top:15px}
.progress-bar{height:100%;background:#2563eb;width:0;transition:width .3s}
.file-info{margin-top:20px;padding:15px;background:#f0f9ff;border-radius:8px;border-left:4px solid #2563eb}
.metadata-info{margin-top:10px;padding:10px;background:#f0f9ff;border-radius:8px;border-left:4px solid #1d4ed8}
.info-row{display:flex;justify-content:space-between;margin-bottom:8px}
.info-label{font-weight:700;color:#1e40af}
.fullscreen{position:fixed;top:0;left:0;width:100vw;height:100vh;background:#000;z-index:1000;display:flex;justify-content:center;align-items:center;flex-direction:column}
.fullscreen .qr-container{
display:flex;
justify-content:center;
align-items:center;
width:80vmin;
height:80vmin;
position:relative;
}
.fullscreen-qr {
width: 100%;
height: 100%;
object-fit: contain;
max-width: 95vh;
max-height: 95vh;
}
.fullscreen-progress{position:absolute;bottom:50px;width:80%;max-width:400px}
.fullscreen-counter{position:absolute;top:20px;left:20px;background:rgba(0,0,0,.5);color:#fff;padding:10px;border-radius:4px;font-weight:bold;font-size:16px;z-index:10}
.exit-button{position:absolute;top:20px;right:20px;background:#ef4444;color:#fff;border:none;width:40px;height:40px;border-radius:20px;font-size:20px;cursor:pointer}
.countdown-display{
font-size:120px;
color:#1890ff;
position:absolute;
top:50%;
left:50%;
transform:translate(-50%,-50%);
text-shadow:0 0 10px rgba(24,144,255,.5);
z-index:100;
display:none;
background:rgba(0,0,0,.4);
width:200px;
height:200px;
border-radius:50%;
line-height:200px;
text-align:center;
font-weight:bold;
}
.fullscreen .countdown-display {
width: 250px;
height: 250px;
line-height: 250px;
font-size: 150px;
background: rgba(0,0,0,.6);
}
input[type=range]{width:100%;height:8px;background:#e5e7eb;border-radius:4px;appearance:none;outline:0}
input[type=range]::-webkit-slider-thumb{appearance:none;width:16px;height:16px;background:#2563eb;border-radius:50%;cursor:pointer}
.slider-labels{display:flex;justify-content:space-between;font-size:12px;color:#6b7280;margin-top:5px}
.value-display{font-weight:700;color:#2563eb;margin-left:auto}
.file-input-container{position:relative;overflow:hidden;display:inline-block;width:100%}
.file-input-label{padding:12px;background:#e5e7eb;color:#333;border-radius:4px;cursor:pointer;display:block;text-align:center;transition:background .2s}
.file-input-label:hover{background:#d1d5db}
.file-input-container input[type=file]{position:absolute;left:0;top:0;opacity:0;width:100%;height:100%;cursor:pointer}
.file-list-container{margin-top:15px;background:#f9fafb;border-radius:8px;padding:15px;display:none}
.file-list-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;font-weight:600}
.file-list{max-height:300px;overflow-y:auto}
.file-item{display:flex;align-items:center;padding:8px;border-bottom:1px solid #e5e7eb;transition:background .2s}
.file-item:hover{background:#f3f4f6}
.file-item:last-child{border-bottom:none}
.file-checkbox{margin-right:12px;width:18px;height:18px;cursor:pointer}
.file-info{flex:1;display:flex;flex-direction:column}
.file-name{font-weight:500;margin-bottom:2px}
.file-size{font-size:12px;color:#6b7280}
.file-status{margin-left:auto;padding:4px 8px;border-radius:12px;font-size:11px;font-weight:500;text-transform:uppercase}
.status-pending{background:#fef3c7;color:#d97706}
.status-inprogress{background:#dbeafe;color:#2563eb}
.status-sent{background:#dcfce7;color:#16a34a}
.status-error{background:#fee2e2;color:#dc2626}
.batch-controls{display:flex;gap:10px;margin-top:10px}
.select-all-btn,.clear-all-btn{font-size:12px;padding:6px 12px}
.control-switch {
display: flex;
align-items: center;
cursor: pointer;
user-select: none;
margin: 10px 0;
}
.control-switch input[type="checkbox"] {
margin-right: 8px;
width: 16px;
height: 16px;
}
.switch-label {
font-weight: 500;
}
.action-button {
background-color: #16a34a;
width: 100%;
padding: 14px;
font-size: 16px;
}
.action-button:hover {
background-color: #15803d;
}
.alignment-guide {
position: absolute;
border: 3px dashed rgba(59, 130, 246, 0.7);
pointer-events: none;
display: none;
}
#qrDisplay.show-guides .alignment-guide {
display: block;
}
.guide-label {
position: absolute;
background: rgba(0, 0, 0, 0.6);
color: white;
padding: 2px 6px;
border-radius: 4px;
font-size: 12px;
pointer-events: none;
}
.qr-image {
transition: opacity 0.15s ease-out;
}
.preset-selector {
display: flex;
gap: 10px;
margin-bottom: 10px;
flex-wrap: wrap;
}
.preset-button {
padding: 8px 12px;
background: #e5e7eb;
color: #333;
border: 1px solid #d1d5db;
border-radius: 4px;
cursor: pointer;
flex: 1;
min-width: 120px;
text-align: center;
transition: all 0.2s;
}
.preset-button:hover {
background: #d1d5db;
}
.preset-button.active {
background: #2563eb;
color: white;
border-color: #2563eb;
}
.tooltip {
position: relative;
display: inline-block;
margin-left: 5px;
width: 16px;
height: 16px;
background: #e5e7eb;
color: #6b7280;
border-radius: 50%;
text-align: center;
line-height: 16px;
font-size: 11px;
font-weight: bold;
cursor: help;
}
.tooltip:hover::after {
content: attr(data-tooltip);
position: absolute;
top: -5px;
left: 100%;
transform: translateY(-100%);
background: rgba(55, 65, 81, 0.9);
color: white;
padding: 5px 10px;
border-radius: 4px;
width: 200px;
font-weight: normal;
font-size: 12px;
z-index: 10;
line-height: 1.4;
}
.handshake-notice {
margin-top: 20px;
padding: 10px;
background: rgba(245, 158, 11, 0.1);
border-left: 3px solid #f59e0b;
border-radius: 3px;
font-size: 13px;
color: #92400e;
}
@media (max-width:768px){
.container{flex-direction:column}
.handshake-notice, .preset-selector {font-size: 11px;}
.preset-button {padding: 6px 8px; min-width: 90px;}
.control-label {font-size: 14px;}
h1 {font-size: 20px; margin: 10px 0;}
.panel {padding: 15px;}
.slider-labels {font-size: 10px;}
.countdown-display {width: 150px; height: 150px; line-height: 150px; font-size: 90px;}
}</style></head><body><h1>QR Code File Encoder</h1><div class="container"><div class="panel control-panel"><div class="control-group"><label class="control-label">Select File</label><div class="file-input-container"><label class="file-input-label"><span id="fileLabel">Choose files</span><input type="file" id="fileInput" multiple></label></div><div id="fileListContainer" class="file-list-container"><div class="file-list-header"><span>Selected Files</span><div class="batch-controls"><button id="selectAllBtn" class="select-all-btn">Select All</button><button id="clearAllBtn" class="clear-all-btn">Clear All</button></div></div><div id="fileList" class="file-list"></div></div></div><div class="control-group"><label class="control-label">Performance Presets</label><div class="preset-selector"><button id="fastPreset" class="preset-button">Fast Transfer</button><button id="reliablePreset" class="preset-button active">Reliable</button><button id="mobilePreset" class="preset-button">Mobile Optimized</button></div><div style="font-size: 12px; color: #6b7280; margin-top: 5px;">
Presets automatically configure optimal settings for your use case
</div></div><div class="control-group"><div class="control-label">
QR Size <span class="value-display" id="sizeValue">800px</span><span class="tooltip" data-tooltip="Size of the QR code in pixels. Larger QR codes are easier to scan but may not fit on screen.">?</span></div><input type="range" id="sizeSlider" min="200" max="800" value="800"><div class="slider-labels"><span>Smaller</span><span>Larger</span></div></div><div class="control-group"><div class="control-label">
Display Speed <span class="value-display" id="speedValue">6 FPS</span><span class="tooltip" data-tooltip="Frames per second. Higher values transfer data faster, but may be harder to scan.">?</span></div><input type="range" id="speedSlider" min="1" max="30" value="6"><div class="slider-labels"><span>Slower</span><span>Faster</span></div></div><div class="control-group"><div class="control-label">
Chunk Size <span class="value-display" id="chunkValue">450 chars</span><span class="tooltip" data-tooltip="Size of each data chunk. Larger chunks transfer faster but may be harder to scan.">?</span></div><input type="range" id="chunkSlider" min="100" max="1000" step="50" value="450"><div class="slider-labels"><span>Smaller chunks</span><span>Larger chunks</span></div></div><div class="control-group"><div class="control-label">
Redundancy <span class="value-display" id="redundancyValue">100%</span><span class="tooltip" data-tooltip="Extra data to ensure successful transfer. Higher values improve reliability but increase transfer time.">?</span></div><input type="range" id="redundancySlider" min="20" max="200" step="10" value="100"><div class="slider-labels"><span>Less</span><span>More</span></div><div style="font-size: 12px; color: #6b7280; margin-top: 5px;">
For 30% missed frames, use 60-70% redundancy<br>
For 50% missed frames, use 100-120% redundancy
</div></div><div class="control-group"><div class="control-label">
Error Correction Level
<span class="tooltip" data-tooltip="QR code error correction level. Higher levels are more reliable but create larger, more complex QR codes.">?</span></div><div style="display: flex; justify-content: space-between; margin-top: 5px;"><select id="errorCorrectionSelect" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #d1d5db;"><option value="H">High (30% recovery)</option><option value="M">Medium (15% recovery)</option><option value="L">Low (7% recovery)</option></select></div><div style="font-size: 12px; color: #6b7280; margin-top: 5px;">
Higher correction = more reliable but larger QR codes
</div></div><div class="control-group"><div class="control-label">
Systematic Chunks per QR <span class="value-display" id="systematicChunksValue">2</span><span class="tooltip" data-tooltip="Number of chunks to combine in systematic QR codes (reliable phase). 1=one chunk per QR, 2=two chunks per QR.">?</span></div><input type="range" id="systematicChunksSlider" min="1" max="4" step="1" value="2"><div class="slider-labels"><span>Single (1)</span><span>Quad (4)</span></div><div style="font-size: 12px; color: #6b7280; margin-top: 5px;">
Systematic phase: Recommend 1-2 for highest reliability
</div></div><div class="control-group"><div class="control-label">
Fountain Max Degree <span class="value-display" id="fountainDegreeValue">3</span><span class="tooltip" data-tooltip="Maximum degree for fountain coding phase (redundancy). Higher values create more complex combinations but better error recovery.">?</span></div><input type="range" id="fountainDegreeSlider" min="2" max="20" step="1" value="3"><div class="slider-labels"><span>Simple (2)</span><span>Complex (20)</span></div><div style="font-size: 12px; color: #6b7280; margin-top: 5px;">
Fountain phase: Higher degrees improve recovery but need more processing
</div></div><div class="control-group"><div class="control-label">
Auto-Split Threshold <span class="value-display" id="splitThresholdValue">100KB</span><span class="tooltip" data-tooltip="Files larger than this size will be automatically split into manageable parts for QR transmission.">?</span></div><input type="range" id="splitThresholdSlider" min="50" max="500" step="10" value="100"><div class="slider-labels"><span>50KB</span><span>500KB</span></div><div style="font-size: 12px; color: #6b7280; margin-top: 5px;">
Large files split automatically for better QR transmission reliability
</div></div><div class="control-group"><label class="control-switch"><input type="checkbox" id="enableAutoSplitCheckbox" checked><span class="switch-label">Enable Auto-Split for Large Files</span><span class="tooltip" data-tooltip="Automatically splits large files into smaller parts for more reliable QR transmission.">?</span></label><div style="font-size: 12px; color: #6b7280; margin-top: 5px; margin-left: 24px;">
Recommended for files >100KB to improve transmission success rate
</div></div><div class="control-group"><div class="control-label">
Countdown Before Start <span class="value-display" id="countdownValue">10s</span><span class="tooltip" data-tooltip="Time to prepare before QR codes start displaying.">?</span></div><input type="range" id="countdownSlider" min="0" max="30" value="10"><div class="slider-labels"><span>None</span><span>30s</span></div></div><div class="control-group"><label class="control-switch"><input type="checkbox" id="fullscreenCheckbox" checked><span class="switch-label">Start in Fullscreen Mode (Recommended)</span></label></div><div class="control-group"><label class="control-switch"><input type="checkbox" id="showGuidesCheckbox"><span class="switch-label">Show Scanner Alignment Guides</span></label></div><div class="control-group"><label class="control-switch"><input type="checkbox" id="enableTransitionsCheckbox" checked><span class="switch-label">Enable Smooth Transitions</span><span class="tooltip" data-tooltip="Enables subtle transitions between QR codes to improve scanning reliability.">?</span></label><div style="font-size: 12px; color: #6b7280; margin-top: 5px; margin-left: 24px;">
Always on for best results; disable only for older devices
</div></div><div class="control-group"><label class="control-switch"><input type="checkbox" id="highDensityCheckbox"><span class="switch-label">High Density Mode</span><span class="tooltip" data-tooltip="Increases QR code data capacity but requires enhanced scanner capabilities.">?</span></label><div style="font-size: 12px; color: #6b7280; margin-top: 5px; margin-left: 24px;">
WARNING: Only enable if using the enhanced parallel processing decoder
</div></div><div class="control-group"><button id="generateAndStartBtn" class="action-button" disabled>Generate & Start Display</button><div style="display: flex; gap: 10px; margin-top: 5px;"><button id="generateBtn" disabled>Generate QR Codes</button><button id="stopBtn" disabled style="flex: 1; background: #dc2626;">Stop</button></div><div style="display: flex; gap: 10px; margin-top: 5px;"><button id="startBtn" disabled style="flex: 1;">Start Display</button><button id="fullscreenBtn" disabled style="flex: 1; background: #4b5563;">Fullscreen</button></div></div><div class="handshake-notice"><strong>Handshake Mode</strong>: The first frame contains special setup data that helps the decoder optimize for your specific transfer. Make sure to scan this frame.
</div></div><div class="panel"><div class="display-container"><div id="frameCounter" style="margin-bottom: 10px; font-weight: bold;">Frame: 0 / 0</div><div id="qrDisplay" style="width: 800px; height: 800px; display: flex; align-items: center; justify-content: center;"><div class="alignment-guide" style="width: 90%; height: 90%; top: 5%; left: 5%;"></div><div class="alignment-guide" style="width: 70%; height: 70%; top: 15%; left: 15%;"></div><div class="guide-label" style="top: 2%; left: 50%; transform: translateX(-50%);">Keep QR code within this area</div><div style="color: #6b7280;">QR code will appear here</div><div id="countdownDisplay" class="countdown-display"></div></div><div class="progress-container"><div class="progress-bar" id="progressBar"></div></div></div><div id="fileInfo" class="file-info" style="display: none;"><h3 style="margin-bottom: 10px;">File Information</h3><div class="info-row"><div class="info-label">File Name:</div><div id="fileName">-</div></div><div class="info-row"><div class="info-label">File Size:</div><div id="fileSize">-</div></div><div class="info-row"><div class="info-label">Chunks:</div><div id="chunksCount">-</div></div><div class="info-row"><div class="info-label">Packets:</div><div id="packetsCount">-</div></div><div class="info-row"><div class="info-label">Redundancy Level:</div><div id="redundancyLevel">-</div></div><div class="info-row"><div class="info-label">Transfer Time:</div><div id="transferTime">-</div></div><div class="info-row"><div class="info-label">Optimal Distance:</div><div id="optimalDistance">-</div></div><div class="info-row high-density-indicator" style="display: none;"><div class="info-label" style="color: #b91c1c;">High Density Mode:</div><div style="color: #b91c1c; font-weight: bold;">Active</div></div></div><div id="metadataInfo" class="metadata-info" style="display: none;"><h3 style="margin-bottom: 10px;">Transmission Details</h3><div id="qrCodeInfo" style="margin-bottom: 10px;"><div style="font-weight: bold; color: #1e40af;">Current Frame Type:</div><div id="frameType">-</div></div><div id="currentChunkInfo" style="margin-bottom: 10px; display: none;"><div style="font-weight: bold; color: #1e40af;">Current Chunk:</div><div id="chunkId">-</div></div><div id="transmissionStats" style="margin-top: 10px;"><div style="font-weight: bold; color: #1e40af;">Transmission Stats:</div><div>Elapsed Time: <span id="elapsedTime">0s</span></div><div>Avg Speed: <span id="transmissionSpeed">-</span></div></div></div></div></div><div id="fullscreenDisplay" class="fullscreen" style="display: none;"><div class="qr-container"><img id="fullscreenQR" class="fullscreen-qr" src="" alt="QR Code"><div id="fsCountdownDisplay" class="countdown-display"></div></div><div class="fullscreen-counter" id="fullscreenCounter">Frame: 0 / 0</div><div class="fullscreen-progress progress-container"><div class="progress-bar" id="fullscreenProgressBar"></div></div><button class="exit-button" id="exitFullscreenBtn">&times;</button></div><script>const DEFAULT_QR_CONTENT_SIZE = 3500;
const HIGH_DENSITY_QR_CONTENT_SIZE = 5000;
let MAX_QR_CONTENT_SIZE = DEFAULT_QR_CONTENT_SIZE;
const fileInput = document.getElementById('fileInput');
const fileLabel = document.getElementById('fileLabel');
const speedSlider = document.getElementById('speedSlider');
const sizeSlider = document.getElementById('sizeSlider');
const chunkSlider = document.getElementById('chunkSlider');
const redundancySlider = document.getElementById('redundancySlider');
const countdownSlider = document.getElementById('countdownSlider');
const systematicChunksSlider = document.getElementById('systematicChunksSlider');
const fountainDegreeSlider = document.getElementById('fountainDegreeSlider');
const splitThresholdSlider = document.getElementById('splitThresholdSlider');
const enableAutoSplitCheckbox = document.getElementById('enableAutoSplitCheckbox');
const speedValue = document.getElementById('speedValue');
const sizeValue = document.getElementById('sizeValue');
const chunkValue = document.getElementById('chunkValue');
const redundancyValue = document.getElementById('redundancyValue');
const systematicChunksValue = document.getElementById('systematicChunksValue');
const fountainDegreeValue = document.getElementById('fountainDegreeValue');
const splitThresholdValue = document.getElementById('splitThresholdValue');
const countdownValue = document.getElementById('countdownValue');
const errorCorrectionSelect = document.getElementById('errorCorrectionSelect');
const fullscreenCheckbox = document.getElementById('fullscreenCheckbox');
const showGuidesCheckbox = document.getElementById('showGuidesCheckbox');
const enableTransitionsCheckbox = document.getElementById('enableTransitionsCheckbox');
const highDensityCheckbox = document.getElementById('highDensityCheckbox');
const generateAndStartBtn = document.getElementById('generateAndStartBtn');
const generateBtn = document.getElementById('generateBtn');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const fullscreenBtn = document.getElementById('fullscreenBtn');
const qrDisplay = document.getElementById('qrDisplay');
const progressBar = document.getElementById('progressBar');
const frameCounter = document.getElementById('frameCounter');
const fileInfo = document.getElementById('fileInfo');
const metadataInfo = document.getElementById('metadataInfo');
const frameType = document.getElementById('frameType');
const chunkId = document.getElementById('chunkId');
const currentChunkInfo = document.getElementById('currentChunkInfo');
const elapsedTime = document.getElementById('elapsedTime');
const transmissionSpeed = document.getElementById('transmissionSpeed');
const fileName = document.getElementById('fileName');
const fileSize = document.getElementById('fileSize');
const chunksCount = document.getElementById('chunksCount');
const packetsCount = document.getElementById('packetsCount');
const redundancyLevel = document.getElementById('redundancyLevel');
const transferTime = document.getElementById('transferTime');
const optimalDistance = document.getElementById('optimalDistance');
const fullscreenDisplay = document.getElementById('fullscreenDisplay');
const fullscreenQR = document.getElementById('fullscreenQR');
const fullscreenCounter = document.getElementById('fullscreenCounter');
const fullscreenProgressBar = document.getElementById('fullscreenProgressBar');
const exitFullscreenBtn = document.getElementById('exitFullscreenBtn');
const countdownDisplay = document.getElementById('countdownDisplay');
const fsCountdownDisplay = document.getElementById('fsCountdownDisplay');
const fastPreset = document.getElementById('fastPreset');
const reliablePreset = document.getElementById('reliablePreset');
const mobilePreset = document.getElementById('mobilePreset');
let fileContent = null;
let fileNameText = '';
let fileSizeBytes = 0;
let chunks = [];
let fountainPackets = [];
let displayInterval = null;
let currentFrame = 0;
let totalFrames = 0;
let isPlaying = false;
let isFullscreen = false;
let qrSize = 800;
let startTime = null;
let transmissionTimer = null;
let preGeneratedQRs = [];
let countdownTimer = null;
let countdownSeconds = 10;
let wakeLock = null;
let debugMode = false;
speedSlider.addEventListener('input', () => {
const fps = speedSlider.value;
speedValue.textContent = `${fps} FPS`;
});
sizeSlider.addEventListener('input', () => {
qrSize = parseInt(sizeSlider.value);
sizeValue.textContent = `${qrSize}px`;
qrDisplay.style.width = `${qrSize}px`;
qrDisplay.style.height = `${qrSize}px`;
});
chunkSlider.addEventListener('input', () => {
const size = chunkSlider.value;
chunkValue.textContent = `${size} chars`;
});
redundancySlider.addEventListener('input', () => {
const redundancy = redundancySlider.value;
redundancyValue.textContent = `${redundancy}%`;
});
countdownSlider.addEventListener('input', () => {
countdownSeconds = parseInt(countdownSlider.value);
countdownValue.textContent = countdownSeconds > 0 ? `${countdownSeconds}s` : 'None';
});
systematicChunksSlider.addEventListener('input', () => {
const systematicChunks = systematicChunksSlider.value;
systematicChunksValue.textContent = systematicChunks;
});
fountainDegreeSlider.addEventListener('input', () => {
const fountainDegree = fountainDegreeSlider.value;
fountainDegreeValue.textContent = fountainDegree;
});
splitThresholdSlider.addEventListener('input', () => {
const threshold = splitThresholdSlider.value;
splitThresholdValue.textContent = `${threshold}KB`;
});
showGuidesCheckbox.addEventListener('change', () => {
if (showGuidesCheckbox.checked) {
qrDisplay.classList.add('show-guides');
} else {
qrDisplay.classList.remove('show-guides');
}
});
highDensityCheckbox.addEventListener('change', () => {
if (highDensityCheckbox.checked) {
MAX_QR_CONTENT_SIZE = HIGH_DENSITY_QR_CONTENT_SIZE;
document.querySelectorAll('.high-density-indicator').forEach(el => {
el.style.display = 'block';
});
} else {
MAX_QR_CONTENT_SIZE = DEFAULT_QR_CONTENT_SIZE;
document.querySelectorAll('.high-density-indicator').forEach(el => {
el.style.display = 'none';
});
}
if (chunks && chunks.length > 0) {
generateBtn.disabled = false;
}
});
fastPreset.addEventListener('click', () => {
applyPreset('fast');
});
reliablePreset.addEventListener('click', () => {
applyPreset('reliable');
});
mobilePreset.addEventListener('click', () => {
applyPreset('mobile');
});
function applyPreset(type) {
fastPreset.classList.remove('active');
reliablePreset.classList.remove('active');
mobilePreset.classList.remove('active');
switch (type) {
case 'fast':
fastPreset.classList.add('active');
speedSlider.value = 12;
chunkSlider.value = 600;
redundancySlider.value = 50;
systematicChunksSlider.value = 2;
fountainDegreeSlider.value = 3;
errorCorrectionSelect.value = 'M';
enableTransitionsCheckbox.checked = true;
break;
case 'reliable':
reliablePreset.classList.add('active');
speedSlider.value = 6;
chunkSlider.value = 450;
redundancySlider.value = 100;
systematicChunksSlider.value = 2;
fountainDegreeSlider.value = 3;
errorCorrectionSelect.value = 'H';
sizeSlider.value = 800;
qrSize = 800;
qrDisplay.style.width = `${qrSize}px`;
qrDisplay.style.height = `${qrSize}px`;
sizeValue.textContent = `${qrSize}px`;
enableTransitionsCheckbox.checked = true;
break;
case 'mobile':
mobilePreset.classList.add('active');
speedSlider.value = 8;
chunkSlider.value = 400;
redundancySlider.value = 100;
systematicChunksSlider.value = 1;
fountainDegreeSlider.value = 4;
errorCorrectionSelect.value = 'H';
sizeSlider.value = 600;
qrSize = 600;
qrDisplay.style.width = `${qrSize}px`;
qrDisplay.style.height = `${qrSize}px`;
sizeValue.textContent = `${qrSize}px`;
enableTransitionsCheckbox.checked = true;
break;
}
speedValue.textContent = `${speedSlider.value} FPS`;
chunkValue.textContent = `${chunkSlider.value} chars`;
redundancyValue.textContent = `${redundancySlider.value}%`;
systematicChunksValue.textContent = systematicChunksSlider.value;
fountainDegreeValue.textContent = fountainDegreeSlider.value;
}
let fileList = [];
let currentProcessingIndex = 0;
fileInput.addEventListener('change', () => {
if (fileInput.files.length > 0) {
fileList = [];
Array.from(fileInput.files).forEach((file, index) => {
fileList.push({
id: Date.now() + index,
file: file,
name: file.name,
size: file.size,
selected: true,
status: 'pending'
});
});
updateFileListDisplay();
updateFileLabel();
generateBtn.disabled = false;
generateAndStartBtn.disabled = false;
if (displayInterval) {
clearInterval(displayInterval);
displayInterval = null;
}
isPlaying = false;
startBtn.disabled = true;
stopBtn.disabled = true;
fullscreenBtn.disabled = true;
applyOptimalSettings();
}
});
function calculateOptimalSettings(fileSize) {
return {
fps: 6,
chunkSize: 450,
redundancy: 100,
distance: "25-30cm",
preset: "reliable"
};
}
function updateFileLabel() {
const selectedCount = fileList.filter(f => f.selected).length;
const totalCount = fileList.length;
if (totalCount === 0) {
fileLabel.textContent = 'Choose files';
} else if (totalCount === 1) {
fileLabel.textContent = fileList[0].name;
} else {
fileLabel.textContent = `${selectedCount}/${totalCount} files selected`;
}
}
function updateFileListDisplay() {
const container = document.getElementById('fileListContainer');
const listElement = document.getElementById('fileList');
if (fileList.length === 0) {
container.style.display = 'none';
return;
}
container.style.display = 'block';
listElement.innerHTML = '';
fileList.forEach((fileItem, index) => {
const itemElement = document.createElement('div');
itemElement.className = 'file-item';
itemElement.innerHTML = `
<input type="checkbox" class="file-checkbox" id="file-${fileItem.id}"
${fileItem.selected ? 'checked' : ''}
onchange="toggleFileSelection(${fileItem.id})"><div class="file-info"><div class="file-name">${fileItem.name}</div><div class="file-size">${formatFileSize(fileItem.size)}</div></div><div class="file-status status-${fileItem.status}">${fileItem.status}</div>
`;
listElement.appendChild(itemElement);
});
}
function toggleFileSelection(fileId) {
const fileItem = fileList.find(f => f.id === fileId);
if (fileItem) {
fileItem.selected = !fileItem.selected;
updateFileLabel();
}
}
function updateFileStatus(fileId, status) {
const fileItem = fileList.find(f => f.id === fileId);
if (fileItem) {
fileItem.status = status;
updateFileListDisplay();
}
}
function formatFileSize(bytes) {
if (bytes === 0) return '0 Bytes';
const k = 1024;
const sizes = ['Bytes', 'KB', 'MB', 'GB'];
const i = Math.floor(Math.log(bytes) / Math.log(k));
return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
document.getElementById('selectAllBtn').addEventListener('click', () => {
fileList.forEach(f => f.selected = true);
updateFileListDisplay();
updateFileLabel();
});
document.getElementById('clearAllBtn').addEventListener('click', () => {
fileList.forEach(f => f.selected = false);
updateFileListDisplay();
updateFileLabel();
});
async function splitFileIntoParts(file, maxPartSize) {
return new Promise((resolve, reject) => {
const fileReader = new FileReader();
fileReader.onload = () => {
try {
const arrayBuffer = fileReader.result;
const fileData = new Uint8Array(arrayBuffer);
const parts = [];
const totalParts = Math.ceil(fileData.length / maxPartSize);
console.log(`‚úÇÔ∏è ENTERPRISE: Splitting ${file.name} (${fileData.length} bytes) into ${totalParts} parts of ~${formatFileSize(maxPartSize)} each`);
for (let i = 0; i < totalParts; i++) {
const start = i * maxPartSize;
const end = Math.min(start + maxPartSize, fileData.length);
const partData = fileData.slice(start, end);
const fileExtension = file.name.split('.').pop();
const baseName = file.name.replace(`.${fileExtension}`, '');
const partName = `${baseName}.part${i + 1}-${totalParts}.${fileExtension}`;
const partBlob = new Blob([partData], { type: file.type });
const partFile = new File([partBlob], partName, { type: file.type });
parts.push(partFile);
console.log(`üì¶ Created part ${i + 1}/${totalParts}: ${partName} (${formatFileSize(partData.length)})`);
}
resolve(parts);
} catch (error) {
reject(error);
}
};
fileReader.onerror = reject;
fileReader.readAsArrayBuffer(file);
});
}
function formatFileSize(bytes) {
if (bytes === 0) return '0 Bytes';
const k = 1024;
const sizes = ['Bytes', 'KB', 'MB', 'GB'];
const i = Math.floor(Math.log(bytes) / Math.log(k));
return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
async function processBatchFiles(selectedFiles, autoStart = false) {
currentProcessingIndex = 0;
console.log(`üìÅ Starting COMBINED batch processing of ${selectedFiles.length} files...`);
console.log(`üé¨ AutoStart mode: ${autoStart} - will ${autoStart ? 'display all QR codes automatically' : 'only generate codes'}`);
const combinedPackets = [];
let totalCombinedPackets = 0;
for (let i = 0; i < selectedFiles.length; i++) {
const fileItem = selectedFiles[i];
currentProcessingIndex = i;
try {
console.log(`üìÑ Processing file ${i + 1}/${selectedFiles.length}: ${fileItem.name} (${fileItem.size} bytes)`);
updateFileStatus(fileItem.id, 'inprogress');
const shouldSplit = enableAutoSplitCheckbox.checked &&
fileItem.size > (parseInt(splitThresholdSlider.value) * 1024);
if (shouldSplit) {
console.log(`‚úÇÔ∏è ENTERPRISE: File ${fileItem.name} (${formatFileSize(fileItem.size)}) exceeds ${splitThresholdSlider.value}KB threshold - auto-splitting`);
const splitParts = await splitFileIntoParts(fileItem.file, parseInt(splitThresholdSlider.value) * 1024);
for (let partIndex = 0; partIndex < splitParts.length; partIndex++) {
const partFile = splitParts[partIndex];
console.log(`üì¶ Processing part ${partIndex + 1}/${splitParts.length}: ${partFile.name}`);
const partPackets = await generateQRCodesForFileOnly(partFile);
combinedPackets.push(...partPackets);
totalCombinedPackets += partPackets.length;
console.log(`üì¶ Added ${partPackets.length} packets for ${partFile.name} (total: ${totalCombinedPackets})`);
}
console.log(`‚úÖ ENTERPRISE: Completed auto-split processing for ${fileItem.name} ‚Üí ${splitParts.length} parts`);
} else {
console.log(`üìÑ File ${fileItem.name} (${formatFileSize(fileItem.size)}) under ${splitThresholdSlider.value}KB threshold - processing as single file`);
const filePackets = await generateQRCodesForFileOnly(fileItem.file);
combinedPackets.push(...filePackets);
totalCombinedPackets += filePackets.length;
console.log(`üì¶ Added ${filePackets.length} packets for ${fileItem.name} (total: ${totalCombinedPackets})`);
}
updateFileStatus(fileItem.id, 'sent');
fileItem.selected = false;
updateFileListDisplay();
updateFileLabel();
} catch (error) {
console.error(`‚ùå Error processing file ${fileItem.name}:`, error);
updateFileStatus(fileItem.id, 'error');
if (i < selectedFiles.length - 1) {
const continueProcessing = confirm(`Error processing ${fileItem.name}. Continue with remaining files?`);
if (!continueProcessing) {
break;
}
}
}
}
console.log(`üéØ Combining all files into single QR sequence: ${totalCombinedPackets} total packets`);
allPackets = combinedPackets;
fountainPackets = combinedPackets;
totalPackets = totalCombinedPackets;
totalFrames = totalCombinedPackets;
console.log(`üîß Display variables set: totalPackets=${totalPackets}, totalFrames=${totalFrames}`);
console.log(`üé® Pre-generating all ${totalCombinedPackets} QR code images...`);
await preGenerateAllQRCodes();
console.log(`‚úÖ All QR codes pre-generated and ready for display`);
const firstFile = selectedFiles[0];
const fileInfo = document.getElementById('fileInfo');
if (fileInfo) {
document.getElementById('fileName').textContent = `Batch: ${selectedFiles.length} files`;
document.getElementById('fileSize').textContent = `Combined transfer`;
document.getElementById('packetsCount').textContent = totalCombinedPackets;
fileInfo.style.display = 'block';
}
console.log(`üìÅ Combined batch ready: ${totalCombinedPackets} QR codes for ${selectedFiles.length} files`);
if (autoStart && totalCombinedPackets > 0) {
console.log(`üé¨ Auto-starting combined QR display for all files...`);
if (fullscreenCheckbox.checked) {
enterFullscreenMode();
if (countdownSeconds > 0) {
await startCountdownAndWait();
} else {
await startPlayingAndWait();
}
} else {
if (countdownSeconds > 0) {
await startCountdownAndWait();
} else {
await startPlayingAndWait();
}
}
console.log(`‚úÖ Combined batch transmission complete!`);
} else {
startBtn.disabled = false;
fullscreenBtn.disabled = false;
console.log(`üí° Click "Start Display" or "Fullscreen" to show combined QR sequence for all files`);
}
}
async function generateQRCodesForFileOnly(file) {
return new Promise((resolve, reject) => {
try {
console.log(`üîß Generating packets for ${file.name} (${file.size} bytes)`);
const fileReader = new FileReader();
fileReader.onload = async () => {
try {
const arrayBuffer = fileReader.result;
const fileData = new Uint8Array(arrayBuffer);
const chunkSize = parseInt(chunkSlider.value);
const chunks = [];
for (let offset = 0; offset < fileData.length; offset += chunkSize) {
const chunk = fileData.slice(offset, offset + chunkSize);
chunks.push(chunk);
}
const ltEncoder = new SystematicLTEncoder(chunks);
ltEncoder.systematicChunksPerQR = parseInt(systematicChunksSlider.value);
ltEncoder.fountainMaxDegree = parseInt(fountainDegreeSlider.value);
ltEncoder.currentFileName = file.name;
ltEncoder.currentFileSize = file.size;
ltEncoder.currentFileType = file.type;
const filePackets = [ltEncoder.generateMetadataPacket()];
const totalPacketsToGenerate = ltEncoder.calculateTotalPackets();
for (let i = 1; i < totalPacketsToGenerate; i++) {
filePackets.push(ltEncoder.generatePacket());
}
console.log(`‚úÖ Generated ${filePackets.length} packets for ${file.name}`);
resolve(filePackets);
} catch (error) {
reject(error);
}
};
fileReader.onerror = reject;
fileReader.readAsArrayBuffer(file);
} catch (error) {
reject(error);
}
});
}
async function generateQRCodesForFile(file) {
return new Promise((resolve, reject) => {
try {
console.log(`üîß Starting QR generation for ${file.name} (${file.size} bytes)`);
const fileReader = new FileReader();
fileReader.onload = async () => {
try {
console.log(`üìñ File read complete, processing...`);
fileName.textContent = file.name;
const arrayBuffer = fileReader.result;
const fileData = new Uint8Array(arrayBuffer);
console.log(`üì¶ File data loaded: ${fileData.length} bytes`);
fileNameText = file.name;
fileSizeBytes = file.size;
const chunkSize = parseInt(chunkSlider.value);
const chunks = [];
console.log(`‚úÇÔ∏è Splitting into ${chunkSize} byte chunks...`);
for (let offset = 0; offset < fileData.length; offset += chunkSize) {
const chunk = fileData.slice(offset, offset + chunkSize);
chunks.push(chunk);
}
console.log(`üìä Created ${chunks.length} chunks`);
console.log(`üèóÔ∏è Creating SystematicLTEncoder...`);
const ltEncoder = new SystematicLTEncoder(chunks);
ltEncoder.systematicChunksPerQR = parseInt(systematicChunksSlider.value);
ltEncoder.fountainMaxDegree = parseInt(fountainDegreeSlider.value);
ltEncoder.currentFileName = file.name;
ltEncoder.currentFileSize = file.size;
ltEncoder.currentFileType = file.type;
console.log(`‚öôÔ∏è Encoder configured: systematic=${ltEncoder.systematicChunksPerQR}, fountain=${ltEncoder.fountainMaxDegree}`);
console.log(`üì§ Generating metadata packet...`);
const localFountainPackets = [ltEncoder.generateMetadataPacket()];
console.log(`üî¢ Calculating total packets needed...`);
const totalPacketsToGenerate = ltEncoder.calculateTotalPackets();
console.log(`üìä Will generate ${totalPacketsToGenerate} total packets`);
for (let i = 1; i < totalPacketsToGenerate; i++) {
const packet = ltEncoder.generatePacket();
localFountainPackets.push(packet);
if (i % 50 === 0) {
console.log(`üì§ Generated ${i}/${totalPacketsToGenerate} packets...`);
}
}
console.log(`‚úÖ Generated all ${localFountainPackets.length} packets`);
allPackets = localFountainPackets;
fountainPackets = localFountainPackets;
totalPackets = allPackets.length;
console.log(`üîß Global arrays set: allPackets.length=${allPackets.length}, fountainPackets.length=${fountainPackets.length}`);
console.log(`üìä Updating packet info UI...`);
try {
const frameCounter = document.getElementById('frameCounter');
const fileName = document.getElementById('fileName');
const fileSize = document.getElementById('fileSize');
const chunksCount = document.getElementById('chunksCount');
const packetsCount = document.getElementById('packetsCount');
const redundancyLevel = document.getElementById('redundancyLevel');
const transferTime = document.getElementById('transferTime');
if (frameCounter) frameCounter.textContent = `Frame: 0 / ${fountainPackets.length}`;
if (fileName) fileName.textContent = file.name;
if (fileSize) fileSize.textContent = this.formatFileSize ? this.formatFileSize(file.size) : `${file.size} bytes`;
if (chunksCount) chunksCount.textContent = chunks.length;
if (packetsCount) packetsCount.textContent = fountainPackets.length;
if (redundancyLevel) redundancyLevel.textContent = `${parseInt(redundancySlider.value)}%`;
if (transferTime) transferTime.textContent = `~${Math.ceil(fountainPackets.length / parseInt(speedSlider.value))} seconds`;
const fileInfo = document.getElementById('fileInfo');
if (fileInfo) fileInfo.style.display = 'block';
console.log(`‚úÖ UI update completed`);
} catch (err) {
console.error(`‚ùå Error updating UI:`, err);
}
console.log(`üéØ QR generation complete for ${file.name}`);
resolve();
} catch (error) {
console.error(`‚ùå Error in file processing:`, error);
console.error(`‚ùå Error details:`, error.message);
console.error(`‚ùå Error stack:`, error.stack);
reject(error);
}
};
fileReader.onerror = (error) => {
console.error(`‚ùå File reader error:`, error);
reject(error);
};
console.log(`üìñ Reading file as ArrayBuffer...`);
fileReader.readAsArrayBuffer(file);
} catch (error) {
console.error(`‚ùå Error setting up file reader:`, error);
reject(error);
}
});
}
async function startPlayingAndWait() {
return new Promise((resolve) => {
startPlaying();
const checkCompletion = setInterval(() => {
if (!displayInterval && !isPlaying) {
clearInterval(checkCompletion);
resolve();
}
}, 1000);
});
}
async function startCountdownAndWait() {
return new Promise((resolve) => {
startCountdown();
const checkCompletion = setInterval(() => {
if (!displayInterval && !countdownTimer && !isPlaying) {
clearInterval(checkCompletion);
resolve();
}
}, 1000);
});
}
function exitFullscreenMode() {
const fullscreenDisplay = document.getElementById('fullscreenDisplay');
if (fullscreenDisplay) {
fullscreenDisplay.style.display = 'none';
}
if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement) {
if (document.exitFullscreen) {
document.exitFullscreen();
} else if (document.webkitExitFullscreen) {
document.webkitExitFullscreen();
} else if (document.mozCancelFullScreen) {
document.mozCancelFullScreen();
}
}
}
function applyOptimalSettings() {
if (!fileInput.files.length) return;
const optimal = calculateOptimalSettings(fileSizeBytes);
speedSlider.value = optimal.fps;
speedValue.textContent = `${optimal.fps} FPS`;
chunkSlider.value = optimal.chunkSize;
chunkValue.textContent = `${optimal.chunkSize} chars`;
redundancySlider.value = optimal.redundancy;
redundancyValue.textContent = `${optimal.redundancy}%`;
optimalDistance.textContent = optimal.distance;
applyPreset(optimal.preset);
}
generateAndStartBtn.addEventListener('click', async () => {
const selectedFiles = fileList.filter(f => f.selected);
if (selectedFiles.length === 0) {
alert('Please select at least one file to process');
return;
}
generateAndStartBtn.disabled = true;
generateAndStartBtn.textContent = 'Processing Batch...';
try {
await processBatchFiles(selectedFiles, true);
} catch (error) {
alert('Error during batch processing: ' + error.message);
} finally {
generateAndStartBtn.textContent = 'Generate & Start Display';
generateAndStartBtn.disabled = false;
}
});
generateBtn.addEventListener('click', async () => {
const selectedFiles = fileList.filter(f => f.selected);
if (selectedFiles.length === 0) {
alert('Please select at least one file to generate QR codes');
return;
}
generateBtn.disabled = true;
generateBtn.textContent = 'Generating Batch...';
try {
await processBatchFiles(selectedFiles, false);
startBtn.disabled = false;
fullscreenBtn.disabled = false;
} catch (error) {
alert('Error generating QR codes: ' + error.message);
} finally {
generateBtn.textContent = 'Generate QR Codes';
generateBtn.disabled = false;
}
});
async function generateQRCodes() {
if (!fileInput.files.length) return;
const file = fileInput.files[0];
const chunkSize = parseInt(chunkSlider.value);
const redundancyPercent = parseInt(redundancySlider.value);
const fileData = await readFileAsBinary(file);
fileContent = fileData;
chunks = chunkFileBinary(fileContent, chunkSize);
if (debugMode) {
console.log(`üîç ENCODER DEBUG - File reading:`);
console.log(` File size: ${fileData.length} bytes`);
console.log(` File type: ${fileData.constructor.name}`);
console.log(` File first 4 bytes: [${Array.from(fileData.slice(0, 4)).join(', ')}]`);
console.log(` Chunk size: ${chunkSize} bytes`);
console.log(` Created ${chunks.length} chunks`);
console.log(` First chunk: ${chunks[0].length} bytes, type: ${chunks[0].constructor.name}`);
console.log(` First chunk first 4 bytes: [${Array.from(chunks[0].slice(0, 4)).join(', ')}]`);
console.log(` Last chunk: ${chunks[chunks.length-1].length} bytes`);
}
const ltEncoder = new SystematicLTEncoder(chunks);
ltEncoder.systematicChunksPerQR = parseInt(systematicChunksSlider.value);
ltEncoder.fountainMaxDegree = parseInt(fountainDegreeSlider.value);
ltEncoder.currentFileName = fileNameText;
ltEncoder.currentFileSize = fileSizeBytes;
ltEncoder.currentFileType = fileInput.files[0] ? fileInput.files[0].type : '';
fountainPackets = [ltEncoder.generateMetadataPacket()];
const totalPackets = ltEncoder.calculateTotalPackets();
for (let i = 1; i < totalPackets; i++) {
fountainPackets.push(ltEncoder.generatePacket());
}
if (chunks.length > 0) {
const redundantChunk0 = ltEncoder.createSystematicPacket(0);
redundantChunk0.p = ltEncoder.packetCounter;
fountainPackets.push(redundantChunk0);
}
const generatedLTPackets = fountainPackets.filter(p => p.systematic === false && p.metaString === undefined).length;
const systematicPhasePackets = fountainPackets.filter(p => p.systematic === true).length;
const targetLTPackets = Math.ceil(chunks.length * (redundancyPercent / 100));
if (generatedLTPackets < targetLTPackets) {
const additionalPacketsNeeded = targetLTPackets - generatedLTPackets;
for (let i = 0; i < additionalPacketsNeeded; i++) {
ltEncoder.systematicPhase = false;
fountainPackets.push(ltEncoder.createLTPacket());
}
}
totalFrames = fountainPackets.length;
frameCounter.textContent = `Frame: 0 / ${totalFrames}`;
fileName.textContent = fileNameText;
fileSize.textContent = formatFileSize(fileSizeBytes);
chunksCount.textContent = chunks.length;
packetsCount.textContent = fountainPackets.length;
redundancyLevel.textContent = `${redundancyPercent}% (${Math.round((fountainPackets.length / chunks.length - 1) * 100)}% effective)`;
transferTime.textContent = `~${Math.ceil(totalFrames / parseInt(speedSlider.value))} seconds`;
optimalDistance.textContent = calculateOptimalSettings(fileSizeBytes).distance;
const systematicCount = systematicPhasePackets;
const fountainCount = generatedLTPackets + (fountainPackets.length - systematicCount - generatedLTPackets - 1);
if (!document.getElementById('phaseInfo')) {
const phaseInfo = document.createElement('div');
phaseInfo.id = 'phaseInfo';
phaseInfo.className = 'info-row';
phaseInfo.innerHTML = `
<div class="info-label">Encoding Phases:</div><div id="phaseDetails"><div>Systematic: ${systematicCount} packets</div><div>Fountain: ${fountainCount} packets</div></div>
`;
document.getElementById('fileInfo').appendChild(phaseInfo);
} else {
document.getElementById('phaseDetails').innerHTML = `
<div>Systematic: ${systematicCount} packets</div><div>Fountain: ${fountainCount} packets</div>
`;
}
if (!document.getElementById('ltParams') && fountainPackets.length > 0) {
const ltParams = document.createElement('div');
ltParams.id = 'ltParams';
ltParams.className = 'info-row';
ltParams.innerHTML = `
<div class="info-label">LT Parameters:</div><div id="ltDetails"><div>c: ${ltEncoder.c.toFixed(2)}</div><div>Œ¥: ${ltEncoder.delta.toFixed(2)}</div></div>
`;
document.getElementById('fileInfo').appendChild(ltParams);
}
fileInfo.style.display = 'block';
if (preGeneratedQRs.length > 0) {
displayPreGeneratedQR(0, isFullscreen);
currentFrame = 0;
}
return true;
}
startBtn.addEventListener('click', () => {
if (fountainPackets.length === 0) return;
if (countdownSeconds > 0) {
startCountdown();
} else {
startPlaying();
}
});
async function startCountdown() {
let countdown = countdownSeconds;
console.log(`‚è∞ Starting countdown with first QR code visible for camera alignment`);
if (preGeneratedQRs.length > 0) {
displayPreGeneratedQR(0, isFullscreen);
console.log(`üìã First QR code (metadata) displayed during countdown for camera alignment`);
}
countdownDisplay.textContent = countdown;
countdownDisplay.style.display = 'block';
fsCountdownDisplay.textContent = countdown;
fsCountdownDisplay.style.display = isFullscreen ? 'block' : 'none';
if (qrDisplay.querySelector('.countdown-display') === null) {
qrDisplay.appendChild(countdownDisplay);
}
startBtn.disabled = true;
countdownTimer = setInterval(() => {
countdown--;
if (countdown <= 0) {
clearInterval(countdownTimer);
countdownDisplay.style.display = 'none';
fsCountdownDisplay.style.display = 'none';
console.log(`‚è∞ Countdown finished - keeping first metadata QR for additional 3 seconds`);
setTimeout(() => {
console.log(`üìã Additional 3-second metadata display complete - starting sequence from frame 1`);
currentFrame = 1;
startPlayingFromCurrentFrame();
}, 3000);
} else {
countdownDisplay.textContent = countdown;
fsCountdownDisplay.textContent = countdown;
}
}, 1000);
}
async function requestWakeLock() {
try {
if ('wakeLock' in navigator) {
wakeLock = await navigator.wakeLock.request('screen');
console.log('Screen wake lock activated');
wakeLock.addEventListener('release', () => {
console.log('Screen wake lock released');
});
}
} catch (err) {
console.log('Wake lock failed:', err.message);
}
}
function releaseWakeLock() {
if (wakeLock) {
wakeLock.release();
wakeLock = null;
console.log('Screen wake lock released manually');
}
}
function startPlaying() {
console.log(`üé¨ startPlaying() called - beginning QR display`);
console.log(`üìä Total packets available: ${totalPackets}`);
console.log(`üìä Fountain packets array length: ${fountainPackets.length}`);
isPlaying = true;
startBtn.disabled = true;
stopBtn.disabled = false;
currentFrame = 0;
requestWakeLock();
startTime = Date.now();
metadataInfo.style.display = 'block';
transmissionTimer = setInterval(updateTransmissionStats, 1000);
const baseInterval = 1000 / parseInt(speedSlider.value);
let nextFrameDelay = baseInterval;
const scheduleNextFrame = async () => {
displayPreGeneratedQR(currentFrame, isFullscreen);
const currentPacket = fountainPackets[currentFrame];
const isMetadata = currentFrame === 0 || (currentPacket && currentPacket.metaString);
if (isMetadata) {
nextFrameDelay = Math.max(baseInterval * 3, 3000);
console.log(`üìã Metadata QR displayed for ${nextFrameDelay}ms (3x longer)`);
} else {
nextFrameDelay = baseInterval;
}
if (totalFrames > 0) {
currentFrame = (currentFrame + 1) % totalFrames;
console.log(`üìç Frame updated: ${currentFrame}/${totalFrames}`);
} else {
console.error(`‚ùå totalFrames is ${totalFrames}, stopping display`);
return;
}
displayInterval = setTimeout(scheduleNextFrame, nextFrameDelay);
};
scheduleNextFrame();
}
async function preGenerateAllQRCodes() {
console.log(`üè≠ ENTERPRISE: Starting pre-generation with full error handling and validation`);
preGeneratedQRs = [];
if (!fountainPackets || fountainPackets.length === 0) {
throw new Error('ENTERPRISE ERROR: No fountain packets available for QR generation');
}
if (!errorCorrectionSelect || !errorCorrectionSelect.value) {
throw new Error('ENTERPRISE ERROR: Error correction level not set');
}
let successCount = 0;
let errorCount = 0;
const startTime = performance.now();
for (let i = 0; i < fountainPackets.length; i++) {
const packet = fountainPackets[i];
try {
if (!packet) {
throw new Error(`Packet ${i} is null or undefined`);
}
let packetData;
if (packet.metaString) {
packetData = packet.metaString;
if (typeof packetData !== 'string' || packetData.length === 0) {
throw new Error(`Invalid metadata string in packet ${i}`);
}
} else if (packet.dataString) {
packetData = packet.dataString;
if (typeof packetData !== 'string' || packetData.length === 0) {
throw new Error(`Invalid data string in packet ${i}`);
}
} else {
throw new Error(`Packet ${i} has no valid data (no metaString or dataString)`);
}
if (packetData.length > 4000) {
console.warn(`‚ö†Ô∏è ENTERPRISE WARNING: Frame ${i} data length ${packetData.length} may exceed QR capacity`);
}
const qrDataURL = await new Promise((resolve, reject) => {
const timeout = setTimeout(() => {
reject(new Error(`QR generation timeout for frame ${i} after 5 seconds`));
}, 5000);
QRCode.toDataURL(packetData, {
errorCorrectionLevel: errorCorrectionSelect.value,
width: qrSize,
margin: 2,
color: {
dark: '#333333',
light: '#FFFFFF'
}
}, (error, url) => {
clearTimeout(timeout);
if (error) {
reject(new Error(`QRCode.toDataURL failed for frame ${i}: ${error.message}`));
} else if (!url || typeof url !== 'string') {
reject(new Error(`Invalid QR data URL returned for frame ${i}`));
} else {
resolve(url);
}
});
});
preGeneratedQRs[i] = qrDataURL;
successCount++;
if ((i + 1) % 10 === 0 || i === 0 || packet.metaString) {
const packetType = packet.metaString ? 'METADATA' : 'DATA';
console.log(`üé® ENTERPRISE: Pre-generated QR ${i + 1}/${fountainPackets.length} (${packetType}) - Data length: ${packetData.length}`);
}
} catch (error) {
errorCount++;
console.error(`‚ùå ENTERPRISE ERROR: Frame ${i} generation failed:`, error.message);
console.error(`‚ùå ENTERPRISE CONTEXT: Packet type=${packet.metaString ? 'metadata' : packet.dataString ? 'data' : 'unknown'}, qrSize=${qrSize}, errorLevel=${errorCorrectionSelect.value}`);
try {
const errorQR = await new Promise((resolve, reject) => {
QRCode.toDataURL(`ENTERPRISE_ERROR_FRAME_${i}`, {
errorCorrectionLevel: 'M',
width: qrSize,
color: { dark: '#FF0000', light: '#FFFFFF' }
}, (error, url) => {
if (error) reject(error);
else resolve(url);
});
});
preGeneratedQRs[i] = errorQR;
console.log(`üîß ENTERPRISE RECOVERY: Created error QR for frame ${i}`);
} catch (fallbackError) {
console.error(`‚ùå ENTERPRISE CRITICAL: Even fallback QR failed for frame ${i}:`, fallbackError);
preGeneratedQRs[i] = null;
}
}
}
const duration = performance.now() - startTime;
console.log(`‚úÖ ENTERPRISE: Pre-generation complete in ${duration.toFixed(0)}ms`);
console.log(`üìä ENTERPRISE STATS: ${successCount} success, ${errorCount} errors, ${preGeneratedQRs.filter(qr => qr !== null).length} total usable QRs`);
if (successCount === 0) {
throw new Error('ENTERPRISE CRITICAL: No QR codes could be generated');
}
if (errorCount > successCount * 0.1) {
console.warn(`‚ö†Ô∏è ENTERPRISE WARNING: High error rate ${errorCount}/${fountainPackets.length} (${(errorCount/fountainPackets.length*100).toFixed(1)}%)`);
}
}
function displayPreGeneratedQR(frameIndex, forFullscreen = false) {
try {
if (typeof frameIndex !== 'number' || frameIndex < 0) {
throw new Error(`Invalid frame index: ${frameIndex}`);
}
if (frameIndex >= preGeneratedQRs.length) {
throw new Error(`Frame index ${frameIndex} exceeds pre-generated array length ${preGeneratedQRs.length}`);
}
const qrDataURL = preGeneratedQRs[frameIndex];
if (!qrDataURL) {
throw new Error(`No pre-generated QR data for frame ${frameIndex}`);
}
if (typeof qrDataURL !== 'string' || !qrDataURL.startsWith('data:image/')) {
throw new Error(`Invalid QR data URL format for frame ${frameIndex}`);
}
console.log(`üì± ENTERPRISE: Displaying pre-generated QR for frame ${frameIndex}`);
if (forFullscreen) {
if (!fullscreenQR) {
throw new Error('Fullscreen QR element not found');
}
fullscreenQR.src = qrDataURL;
fullscreenQR.onerror = () => {
console.error(`‚ùå ENTERPRISE ERROR: Failed to load QR image for frame ${frameIndex} in fullscreen`);
};
} else {
if (!qrDisplay) {
throw new Error('QR display element not found');
}
qrDisplay.innerHTML = `<img src="${qrDataURL}" alt="QR Code" style="max-width: 100%; max-height: 100%;" onerror="console.error('QR image load failed for frame ${frameIndex}')">`;
}
try {
if (frameCounter) frameCounter.textContent = `Frame: ${frameIndex + 1} / ${totalFrames}`;
try {
updateFrameMetadata(frameIndex);
} catch (metadataError) {
console.warn(`‚ö†Ô∏è ENTERPRISE WARNING: Frame metadata update failed for frame ${frameIndex}:`, metadataError.message);
}
const progress = ((frameIndex + 1) / totalFrames) * 100;
if (progressBar) progressBar.style.width = `${progress}%`;
if (fullscreenProgressBar) fullscreenProgressBar.style.width = `${progress}%`;
} catch (uiError) {
console.warn(`‚ö†Ô∏è ENTERPRISE WARNING: UI update failed for frame ${frameIndex}:`, uiError.message);
}
} catch (error) {
console.error(`‚ùå ENTERPRISE ERROR: Display failed for frame ${frameIndex}:`, error.message);
console.error(`‚ùå ENTERPRISE CONTEXT: forFullscreen=${forFullscreen}, totalFrames=${totalFrames}, preGeneratedQRs.length=${preGeneratedQRs.length}`);
console.log(`üîß ENTERPRISE RECOVERY: Attempting to continue to next frame`);
}
}
function startPlayingFromCurrentFrame() {
console.log(`üé¨ Starting QR sequence from frame ${currentFrame}`);
isPlaying = true;
startBtn.disabled = true;
stopBtn.disabled = false;
const baseInterval = 1000 / parseInt(speedSlider.value);
const scheduleNextFrame = async () => {
displayPreGeneratedQR(currentFrame, isFullscreen);
const currentPacket = fountainPackets[currentFrame];
const isMetadata = currentPacket && currentPacket.metaString;
let nextFrameDelay;
if (isMetadata) {
nextFrameDelay = Math.max(baseInterval * 3, 3000);
console.log(`üìã Metadata QR displayed for ${nextFrameDelay}ms (3x longer)`);
} else {
nextFrameDelay = baseInterval;
}
if (totalFrames > 0) {
currentFrame = (currentFrame + 1) % totalFrames;
console.log(`üìç Frame updated: ${currentFrame}/${totalFrames}`);
} else {
console.error(`‚ùå totalFrames is ${totalFrames}, stopping display`);
return;
}
displayInterval = setTimeout(scheduleNextFrame, nextFrameDelay);
};
scheduleNextFrame();
}
stopBtn.addEventListener('click', () => {
stopPlaying();
});
function stopPlaying() {
if (countdownTimer) {
clearInterval(countdownTimer);
countdownTimer = null;
countdownDisplay.style.display = 'none';
if (isFullscreen) {
fsCountdownDisplay.style.display = 'none';
}
}
if (displayInterval) {
clearTimeout(displayInterval);
displayInterval = null;
}
if (transmissionTimer) {
clearInterval(transmissionTimer);
transmissionTimer = null;
}
releaseWakeLock();
isPlaying = false;
startBtn.disabled = false;
stopBtn.disabled = true;
}
fullscreenBtn.addEventListener('click', () => {
enterFullscreenMode();
if (countdownSeconds > 0) {
startCountdown();
} else {
startPlaying();
}
});
function enterFullscreenMode() {
isFullscreen = true;
fullscreenDisplay.style.display = 'flex';
if (isPlaying) {
stopPlaying();
}
setTimeout(() => {
if (currentFrame >= 0 && preGeneratedQRs.length > 0) {
displayPreGeneratedQR(currentFrame, true);
}
}, 100);
}
exitFullscreenBtn.addEventListener('click', () => {
isFullscreen = false;
fullscreenDisplay.style.display = 'none';
stopPlaying();
});
window.addEventListener('resize', () => {
if (isFullscreen && currentFrame >= 0 && preGeneratedQRs.length > 0) {
setTimeout(() => {
displayPreGeneratedQR(currentFrame, true);
}, 100);
}
});
function updateTransmissionStats() {
if (!isPlaying || !startTime) return;
const elapsed = (Date.now() - startTime) / 1000;
const elapsedFormatted = formatTime(elapsed);
elapsedTime.textContent = elapsedFormatted;
const totalBytes = fileSizeBytes;
const progress = Math.min(currentFrame / totalFrames, 1);
const bytesTransferred = totalBytes * progress;
const bytesPerSecond = bytesTransferred / elapsed;
transmissionSpeed.textContent = `${formatFileSize(bytesPerSecond)}/s`;
}
function formatTime(seconds) {
const mins = Math.floor(seconds / 60);
const secs = Math.floor(seconds % 60);
return `${mins}:${secs.toString().padStart(2, '0')}`;
}
function calculateFullscreenQRSize() {
const viewportWidth = window.innerWidth;
const viewportHeight = window.innerHeight;
const topReserved = 80;
const bottomReserved = 100;
const sideMargin = 40;
const availableWidth = viewportWidth - (sideMargin * 2);
const availableHeight = viewportHeight - topReserved - bottomReserved;
const maxSize = Math.min(availableWidth, availableHeight);
return Math.floor(maxSize * 0.9);
}
async function generateQRCodeForFrame(frameIndex, forFullscreen = false) {
try {
console.log(`üéØ Generating QR for frame ${frameIndex} (fullscreen: ${forFullscreen})`);
if (!fountainPackets[frameIndex]) {
console.error(`‚ùå No packet found for frame ${frameIndex}`);
return;
}
const packet = fountainPackets[frameIndex];
console.log(`üì¶ Packet type: ${packet.metaString ? 'metadata' : 'data'}`);
let packetData;
if (frameIndex === 0 && packet.metaString) {
packetData = packet.metaString;
} else if (packet.dataString) {
packetData = packet.dataString;
}
const options = {
errorCorrectionLevel: errorCorrectionSelect.value,
margin: 1,
width: forFullscreen ? calculateFullscreenQRSize() : qrSize,
color: {
dark: '#000000',
light: '#FFFFFF'
}
};
const qrCodeDataUrl = await new Promise((resolve, reject) => {
QRCode.toDataURL(packetData, options, (error, url) => {
if (error) reject(error);
else resolve(url);
});
});
if (forFullscreen || isFullscreen) {
fullscreenQR.src = qrCodeDataUrl;
fullscreenCounter.textContent = `Frame: ${frameIndex + 1} / ${totalFrames}`;
if (enableTransitionsCheckbox.checked) {
fullscreenQR.classList.add('qr-image');
}
if (countdownDisplay.style.display === 'block') {
fsCountdownDisplay.style.display = 'block';
fsCountdownDisplay.textContent = countdownDisplay.textContent;
} else {
fsCountdownDisplay.style.display = 'none';
}
}
qrDisplay.innerHTML = `<img src="${qrCodeDataUrl}" alt="QR Code" style="max-width: 100%; max-height: 100%;">`;
if (enableTransitionsCheckbox.checked) {
const newImage = qrDisplay.querySelector('img');
if (newImage) {
newImage.classList.add('qr-image');
}
}
if (showGuidesCheckbox.checked) {
const alignmentGuide1 = document.createElement('div');
alignmentGuide1.className = 'alignment-guide';
alignmentGuide1.style = 'width: 90%; height: 90%; top: 5%; left: 5%;';
const alignmentGuide2 = document.createElement('div');
alignmentGuide2.className = 'alignment-guide';
alignmentGuide2.style = 'width: 70%; height: 70%; top: 15%; left: 15%;';
const guideLabel = document.createElement('div');
guideLabel.className = 'guide-label';
guideLabel.style = 'top: 2%; left: 50%; transform: translateX(-50%);';
guideLabel.textContent = 'Keep QR code within this area';
qrDisplay.appendChild(alignmentGuide1);
qrDisplay.appendChild(alignmentGuide2);
qrDisplay.appendChild(guideLabel);
if (showGuidesCheckbox.checked) {
qrDisplay.classList.add('show-guides');
}
}
if (countdownDisplay.style.display === 'block') {
qrDisplay.appendChild(countdownDisplay);
}
frameCounter.textContent = `Frame: ${frameIndex + 1} / ${totalFrames}`;
updateFrameMetadata(frameIndex);
const progress = ((frameIndex + 1) / totalFrames) * 100;
progressBar.style.width = `${progress}%`;
fullscreenProgressBar.style.width = `${progress}%`;
} catch (error) {
console.error(`Error generating QR code for frame ${frameIndex}:`, error);
console.error(`Packet data length: ${packetData ? packetData.length : 'null'}`);
console.error(`Packet type: ${packet.metaString ? 'metadata' : 'data'}`);
try {
const errorQR = await new Promise((resolve, reject) => {
QRCode.toDataURL(`ERROR: Frame ${frameIndex} failed to generate`, {
errorCorrectionLevel: 'M',
width: 400,
color: { dark: '#FF0000', light: '#FFFFFF' }
}, (error, url) => {
if (error) reject(error);
else resolve(url);
});
});
if (forFullscreen && fullscreenQR) {
fullscreenQR.src = errorQR;
} else if (qrDisplay) {
qrDisplay.innerHTML = `<img src="${errorQR}" alt="Error QR Code" style="max-width: 100%; max-height: 100%;">`;
}
console.log(`‚ö†Ô∏è Displayed error QR for frame ${frameIndex}`);
} catch (fallbackError) {
console.error('Even error QR generation failed:', fallbackError);
}
}
}
function updateFrameMetadata(frameIndex) {
try {
const packet = fountainPackets[frameIndex];
if (!packet) {
console.warn(`‚ö†Ô∏è ENTERPRISE: No packet found for frame ${frameIndex} metadata update`);
return;
}
let frameTypeText;
let packetSizeInfo = '';
if (packet.metaString) {
frameTypeText = frameIndex === 0 ? 'Handshake (Setup Data)' : 'File Metadata';
if (currentChunkInfo) currentChunkInfo.style.display = 'none';
const metaSize = packet.metaString.length;
packetSizeInfo = ` (${metaSize} bytes)`;
console.log(`üìã ENTERPRISE: Frame ${frameIndex} is metadata packet (${metaSize} bytes)`);
} else if (packet.dataString) {
if (typeof packet.dataString !== 'string') {
throw new Error(`Invalid dataString type for frame ${frameIndex}: ${typeof packet.dataString}`);
}
const parts = packet.dataString.split(':');
if (parts.length >= 6) {
const packetId = parts[1];
const degree = parts[5];
frameTypeText = `Data Packet (Degree: ${degree})`;
if (currentChunkInfo) currentChunkInfo.style.display = 'block';
if (chunkId) chunkId.textContent = `${packetId} (contains ${degree} chunk${degree > 1 ? 's' : ''})`;
packetSizeInfo = ` (${packet.dataString.length} bytes)`;
} else {
throw new Error(`Invalid dataString format for frame ${frameIndex}: insufficient parts (${parts.length})`);
}
} else {
throw new Error(`Frame ${frameIndex} packet has no valid data (no metaString or dataString)`);
}
if (frameType) {
frameType.textContent = frameTypeText + packetSizeInfo;
} else {
console.warn(`‚ö†Ô∏è ENTERPRISE: frameType element not found for frame ${frameIndex}`);
}
} catch (error) {
console.error(`‚ùå ENTERPRISE ERROR: updateFrameMetadata failed for frame ${frameIndex}:`, error.message);
console.error(`‚ùå ENTERPRISE CONTEXT: packet structure:`, {
hasMetaString: !!fountainPackets[frameIndex]?.metaString,
hasDataString: !!fountainPackets[frameIndex]?.dataString,
packetKeys: fountainPackets[frameIndex] ? Object.keys(fountainPackets[frameIndex]) : 'null'
});
try {
if (frameType) {
frameType.textContent = `Frame ${frameIndex + 1} (metadata parsing failed)`;
}
} catch (fallbackError) {
console.error(`‚ùå ENTERPRISE CRITICAL: Even fallback frame type update failed:`, fallbackError);
}
}
}
function updateProgress() {
const progress = ((currentFrame + 1) / totalFrames) * 100;
progressBar.style.width = `${progress}%`;
if (isFullscreen) {
fullscreenProgressBar.style.width = `${progress}%`;
}
}
function readFileAsBinary(file) {
return new Promise((resolve, reject) => {
const reader = new FileReader();
reader.onload = () => {
const arrayBuffer = reader.result;
resolve(new Uint8Array(arrayBuffer));
};
reader.onerror = reject;
reader.readAsArrayBuffer(file);
});
}
function chunkFileBinary(data, chunkSize) {
const chunks = [];
for (let i = 0; i < data.length; i += chunkSize) {
const chunk = data.slice(i, i + chunkSize);
chunks.push(chunk);
}
return chunks;
}
function readFileAsBase64(file) {
return new Promise((resolve, reject) => {
const reader = new FileReader();
reader.onload = () => resolve(reader.result);
reader.onerror = reject;
reader.readAsDataURL(file);
});
}
function chunkFile(data, chunkSize) {
const chunks = [];
for (let i = 0; i < data.length; i += chunkSize) {
chunks.push(data.slice(i, i + chunkSize));
}
return chunks;
}
function formatFileSize(bytes) {
if (bytes < 1024) return bytes + ' bytes';
else if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
else return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}
class SystematicLTEncoder {
constructor(originalChunks, seedBase = Date.now()) {
this.originalChunks = originalChunks;
this.numChunks = originalChunks.length;
this.seedBase = seedBase;
this.packetCounter = 0;
this.avgChunkSize = this.calculateAverageChunkSize();
this.systematicPhase = true;
this.currentSystematicIndex = 0;
this.systematicChunksPerQR = 2;
this.fountainMaxDegree = 3;
this.c = 0.03;
this.delta = 0.5;
}
calculateAverageChunkSize() {
let sum = 0;
const sampleSize = Math.min(10, this.numChunks);
for (let i = 0; i < sampleSize; i++) {
sum += this.originalChunks[i].length;
}
return Math.ceil(sum / sampleSize);
}
calculateTotalPackets() {
let systematicPackets;
if (this.systematicChunksPerQR >= 2) {
systematicPackets = Math.ceil(this.numChunks / this.systematicChunksPerQR);
} else {
systematicPackets = this.numChunks;
}
const redundancyPercent = parseInt(document.getElementById('redundancySlider').value);
const redundancyFactor = redundancyPercent / 100;
const additionalPackets = Math.ceil(this.numChunks * redundancyFactor);
const extraPackets = this.systematicChunksPerQR >= 2 ? Math.ceil(this.numChunks * 0.1) : 0;
return systematicPackets + additionalPackets + extraPackets;
}
generatePacket() {
if (this.systematicPhase) {
const maxQRSize = document.getElementById('highDensityCheckbox').checked ?
HIGH_DENSITY_QR_CONTENT_SIZE : DEFAULT_QR_CONTENT_SIZE;
if (this.systematicChunksPerQR >= 2 &&
this.currentSystematicIndex < this.numChunks &&
this.numChunks - 1 - this.currentSystematicIndex >= 0) {
const packet = this.createDualSystematicPacket(
this.currentSystematicIndex,
this.numChunks - 1 - this.currentSystematicIndex
);
this.currentSystematicIndex++;
if (this.currentSystematicIndex >= this.numChunks) {
this.systematicPhase = false;
}
return packet;
} else {
const packet = this.createSystematicPacket(this.currentSystematicIndex);
this.currentSystematicIndex++;
if (this.currentSystematicIndex >= this.numChunks) {
this.systematicPhase = false;
}
return packet;
}
}
return this.createLTPacket();
}
createSystematicPacket(chunkIndex) {
const chunkData = this.originalChunks[chunkIndex];
const seed = this.seedBase + this.packetCounter;
const chunkBase64 = this.arrayBufferToBase64(chunkData);
const combinedData = `${chunkIndex}:${chunkBase64}`;
const dataString = `D:${this.packetCounter}:${seed}:${this.seedBase}:${this.numChunks}:1:${combinedData}`;
if (debugMode) {
console.log(`üîç ENCODER DEBUG - Single systematic packet ${this.packetCounter}:`);
console.log(` Chunk ${chunkIndex}: ${chunkData.length} bytes`);
console.log(` Chunk type: ${chunkData.constructor.name}`);
console.log(` First 4 bytes: [${Array.from(chunkData.slice(0, 4)).join(', ')}]`);
console.log(` Base64 length: ${chunkBase64.length} chars`);
console.log(` Base64 preview: ${chunkBase64.substring(0, 20)}...`);
console.log(` Base64 valid: ${/^[A-Za-z0-9+/]*={0,2}$/.test(chunkBase64)}`);
console.log(` Combined data length: ${combinedData.length} chars`);
console.log(` Combined preview: ${combinedData.substring(0, 30)}...`);
console.log(` Final packet length: ${dataString.length} chars`);
console.log(` Final packet preview: ${dataString.substring(0, 80)}...`);
}
const packet = {
format: "compact",
dataString: dataString,
s: seed,
d: 1,
p: this.packetCounter++,
n: this.numChunks,
b: this.seedBase,
systematic: true
};
this.checkAndHandlePacketSize(packet);
return packet;
}
createDualSystematicPacket(firstChunkIndex, secondChunkIndex) {
const firstChunkData = this.originalChunks[firstChunkIndex];
const secondChunkData = this.originalChunks[secondChunkIndex];
if (debugMode) {
console.log(`üîç ENCODER DEBUG - Dual systematic packet ${this.packetCounter}:`);
console.log(` Chunk ${firstChunkIndex}: ${firstChunkData.length} bytes, type: ${firstChunkData.constructor.name}`);
console.log(` Chunk ${secondChunkIndex}: ${secondChunkData.length} bytes, type: ${secondChunkData.constructor.name}`);
console.log(` First chunk first 4 bytes: [${Array.from(firstChunkData.slice(0, 4)).join(', ')}]`);
console.log(` Second chunk first 4 bytes: [${Array.from(secondChunkData.slice(0, 4)).join(', ')}]`);
}
const seed = this.seedBase + this.packetCounter;
const firstChunkBase64 = this.arrayBufferToBase64(firstChunkData);
const secondChunkBase64 = this.arrayBufferToBase64(secondChunkData);
const combinedData = `${firstChunkIndex}:${firstChunkBase64}|${secondChunkIndex}:${secondChunkBase64}`;
const dataString = `D:${this.packetCounter}:${seed}:${this.seedBase}:${this.numChunks}:2:${combinedData}`;
if (debugMode) {
console.log(` First base64: ${firstChunkBase64.length} chars, preview: ${firstChunkBase64.substring(0, 20)}...`);
console.log(` First base64 valid: ${/^[A-Za-z0-9+/]*={0,2}$/.test(firstChunkBase64)}`);
console.log(` Second base64: ${secondChunkBase64.length} chars, preview: ${secondChunkBase64.substring(0, 20)}...`);
console.log(` Second base64 valid: ${/^[A-Za-z0-9+/]*={0,2}$/.test(secondChunkBase64)}`);
console.log(` Combined data length: ${combinedData.length} chars`);
console.log(` Combined preview: ${combinedData.substring(0, 50)}...`);
console.log(` Contains invalid chars: ${/[^A-Za-z0-9+/=:|]/.test(combinedData)}`);
console.log(` Final packet length: ${dataString.length} chars`);
console.log(` Final packet preview: ${dataString.substring(0, 100)}...`);
}
const packet = {
format: "compact",
dataString: dataString,
s: seed,
d: 2,
p: this.packetCounter++,
n: this.numChunks,
b: this.seedBase,
systematic: true
};
this.checkAndHandlePacketSize(packet);
return packet;
}
createLTPacket() {
const seed = this.seedBase + this.packetCounter;
const rng = this.createPRNG(seed);
const degree = this.getRobustSolitonDegree(rng);
const selectedIndices = this.selectChunksLT(degree, rng);
const fountainData = this.xorChunks(selectedIndices);
const indicesStr = selectedIndices.join(',');
const base64Data = this.arrayBufferToBase64(fountainData);
const dataString = `D:${this.packetCounter}:${seed}:${this.seedBase}:${this.numChunks}:1:${indicesStr}:${base64Data}`;
const packet = {
format: "enhanced",
dataString: dataString,
s: seed,
d: degree,
p: this.packetCounter++,
n: this.numChunks,
b: this.seedBase,
systematic: false,
sourceIndices: selectedIndices,
fountainData: fountainData
};
this.checkAndHandlePacketSize(packet);
return packet;
}
checkAndHandlePacketSize(packet) {
const maxQRSize = document.getElementById('highDensityCheckbox').checked ?
HIGH_DENSITY_QR_CONTENT_SIZE : DEFAULT_QR_CONTENT_SIZE;
const packetSize = packet.dataString.length;
if (packetSize > maxQRSize * 0.9) {
this.truncatePacket(packet, maxQRSize * 0.9);
}
}
truncatePacket(packet, maxSize) {
const parts = packet.dataString.split(":", 6);
const header = parts.slice(0, 6).join(":");
const headerSize = header.length + 1;
const availableSize = maxSize - headerSize;
const originalData = packet.dataString.substring(headerSize);
const originalLength = originalData.length;
const truncatedData = originalData.substring(0, availableSize);
packet.dataString = `${header}:${truncatedData}`;
packet.truncated = true;
packet.dataString = `${packet.dataString}:t:${originalLength}`;
}
createPRNG(seed) {
let s = seed;
return function() {
s = Math.sin(s) * 10000;
return s - Math.floor(s);
};
}
getRobustSolitonDegree(rng) {
if (this.numChunks <= 1) return 1;
const c = this.c;
const delta = this.delta;
const R = c * Math.log(this.numChunks / delta) * Math.sqrt(this.numChunks);
const maxDegree = Math.min(this.fountainMaxDegree, this.numChunks);
const r = rng();
let cdf = 0;
const p1 = (1.0 / this.numChunks) + (R / this.numChunks);
cdf += p1;
if (r < cdf) return 1;
for (let d = 2; d <= maxDegree; d++) {
let p_std = 1.0 / (d * (d - 1));
let p_robust = 0;
if (d <= Math.floor(this.numChunks / R)) {
p_robust = R / (d * this.numChunks);
} else if (d === Math.floor(this.numChunks / R)) {
p_robust = (R * Math.log(R / delta)) / this.numChunks;
}
cdf += p_std + p_robust;
if (r < cdf) return d;
}
return maxDegree;
}
selectChunksLT(degree, rng) {
const indices = [];
const actualDegree = Math.min(degree, this.numChunks);
while (indices.length < actualDegree) {
const index = Math.floor(rng() * this.numChunks);
if (!indices.includes(index)) {
indices.push(index);
}
}
return indices;
}
combineChunks(indices) {
if (indices.length === 0) return "";
const stringFormat = indices.map(index => {
return `${index}:${this.originalChunks[index]}`;
}).join("|");
const fountainData = this.xorChunks(indices);
return stringFormat;
}
xorChunks(indices) {
if (indices.length === 0) return new Uint8Array(0);
const firstChunk = this.ensureUint8Array(this.originalChunks[indices[0]]);
if (indices.length === 1) return firstChunk;
let maxLength = firstChunk.length;
for (let i = 1; i < indices.length; i++) {
const chunkData = this.ensureUint8Array(this.originalChunks[indices[i]]);
maxLength = Math.max(maxLength, chunkData.length);
}
const result = new Uint8Array(maxLength);
result.set(firstChunk);
for (let i = 1; i < indices.length; i++) {
const chunkIndex = indices[i];
const chunkData = this.ensureUint8Array(this.originalChunks[chunkIndex]);
for (let j = 0; j < Math.min(result.length, chunkData.length); j++) {
result[j] ^= chunkData[j];
}
}
return result;
}
stringToUint8Array(str) {
const arr = new Uint8Array(str.length);
for (let i = 0; i < str.length; i++) {
arr[i] = str.charCodeAt(i);
}
return arr;
}
ensureUint8Array(data) {
if (data instanceof Uint8Array) {
return data;
}
if (typeof data === 'string') {
return this.stringToUint8Array(data);
}
return new Uint8Array(data);
}
arrayBufferToBase64(buffer) {
let binary = '';
const bytes = new Uint8Array(buffer);
for (let i = 0; i < bytes.length; i++) {
binary += String.fromCharCode(bytes[i]);
}
return btoa(binary);
}
generateMetadataPacket() {
const fileNameText = this.currentFileName || document.getElementById('fileName').textContent;
const fileSizeBytes = this.currentFileSize || (fileInput.files[0] ? fileInput.files[0].size : 0);
const fileType = this.currentFileType || (fileInput.files[0] ? fileInput.files[0].type : '');
const fps = parseInt(document.getElementById('speedSlider').value);
const systematicChunks = parseInt(document.getElementById('systematicChunksSlider').value);
const fountainMaxDegree = parseInt(document.getElementById('fountainDegreeSlider').value);
const chunkSize = parseInt(document.getElementById('chunkSlider').value);
const redundancy = parseInt(document.getElementById('redundancySlider').value);
const highDensityMode = document.getElementById('highDensityCheckbox').checked ? 1 : 0;
const ecLevel = document.getElementById('errorCorrectionSelect').value;
const fileChecksum = this.calculateFileChecksumFromChunks(this.originalChunks);
const checksumData = `${fileNameText}:${fileSizeBytes}:${this.numChunks}`;
const metaChecksum = this.simpleChecksum(checksumData);
const ltParams = `${this.c}:${this.delta}`;
const metadataString = `M:3.0:${encodeURIComponent(fileNameText)}:${encodeURIComponent(fileType)}:${fileSizeBytes}:${this.numChunks}:${this.calculateTotalPackets()}:${systematicChunks}:${highDensityMode}:${fps}:${chunkSize}:${redundancy}:${ecLevel}:${metaChecksum}:${fileChecksum}:${ltParams}:${fountainMaxDegree}`;
console.log(`üìã METADATA DEBUG:`);
console.log(` fileName: "${fileNameText}"`);
console.log(` fileType: "${fileType}"`);
console.log(` fileSize: ${fileSizeBytes}`);
console.log(` metadata string: ${metadataString.substring(0, 100)}...`);
const packet = {
format: "compact",
metaString: metadataString,
s: this.seedBase,
p: this.packetCounter++,
n: this.numChunks,
b: this.seedBase
};
return packet;
}
calculateFileChecksum(binaryData) {
if (!binaryData) {
console.warn('calculateFileChecksum: binaryData is null, returning default');
return 'nullchk';
}
let hash = 0;
for (let i = 0; i < binaryData.length; i++) {
hash = ((hash << 5) - hash) + binaryData[i];
hash = hash & hash;
}
return Math.abs(hash).toString(36).substring(0, 8);
}
calculateFileChecksumFromChunks(chunks) {
if (!chunks || chunks.length === 0) {
console.warn('calculateFileChecksumFromChunks: chunks is null/empty, returning default');
return 'nochunk';
}
let hash = 0;
for (const chunk of chunks) {
for (let i = 0; i < chunk.length; i++) {
hash = ((hash << 5) - hash) + chunk[i];
hash = hash & hash;
}
}
return Math.abs(hash).toString(36).substring(0, 8);
}
simpleChecksum(str) {
let hash = 0;
for (let i = 0; i < str.length; i++) {
hash = ((hash << 5) - hash) + str.charCodeAt(i);
hash = hash & hash;
}
return Math.abs(hash).toString(36).substring(0, 6);
}
}</script></body></html>