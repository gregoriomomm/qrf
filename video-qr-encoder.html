// 1. Set-by-Set Metadata Implementation

// Restructure the metadata and frame generation system
function updateTotalFramesCount() {
    // Count how many chunks are in selected sets
    let selectedChunksCount = 0;
    let selectedSetsCount = 0;
    
    // Enhanced logging information
    let setDetails = [];
    
    selectedSets.forEach((isSelected, index) => {
        if (isSelected) {
            selectedSetsCount++;
            const setSize = sets[index].length;
            selectedChunksCount += setSize;
            setDetails.push(`Set ${index + 1}: ${setSize} chunks`);
            log(`Set ${index + 1}: ${setSize} chunks included`, false);
        }
    });
    
    // Show detailed set information
    if (setDetails.length > 0) {
        log(`Selected sets breakdown:\n${setDetails.join('\n')}`, false);
    }
    
    // Calculate total frames:
    // 1 for global metadata + 1 per selected set metadata + all chunks + 1 end frame
    totalFrames = 1 + selectedSetsCount + selectedChunksCount + 1;
    
    log(`Selected ${selectedSetsCount} sets with ${selectedChunksCount} chunks`);
    log(`Total frames to display: ${totalFrames}`);
    log(`Frame breakdown: 1 global metadata + ${selectedSetsCount} set metadata + ${selectedChunksCount} chunks + 1 end frame`, false);
    
    updateProgress(0, totalFrames);
}

// Enhanced getFrameContent function with set-specific metadata
function getFrameContent(frameIndex) {
    let frameContent = '';
    let frameLabel = '';
    let frameType = 'chunk';
    
    if (frameIndex === 0) {
        // Global metadata frame
        const includeFileQueueInfo = fileQueue.length > 1;
        
        // Calculate exact number of chunks from selected sets
        let selectedChunksCount = 0;
        let selectedSetIndices = [];
        
        selectedSets.forEach((isSelected, index) => {
            if (isSelected) {
                selectedChunksCount += sets[index].length;
                selectedSetIndices.push(index);
            }
        });
        
        const metadata = {
            type: "global_metadata",
            file_name: fileName,
            file_size: fileSize,
            total_sets: sets.length,
            total_selected_sets: selectedSets.filter(Boolean).length,
            chunks_per_set: SET_SIZE_CHUNKS,
            total_chunks: selectedChunksCount,
            actual_chunks_count: selectedChunksCount,
            timestamp: Date.now(),
            qr_grid_size: parseInt(gridLayoutSelect.value),
            chunks_per_selected_set: selectedSetIndices.map(idx => sets[idx].length),
            version: "2.0" // Version to help decoder identify the protocol
        };
        
        // Add file queue information if multiple files
        if (includeFileQueueInfo) {
            metadata.file_index = currentFileIndex + 1;
            metadata.total_files = fileQueue.length;
            metadata.remaining_files = fileQueue.length - currentFileIndex - 1;
        }
        
        // Add selected sets information
        metadata.selected_sets = selectedSets.map((selected, index) => 
            selected ? index + 1 : null).filter(Boolean);
        
        frameContent = JSON.stringify(metadata);
        frameLabel = "Global Metadata";
        frameType = 'metadata';
        
    } else {
        // Calculate set boundaries for new set-specific metadata placement
        let currentFrame = 1; // Start after global metadata
        let setMetadataIndices = [];
        let setFirstChunkIndices = [];
        let totalChunks = 0;
        
        // Calculate frame indices for set-specific metadata and first chunks
        selectedSets.forEach((isSelected, setIndex) => {
            if (!isSelected) return;
            
            // This is the index of the set metadata frame
            setMetadataIndices.push(currentFrame);
            currentFrame++;
            
            // This is the index of the first chunk in this set
            setFirstChunkIndices.push(currentFrame);
            currentFrame += sets[setIndex].length;
            
            totalChunks += sets[setIndex].length;
        });
        
        // Check if this is a set metadata frame
        const setMetadataIndex = setMetadataIndices.indexOf(frameIndex);
        if (setMetadataIndex !== -1) {
            // This is a set metadata frame
            const setIndex = selectedSets.findIndex((selected, idx) => 
                selected && setMetadataIndices.indexOf(frameIndex) === setMetadataIndices.findIndex(i => 
                    selectedSets[idx] && i === frameIndex
                )
            );
            
            // Get global chunk offset for this set
            let globalChunkOffset = 0;
            for (let i = 0; i < setIndex; i++) {
                if (selectedSets[i]) {
                    globalChunkOffset += sets[i].length;
                }
            }
            
            const setMetadata = {
                type: "set_metadata",
                set_index: setIndex + 1,
                total_sets: selectedSets.filter(Boolean).length,
                chunks_in_set: sets[setIndex].length,
                global_chunk_offset: globalChunkOffset,
                file_name: fileName, // Include file info in each set metadata
                timestamp: Date.now()
            };
            
            frameContent = JSON.stringify(setMetadata);
            frameLabel = `Set ${setIndex + 1} Metadata`;
            frameType = 'set_metadata';
        }
        // End frame check
        else if (frameIndex === totalFrames - 1) {
            // Enhanced end frame with verification data
            const selectedChunksCount = selectedSets.reduce((count, selected, index) => 
                selected ? count + sets[index].length : count, 0);
            
            const endData = {
                type: "end",
                file_name: fileName,
                file_size: fileSize,
                total_chunks_sent: selectedChunksCount,
                selected_sets: selectedSets.map((selected, index) => 
                    selected ? index + 1 : null).filter(Boolean),
                chunks_per_selected_set: selectedSets.map((selected, index) => 
                    selected ? sets[index].length : 0).filter(count => count > 0),
                timestamp: Date.now(),
                version: "2.0"
            };
            
            frameContent = JSON.stringify(endData);
            frameLabel = "End Frame";
            frameType = 'end';
        }
        // Must be a chunk frame
        else {
            // Find which set and chunk this corresponds to
            let currentPosition = 1; // Start after global metadata
            let targetSet = -1;
            let localChunkIndex = -1;
            
            for (let i = 0; i < selectedSets.length; i++) {
                if (!selectedSets[i]) continue;
                
                // Skip set metadata frame
                currentPosition++;
                
                // Check if the frameIndex is within this set's chunks
                if (currentPosition <= frameIndex && frameIndex < currentPosition + sets[i].length) {
                    targetSet = i;
                    localChunkIndex = frameIndex - currentPosition;
                    break;
                }
                
                // Move past this set's chunks
                currentPosition += sets[i].length;
            }
            
            if (targetSet !== -1 && localChunkIndex !== -1) {
                // Calculate global chunk index
                let globalChunkIndex = 0;
                for (let i = 0; i < targetSet; i++) {
                    if (selectedSets[i]) {
                        globalChunkIndex += sets[i].length;
                    }
                }
                globalChunkIndex += localChunkIndex;
                
                // Create enhanced chunk data
                const chunkData = {
                    type: "chunk",
                    set_index: targetSet + 1,
                    chunk_index: localChunkIndex + 1,
                    chunks_in_set: sets[targetSet].length,
                    global_chunk_index: globalChunkIndex,
                    data: sets[targetSet][localChunkIndex] || ""
                };
                
                frameContent = JSON.stringify(chunkData);
                frameLabel = `Set ${targetSet + 1}, Chunk ${localChunkIndex + 1}`;
                frameType = 'chunk';
            } else {
                // Error case - shouldn't happen with proper indexing
                frameContent = JSON.stringify({ 
                    error: "Invalid chunk index", 
                    index: frameIndex,
                    totalFrames: totalFrames
                });
                frameLabel = "Error";
                frameType = 'error';
            }
        }
    }
    
    return { content: frameContent, label: frameLabel, type: frameType };
}

// 2. Enhanced Set Selection Interface
function enhanceSetSelectionInterface() {
    // Make the sets selection panel more prominent
    setsSelectionPanel.style.background = '#f0f7ff';
    setsSelectionPanel.style.border = '2px solid #1890ff';
    setsSelectionPanel.style.borderRadius = '8px';
    setsSelectionPanel.style.padding = '15px';
    setsSelectionPanel.style.margin = '20px 0';
    setsSelectionPanel.style.boxShadow = '0 2px 8px rgba(24, 144, 255, 0.2)';
    
    // Add a clear title
    const titleDiv = document.createElement('div');
    titleDiv.innerHTML = `<h3 style="margin-top:0; color:#1890ff;">Set Selection for Transfer</h3>
                          <p style="margin-bottom:15px;">Select which sets to include in the transmission. 
                          Each set contains a portion of the file data.</p>`;
    setsSelectionPanel.insertBefore(titleDiv, setsSelectionPanel.firstChild);
    
    // Add a "Resend Selected Sets" button
    const resendButton = document.createElement('button');
    resendButton.id = 'resendSetsBtn';
    resendButton.textContent = 'Prepare Selected Sets for Transfer';
    resendButton.style.marginTop = '15px';
    resendButton.style.backgroundColor = '#52c41a';
    resendButton.style.color = 'white';
    resendButton.style.border = 'none';
    resendButton.style.borderRadius = '4px';
    resendButton.style.padding = '10px 15px';
    resendButton.style.cursor = 'pointer';
    resendButton.style.fontSize = '14px';
    resendButton.style.fontWeight = 'bold';
    resendButton.disabled = true;
    
    // Add button to the sets selection panel
    const buttonContainer = document.createElement('div');
    buttonContainer.style.display = 'flex';
    buttonContainer.style.justifyContent = 'center';
    buttonContainer.style.marginTop = '15px';
    buttonContainer.appendChild(resendButton);
    setsSelectionPanel.appendChild(buttonContainer);
    
    // Add event listener for the resend button
    resendButton.addEventListener('click', function() {
        // Recalculate frames based on current selection
        updateTotalFramesCount();
        // Enable start button
        startBtn.disabled = false;
        // Provide feedback to the user
        log(`Prepared ${selectedSets.filter(Boolean).length} sets for transmission.`);
        // Update time estimates
        updateEstimatedTime();
    });
    
    // Enhance the set checkboxes for better visibility
    const enhanceSetCheckboxes = function() {
        const checkboxes = setsSelectionList.querySelectorAll('.set-checkbox');
        checkboxes.forEach((checkbox, index) => {
            // Add more visual cues
            checkbox.style.display = 'flex';
            checkbox.style.flexDirection = 'column';
            checkbox.style.alignItems = 'center';
            checkbox.style.justifyContent = 'center';
            checkbox.style.padding = '10px';
            checkbox.style.height = '70px';
            checkbox.style.transition = 'all 0.2s';
            
            // Add set size information
            if (sets[index]) {
                const sizeText = document.createElement('div');
                sizeText.style.fontSize = '11px';
                sizeText.style.marginTop = '5px';
                sizeText.textContent = `${sets[index].length} chunks`;
                checkbox.appendChild(sizeText);
                
                // Add size indicator (approx. KB)
                const totalSize = sets[index].reduce((size, chunk) => size + (chunk ? chunk.length : 0), 0);
                const sizeKB = Math.round((totalSize * 3/4) / 1024); // Approximate base64 to binary conversion
                
                const sizeIndicator = document.createElement('div');
                sizeIndicator.style.fontSize = '10px';
                sizeIndicator.style.color = '#666';
                sizeIndicator.textContent = `~${sizeKB} KB`;
                checkbox.appendChild(sizeIndicator);
            }
            
            // Enhance hover effect
            checkbox.addEventListener('mouseenter', function() {
                checkbox.style.transform = 'scale(1.05)';
                checkbox.style.boxShadow = '0 0 8px rgba(24, 144, 255, 0.5)';
            });
            
            checkbox.addEventListener('mouseleave', function() {
                checkbox.style.transform = 'scale(1)';
                checkbox.style.boxShadow = 'none';
            });
        });
        
        // Enable the resend button when at least one set is selected
        const updateResendButton = function() {
            const anySelected = selectedSets.some(Boolean);
            resendButton.disabled = !anySelected;
        };
        
        // Update button state when selection changes
        checkboxes.forEach(checkbox => {
            checkbox.addEventListener('click', updateResendButton);
        });
        
        // Initial button state
        updateResendButton();
    };
    
    // Override the original updateGrid function to include our enhancements
    const originalCreateSetSelection = window.createSetSelection || function() {};
    
    window.createSetSelection = function() {
        // Call the original function if it exists
        if (typeof originalCreateSetSelection === 'function') {
            originalCreateSetSelection();
        }
        
        // Apply our enhancements
        setTimeout(enhanceSetCheckboxes, 100);
    };
    
    // Add function to mark sets that need resending
    window.markSetsForResending = function(setIndices) {
        if (!Array.isArray(setIndices) || setIndices.length === 0) return;
        
        const checkboxes = setsSelectionList.querySelectorAll('.set-checkbox');
        
        // First, deselect all sets
        selectedSets = Array(sets.length).fill(0);
        checkboxes.forEach(checkbox => {
            checkbox.style.backgroundColor = '#f5f5f5';
            checkbox.style.border = '1px solid #d9d9d9';
        });
        
        // Then select only the sets that need resending
        setIndices.forEach(index => {
            if (index >= 0 && index < selectedSets.length) {
                selectedSets[index] = 1;
                
                // Update the UI if the checkbox exists
                if (index < checkboxes.length) {
                    checkboxes[index].style.backgroundColor = '#e6f7ff';
                    checkboxes[index].style.border = '1px solid #1890ff';
                    // Add a "Needs Resending" indicator
                    const resendIndicator = document.createElement('div');
                    resendIndicator.style.fontSize = '10px';
                    resendIndicator.style.color = 'red';
                    resendIndicator.style.fontWeight = 'bold';
                    resendIndicator.style.marginTop = '5px';
                    resendIndicator.textContent = 'Needs Resending';
                    checkboxes[index].appendChild(resendIndicator);
                }
            }
        });
        
        // Update the button state
        const anySelected = selectedSets.some(Boolean);
        resendButton.disabled = !anySelected;
        
        // Show a notification
        log(`Marked ${setIndices.length} sets for resending.`);
    };
}

// 3. Full-Screen Presentation Mode Fixes
function enterPresentationMode() {
    if (isPresentation) return;
    
    try {
        // Store current frame/content before switching modes
        const currentFrameNumber = currentFrame;
        const currentContent = getFrameContent(currentFrame);
        
        // Setup presentation mode
        presentationOverlay.style.display = 'flex';
        isPresentation = true;
        
        // Update presentation info
        presentationCounter.textContent = frameCounter.textContent;
        
        // Calculate and display estimated transmission time
        const fps = parseInt(speedSlider.value);
        const totalTimeSeconds = calculateEstimatedTime(totalFrames, fps);
        const presentationFilename = document.getElementById('presentationFilename');
        const presentationEstTime = document.getElementById('presentationEstTime');
        const presentationRemaining = document.getElementById('presentationRemaining');
        
        presentationFilename.textContent = `Transmitting: ${fileName}`;
        presentationEstTime.textContent = `Est. Time: ${formatTime(totalTimeSeconds)}`;
        
        // Update remaining time if we're already playing
        if (isPlaying && remainingSeconds > 0) {
            if (presentationRemaining) {
                presentationRemaining.textContent = `Remaining: ${formatTime(remainingSeconds)}`;
            }
            // Update presentation with current content
            updatePresentationView(currentContent.content, currentContent.label);
        }
        
        // Improved fullscreen implementation
        try {
            const elem = document.documentElement;
            
            if (elem.requestFullscreen) {
                elem.requestFullscreen().catch(e => {
                    log("Info: Fullscreen mode error: " + e.message, false);
                });
            } else if (elem.mozRequestFullScreen) { /* Firefox */
                elem.mozRequestFullScreen();
            } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) { /* IE/Edge */
                elem.msRequestFullscreen();
            } else {
                log("Info: Fullscreen mode not supported by this browser", false);
            }
        } catch (err) {
            log("Info: Fullscreen API error: " + err.message, false);
            // Continue without fullscreen - position fixed should still make it work
        }
        
        // Ensure presentation overlay has correct styling
        presentationOverlay.style.position = 'fixed';
        presentationOverlay.style.top = '0';
        presentationOverlay.style.left = '0';
        presentationOverlay.style.width = '100%';
        presentationOverlay.style.height = '100%';
        presentationOverlay.style.zIndex = '9999';
        presentationOverlay.style.backgroundColor = '#000';
        presentationOverlay.style.display = 'flex';
        presentationOverlay.style.flexDirection = 'column';
        presentationOverlay.style.justifyContent = 'center';
        presentationOverlay.style.alignItems = 'center';
        
        // Make sure all controls are visible in presentation mode
        presentationHeader.style.zIndex = '10000';
        exitPresentationBtn.style.zIndex = '10000';
        
        // Responsive sizing for QR display
        const resizeQrDisplay = function() {
            const qrSize = Math.min(window.innerWidth, window.innerHeight) * 0.8;
            presentationQrDisplay.style.width = qrSize + 'px';
            presentationQrDisplay.style.height = qrSize + 'px';
        };
        
        // Initial sizing
        resizeQrDisplay();
        
        // Add resize listener
        window.addEventListener('resize', resizeQrDisplay);
        
        log("Entered presentation mode successfully", false);
    } catch (error) {
        log("Error entering presentation mode: " + error.message, true);
        // Continue in regular mode
    }
}

// 4. Multiple File Queue Support Enhancements
function enhanceFileQueueSystem() {
    // Make file queue panel more prominent
    fileQueuePanel.style.background = '#f5f5f5';
    fileQueuePanel.style.border = '2px solid #d9d9d9';
    fileQueuePanel.style.borderRadius = '8px';
    fileQueuePanel.style.padding = '15px';
    fileQueuePanel.style.margin = '20px 0';
    fileQueuePanel.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';
    
    // Add a title
    const titleDiv = document.createElement('div');
    titleDiv.innerHTML = `<h3 style="margin-top:0;">File Queue</h3>
                         <p style="margin-bottom:15px;">Select files to transfer in sequence.</p>`;
    fileQueuePanel.insertBefore(titleDiv, fileQueuePanel.firstChild);
    
    // Add a clear button to remove all files
    const clearQueueBtn = document.createElement('button');
    clearQueueBtn.textContent = 'Clear Queue';
    clearQueueBtn.style.backgroundColor = '#f5f5f5';
    clearQueueBtn.style.color = '#333';
    clearQueueBtn.style.border = '1px solid #d9d9d9';
    clearQueueBtn.style.marginLeft = '10px';
    
    // Add event listener for the clear button
    clearQueueBtn.addEventListener('click', function() {
        fileQueue = [];
        fileQueueList.innerHTML = '';
        currentFileIndex = 0;
        updateQueueControls();
        log('File queue cleared.');
        
        // Update the input element to allow new selections
        fileInput.value = '';
        
        // Disable generate button if queue is empty
        generateBtn.disabled = true;
    });
    
    // Add the clear button to the file queue panel
    const buttonContainer = fileQueuePanel.querySelector('div');
    if (buttonContainer) {
        buttonContainer.appendChild(clearQueueBtn);
    }
    
    // Enhance file queue items with better information
    const updateFileQueueDisplay = function() {
        const items = fileQueueList.querySelectorAll('.file-queue-item');
        items.forEach((item, index) => {
            // Add more detailed information
            const fileItem = fileQueue[index];
            if (!fileItem) return;
            
            // Check if already has enhanced info
            if (item.querySelector('.file-details')) return;
            
            // Create detailed info
            const detailsDiv = document.createElement('div');
            detailsDiv.className = 'file-details';
            detailsDiv.style.fontSize = '11px';
            detailsDiv.style.color = '#666';
            detailsDiv.style.marginTop = '5px';
            
            // Add file info
            detailsDiv.innerHTML = `Size: ${formatFileSize(fileItem.size)} | Type: ${fileItem.file.type || 'Unknown'}`;
            
            // Add details to item
            item.appendChild(detailsDiv);
            
            // Highlight active item more clearly
            if (index === currentFileIndex) {
                item.style.backgroundColor = '#e6f7ff';
                item.style.border = '1px solid #1890ff';
                item.style.boxShadow = '0 0 5px rgba(24, 144, 255, 0.3)';
                
                const activeIndicator = document.createElement('div');
                activeIndicator.style.position = 'absolute';
                activeIndicator.style.top = '5px';
                activeIndicator.style.right = '5px';
                activeIndicator.style.backgroundColor = '#1890ff';
                activeIndicator.style.color = 'white';
                activeIndicator.style.padding = '2px 5px';
                activeIndicator.style.borderRadius = '3px';
                activeIndicator.style.fontSize = '10px';
                activeIndicator.textContent = 'Active';
                
                // Make sure the item is relative positioned for absolute positioning to work
                item.style.position = 'relative';
                item.appendChild(activeIndicator);
            }
        });
    };
    
    // Override the refreshQueueDisplay function to include our enhancements
    const originalRefreshQueueDisplay = window.refreshQueueDisplay;
    
    window.refreshQueueDisplay = function() {
        // Call the original function
        originalRefreshQueueDisplay();
        
        // Apply our enhancements
        setTimeout(updateFileQueueDisplay, 100);
    };
    
    // Make generated file queues display immediately
    fileQueuePanel.style.display = 'block';
}

// 5. Enhanced Debug and Log Visibility
function enhanceDebugAndLogVisibility() {
    // Style the debug view for better visibility
    debugView.style.fontFamily = 'monospace';
    debugView.style.fontSize = '12px';
    debugView.style.lineHeight = '1.5';
    debugView.style.padding = '10px';
    debugView.style.backgroundColor = '#f5f5f5';
    debugView.style.border = '1px solid #d9d9d9';
    debugView.style.borderRadius = '4px';
    debugView.style.whiteSpace = 'pre-wrap';
    debugView.style.tabSize = '2';
    debugView.style.overflowX = 'auto';
    
    // Add a clear debug button
    const clearDebugBtn = document.createElement('button');
    clearDebugBtn.textContent = 'Clear Debug Log';
    clearDebugBtn.style.margin = '10px 0';
    clearDebugBtn.style.padding = '5px 10px';
    clearDebugBtn.style.backgroundColor = '#f5f5f5';
    clearDebugBtn.style.border = '1px solid #d9d9d9';
    clearDebugBtn.style.borderRadius = '4px';
    clearDebugBtn.style.cursor = 'pointer';
    
    // Add event listener
    clearDebugBtn.addEventListener('click', function() {
        debugLogs = [];
        debugView.textContent = '';
        log('Debug log cleared.');
    });
    
    // Add button before debug view
    const debugTab = document.querySelector('.tab-content[data-tab-content="debug"]');
    if (debugTab) {
        debugTab.insertBefore(clearDebugBtn, debugView);
    }
    
    // Enhance the status element
    statusEl.style.fontFamily = 'monospace';
    statusEl.style.fontSize = '12px';
    statusEl.style.lineHeight = '1.5';
    statusEl.style.padding = '10px';
    statusEl.style.backgroundColor = '#f0f7ff';
    statusEl.style.border = '1px solid #d9d9d9';
    statusEl.style.borderRadius = '4px';
    statusEl.style.whiteSpace = 'pre-wrap';
    
    // Create a floating status panel for important messages
    const floatingStatus = document.createElement('div');
    floatingStatus.id = 'floatingStatus';
    floatingStatus.style.position = 'fixed';
    floatingStatus.style.bottom = '20px';
    floatingStatus.style.right = '20px';
    floatingStatus.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    floatingStatus.style.color = '#fff';
    floatingStatus.style.padding = '10px 15px';
    floatingStatus.style.borderRadius = '5px';
    floatingStatus.style.maxWidth = '300px';
    floatingStatus.style.zIndex = '9999';
    floatingStatus.style.display = 'none';
    floatingStatus.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.2)';
    floatingStatus.style.transition = 'opacity 0.3s';
    
    document.body.appendChild(floatingStatus);
    
    // Enhance the log function to also show important messages in the floating status
    const originalLog = window.log;
    
    window.log = function(message, isError = false) {
        // Call the original log function
        originalLog(message, isError);
        
        // For important messages, also show in floating status
        if (isError || message.includes('received') || message.includes('complete') || 
            message.includes('Starting') || message.includes('Frame')) {
            
            floatingStatus.textContent = message;
            floatingStatus.style.display = 'block';
            floatingStatus.style.backgroundColor = isError ? 'rgba(255, 0, 0, 0.8)' : 'rgba(0, 0, 0, 0.8)';
            
            // Auto-hide after 3 seconds
            setTimeout(function() {
                floatingStatus.style.opacity = '0';
                
                // Actually hide after fade out
                setTimeout(function() {
                    floatingStatus.style.display = 'none';
                    floatingStatus.style.opacity = '1';
                }, 300);
            }, 3000);
        }
    };
}

// Call all the enhancement functions during initialization
document.addEventListener('DOMContentLoaded', function() {
    // Add these functions to the window so they can be called
    window.enhanceSetSelectionInterface = enhanceSetSelectionInterface;
    window.enhanceFileQueueSystem = enhanceFileQueueSystem;
    window.enhanceDebugAndLogVisibility = enhanceDebugAndLogVisibility;
    
    // Apply the enhancements
    setTimeout(function() {
        enhanceSetSelectionInterface();
        enhanceFileQueueSystem();
        enhanceDebugAndLogVisibility();
        
        // Log initialization complete
        log('UI enhancements applied successfully.');
    }, 500);
});
