<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>QR Code File Decoder</title><style>.log-filter,body{color:var(--text-color)}.close,button{cursor:pointer}:root{--primary-color:#2563eb;--secondary-color:#1d4ed8;--success-color:#10b981;--warning-color:#f59e0b;--error-color:#ef4444;--text-color:#1f2937;--bg-color:#f9fafb;--panel-bg:#ffffff;--border-color:#e5e7eb}*{box-sizing:border-box;margin:0;padding:0}body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;line-height:1.5;background-color:var(--bg-color);padding:20px;max-width:1200px;margin:0 auto}h1,h2{margin-bottom:1rem}button{background-color:var(--primary-color);color:#fff;border:none;padding:8px 16px;border-radius:4px;font-weight:500;transition:background-color .2s}.control-panel,.video-container{background-color:var(--panel-bg);border-radius:8px;margin-bottom:20px;padding:15px;box-shadow:0 1px 3px rgba(0,0,0,.1)}button:hover{background-color:var(--secondary-color)}button:disabled{background-color:#9ca3af;cursor:not-allowed}input[type=file]{margin-right:10px}.control-panel{display:flex;justify-content:space-between;align-items:center}.controls{display:flex;gap:10px}.video-container{position:relative}video{width:100%;max-height:400px;background-color:#000;border-radius:4px}canvas{position:absolute;top:15px;left:15px;pointer-events:none}#saveSettingsBtn,.progress-container{margin-top:10px}.progress-bar{height:10px;background-color:var(--primary-color);width:0%;border-radius:5px;transition:width .3s}.progress-text{font-size:14px;margin-top:5px;text-align:right}.chunks-container,.file-info-container{background-color:var(--panel-bg);padding:15px;border-radius:8px;box-shadow:0 1px 3px rgba(0,0,0,.1);margin-bottom:20px}.chunk,.chunk.pending{background-color:rgba(229,231,235,.5)}.chunks-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(20px,1fr));gap:4px;margin-top:10px}.chunk{height:20px;border:1px solid var(--border-color);border-radius:2px;transition:background-color .3s}.chunk.received{background-color:rgba(16,185,129,.2);border-color:var(--success-color)}.chunk.blinking{animation:.5s blink}@keyframes blink{0%{background-color:rgba(245,158,11,.5)}100%{background-color:rgba(16,185,129,.2)}}#downloadContainer{margin-top:15px}#downloadBtn{background-color:var(--success-color)}#downloadBtn:hover{background-color:#0d9668}.debug-container{background-color:var(--panel-bg);padding:15px;border-radius:8px;box-shadow:0 1px 3px rgba(0,0,0,.1)}.log-controls{display:flex;gap:8px;margin-bottom:10px}.log-filter{background-color:#e5e7eb;font-size:12px;padding:4px 8px}.log-filter.active{background-color:var(--primary-color);color:#fff}.log-window{height:200px;overflow-y:auto;border:1px solid var(--border-color);border-radius:4px;padding:10px;font-family:monospace;font-size:13px;background-color:#f1f5f9}.log-entry{margin-bottom:4px;border-bottom:1px solid rgba(229,231,235,.5);padding-bottom:4px}.log-debug{color:#6b7280}.log-info{color:#1d4ed8}.log-warn{color:#b45309}.log-error{color:#b91c1c}.modal{display:none;position:fixed;z-index:1000;left:0;top:0;width:100%;height:100%;background-color:rgba(0,0,0,.5)}.modal-content{background-color:var(--panel-bg);margin:10% auto;padding:20px;border-radius:8px;max-width:500px;box-shadow:0 4px 6px rgba(0,0,0,.1);position:relative}.close,.scan-line{position:absolute}.close{right:15px;top:10px;font-size:24px}.settings-group{margin-bottom:15px}.settings-group label{display:block;margin-bottom:5px}.settings-group input{width:100%;padding:8px;border:1px solid var(--border-color);border-radius:4px}.error-message{background-color:#fef2f2;border-left:4px solid var(--error-color);padding:15px;margin-bottom:20px;color:#b91c1c;display:none}#resetBtn{background-color:var(--warning-color)}#resetBtn:hover{background-color:#e08c00}.scan-line{height:2px;background-color:rgba(16,185,129,.8);animation:2s infinite scan-animation}@keyframes scan-animation{0%,100%{opacity:.5}50%{opacity:1}}@media (max-width:768px){.control-panel{flex-direction:column;align-items:flex-start}.controls{margin-top:10px;width:100%;flex-wrap:wrap}video{max-height:300px}.chunks-grid{grid-template-columns:repeat(auto-fill,minmax(15px,1fr))}.chunk{height:15px}}</style></head><body><div id="errorMessage" class="error-message"></div><header class="control-panel"><h1>QR Code File Decoder</h1><div class="controls"><input type="file" id="videoInput" accept="video/*"> <button id="startScanBtn" disabled="disabled">Start Scan & Discover</button> <button id="continueBtn" disabled="disabled" style="background-color: #10b981;">Continue</button> <button id="stopScanBtn" disabled="disabled">Stop Scan</button> <button id="resetBtn">Reset Contents</button> <button id="settingsBtn">Advanced Settings</button></div></header><div class="file-info-container"><h2>File Information</h2><div id="fileInfo">No file detected yet</div><div id="checksumInfo" style="display: none; margin-top: 10px; font-size: 14px; color: #6b7280;"><div>File Checksum: <span id="fileChecksum">-</span></div><div>Meta Checksum: <span id="metaChecksum">-</span></div></div><div id="missingChunks">Waiting for metadata...</div><div id="downloadContainer" style="display: none;"><button id="downloadBtn">Download Recovered File</button></div></div><div class="video-container"><video id="videoPreview" controls></video><canvas id="overlayCanvas"></canvas><div class="progress-container"><div class="progress-bar" id="scanProgressBar"></div><div class="progress-text" id="scanProgressText">Frames: 0/0 | Time Remaining: --:-- | Loop: 1</div><div class="loop-info" id="loopInfo" style="font-size: 12px; margin-top: 5px; color: #666;">Status: Processing video...</div></div></div><div class="chunks-container"><h2>Chunk Recovery Progress</h2><div class="chunks-grid" id="chunksGrid"></div></div><div id="discoveredFilesContainer" class="file-info-container" style="display: none;"><h2>Discovered Files in Video</h2><div id="discoveredFilesList"></div><div style="margin-top: 10px; font-size: 12px; color: #666;">Click a file button to start decoding from that file's position in the video</div></div><div class="debug-container"><h2>Debug Log</h2><div class="log-controls"><button class="log-filter active" data-level="all">All</button> <button class="log-filter" data-level="debug">Debug</button> <button class="log-filter" data-level="info">Info</button> <button class="log-filter" data-level="warn">Warnings</button> <button class="log-filter" data-level="error">Errors</button> <button id="clearLogBtn">Clear Log</button> <button id="copyLogBtn">Copy Debug Log</button></div><div class="log-window" id="logWindow"></div></div><div id="settingsModal" class="modal"><div class="modal-content"><span class="close">&times;</span><h2>Advanced Settings</h2><div class="settings-group"><label for="workerCount">QR Processing Workers:</label> <input type="number" id="workerCount" min="1" max="16" value="4"></div><div class="settings-group"><label for="packetWorkerCount">Packet Processing Workers:</label> <input type="number" id="packetWorkerCount" min="1" max="8" value="2"></div><div class="settings-group"><label for="frameInterval">Frame Processing Interval (ms):</label> <input type="number" id="frameInterval" min="0" max="1000" value="20"></div><div class="settings-group"><label for="qrDetectionConfidence">QR Detection Confidence (0-1):</label> <input type="number" id="qrDetectionConfidence" min="0" max="1" step="0.1" value="0.5"></div><button id="saveSettingsBtn">Save Settings</button></div></div><script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script><script>let debugMode=!1;document.addEventListener("keydown",(e=>{e.ctrlKey&&e.shiftKey&&"D"===e.key&&(debugMode=!debugMode,console.log("🔧 Debug mode: "+(debugMode?"ENABLED":"DISABLED")))})),document.addEventListener("visibilitychange",(()=>{document.hidden&&console.warn("⚠️ Tab backgrounded - QR processing may be throttled by browser. Keep tab active for best performance.")}));class Logger{constructor(e){this.logElement=document.getElementById(e),this.filter="all",this.maxEntries=500,this.entries=[]}debug(e){this.log("debug",e)}info(e){this.log("info",e)}warn(e){this.log("warn",e)}error(e){this.log("error",e)}log(e,t){const i={timestamp:new Date,level:e,message:t};this.entries.push(i),this.entries.length>this.maxEntries&&this.entries.shift();const o=document.createElement("div");o.className=`log-entry log-${e}`;const s=i.timestamp.toLocaleTimeString();o.innerHTML=`[${s}] [${e.toUpperCase()}] ${t}`,"all"!==this.filter&&this.filter!==e&&(o.style.display="none"),this.logElement.appendChild(o),this.logElement.scrollTop=this.logElement.scrollHeight}clear(){this.logElement.innerHTML="",this.entries=[]}setFilter(e){this.filter=e;this.logElement.querySelectorAll(".log-entry").forEach((t=>{if("all"===e)t.style.display="";else{const i=Array.from(t.classList).find((e=>e.startsWith("log-"))).replace("log-","");t.style.display=i===e?"":"none"}}))}}class UI{constructor(e){this.logger=e,this.overlayCanvas=document.getElementById("overlayCanvas"),this.overlayCtx=this.overlayCanvas.getContext("2d")}resetChunkGrid(){document.getElementById("chunksGrid").innerHTML="",document.getElementById("scanProgressBar").style.width="0%",document.getElementById("scanProgressText").textContent="Frames: 0/0 | Time Remaining: --:--",document.getElementById("downloadContainer").style.display="none"}initializeChunkGrid(e){const t=document.getElementById("chunksGrid");t.innerHTML="";for(let i=0;i<e;i++){const e=document.createElement("div");e.className="chunk pending",e.dataset.index=i,t.appendChild(e)}}updateProgress(e,t,i,o){document.getElementById("scanProgressBar").style.width=100*e+"%";const s=document.getElementById("scanProgressText"),n=`${Math.floor(o/60)}:${Math.floor(o%60).toString().padStart(2,"0")}`,r=window.qrFileDecoder?.videoProcessor?.loopCount||1;s.textContent=`Frames: ${t}/${i} | Time Remaining: ${n} | Loop: ${r}`}updateFileInfo(e){document.getElementById("fileInfo").innerHTML=e}blinkChunk(e){const t=document.querySelector(`.chunk[data-index="${e}"]`);t&&(t.classList.remove("blinking"),t.offsetWidth,t.classList.add("blinking"))}markChunkAsRecovered(e){const t=document.querySelector(`.chunk[data-index="${e}"]`);t&&(t.classList.remove("pending"),t.classList.add("received"))}showSettingsModal(){if(window.qrFileDecoder&&window.qrFileDecoder.settings){const e=window.qrFileDecoder.settings;document.getElementById("workerCount").value=e.workerCount,document.getElementById("packetWorkerCount").value=e.packetWorkerCount,document.getElementById("frameInterval").value=e.frameInterval,document.getElementById("qrDetectionConfidence").value=e.qrDetectionConfidence}document.getElementById("settingsModal").style.display="block"}hideSettingsModal(){document.getElementById("settingsModal").style.display="none"}updateLogFilterButtons(e){document.querySelectorAll(".log-filter").forEach((e=>{e.classList.remove("active")})),e.classList.add("active")}showErrorMessage(e){const t=document.getElementById("errorMessage");t.textContent=e,t.style.display="block"}hideErrorMessage(){document.getElementById("errorMessage").style.display="none"}drawQRHighlight(e,t,i,o,s=10){const n=document.getElementById("videoPreview");this.overlayCanvas.width===n.clientWidth&&this.overlayCanvas.height===n.clientHeight||(this.overlayCanvas.width=n.clientWidth,this.overlayCanvas.height=n.clientHeight),this.overlayCtx.clearRect(0,0,this.overlayCanvas.width,this.overlayCanvas.height);const r=n.clientWidth/n.videoWidth,a=n.clientHeight/n.videoHeight,l=(e-s)*r,c=(t-s-30)*a,d=Math.max((i+2*s)*r,(o+2*s)*a),h=d,u=d;this.overlayCtx.strokeStyle="#10b981",this.overlayCtx.lineWidth=3,this.overlayCtx.beginPath(),this.overlayCtx.rect(l,0,h,u),this.overlayCtx.stroke();const g=u/4;this.overlayCtx.beginPath();for(let e=1;e<=3;e++){const t=c+g*e;this.overlayCtx.moveTo(l,t),this.overlayCtx.lineTo(l+h,t)}this.overlayCtx.stroke();const m=15;this.overlayCtx.fillStyle="#10b981",this.overlayCtx.fillRect(l-7.5,c-7.5,m,m),this.overlayCtx.fillRect(l+h-7.5,c-7.5,m,m),this.overlayCtx.fillRect(l-7.5,c+u-7.5,m,m),this.overlayCtx.fillRect(l+h-7.5,c+u-7.5,m,m)}clearQRHighlight(){this.overlayCtx&&this.overlayCtx.clearRect(0,0,this.overlayCanvas.width,this.overlayCanvas.height)}}class PacketProcessor{constructor(){}processQRData(e,t){try{if(e.startsWith("M:"))return this.processMetadataPacket(e,t);if(e.startsWith("D:"))return this.processDataPacket(e,t);throw new Error(`Unknown packet format: ${e.substring(0,10)}...`)}catch(e){return{success:!1,error:e.message,frameIndex:t}}}processMetadataPacket(e,t){const i=e.split(":");if(i.length<10)throw new Error(`Invalid metadata packet format: ${e.substring(0,30)}...`);let o=-1;try{o=parseInt(i[4])}catch(e){console.error(`Invalid file size: ${i[4]}`)}const s={protocolVersion:i[1],fileName:this.decodeURIComponentSafe(i[2]),fileType:this.decodeURIComponentSafe(i[3]),fileSize:o,chunksCount:parseInt(i[5]),packetCount:parseInt(i[6]),maxDegree:parseInt(i[7]),density:parseFloat(i[8]),fps:i[9],chunkSize:parseInt(i[10]||"1024"),redundancy:parseInt(i[11]||"0"),ecl:i[12]||"L",metaChecksum:i[13]||"",fileChecksum:i[14]||"",ltParams:i.slice(15).join(":")};if((isNaN(s.fileSize)||s.fileSize<=0)&&(s.fileSize=-1,console.error(`Invalid file size: ${i[4]}`)),isNaN(s.chunksCount)||s.chunksCount<=0)throw new Error(`Invalid chunk count: ${i[5]}`);return{success:!0,packetType:"metadata",packetData:s,frameIndex:t}}processDataPacket(e,t){const i=e.split(":");if(i.length<7)throw new Error(`Invalid data packet format: ${e.substring(0,30)}...`);const o=parseInt(i[1]),s=parseInt(i[2]),n=parseInt(i[3]),r=parseInt(i[4]),a=parseInt(i[5]);let l=[],c=[],d=null,h="standard";if(i[6]&&i[6].includes(",")){const e=i[6].split(",").map((e=>parseInt(e))),t=e.length;console.debug(`Fountain packet ${o} with degree=${t} (XOR of ${e.join(",")})`),h="enhanced",l=e;try{d=this.base64ToUint8Array(i[7])}catch(e){throw console.error(`Failed to decode fountain XOR data: ${e.message}`),e}}else{debugMode&&console.debug(`Systematic packet ${o} with chunkCount=${a}`);const e=i.slice(6).join(":").split("|");debugMode&&console.debug(`Processing ${e.length} systematic records (expected: ${a})`);for(let t=0;t<e.length;t++){const i=e[t],o=i.split(":",2);if(2===o.length){const e=parseInt(o[0]),i=o[1];e>=0&&e<r?(l.push(e),c.push({chunkIndex:e,chunkData:i}),console.debug(`  Record ${t+1}: chunk ${e} (${i.length} base64 chars)`)):console.warn(`  Invalid chunk index ${e} in record ${t+1}`)}else console.warn(`  Invalid record format: ${i}`)}}let u=!1,g=0;if("enhanced"!==h&&"legacy"!==h){const e=i.slice(6).join(":"),t=e.indexOf(":t:");if(t>0){u=!0;const i=e.substring(t+3).split(":");g=parseInt(i[0]||"0")}}return{success:!0,packetType:"data",packetData:{packetId:o,seed:s,seedBase:n,chunkCount:a,actualDegree:"enhanced"===h?l.length:a,fountainData:d,systematicDataChunks:c,sourceChunks:l,isDegreeOne:1===a,isSystematic:"enhanced"!==h,isTruncated:u,originalLength:g,format:h},frameIndex:t}}decodeURIComponentSafe(e){try{return decodeURIComponent(e)}catch(t){return e}}createPRNG(e){let t=e;return function(){return t=1e4*Math.sin(t),t-Math.floor(t)}}selectChunksLT(e,t,i){const o=[],s=Math.min(t,i);for(;o.length<s;){const t=Math.floor(e()*i);o.includes(t)||o.push(t)}return o}stringToUint8Array(e){const t=new Uint8Array(e.length);for(let i=0;i<e.length;i++)t[i]=e.charCodeAt(i);return t}xorUint8Arrays(e,t){const i=Math.min(e.length,t.length);for(let o=0;o<i;o++)e[o]^=t[o]}base64ToUint8Array(e){try{const t=atob(e),i=new Uint8Array(t.length);for(let e=0;e<t.length;e++)i[e]=t.charCodeAt(e);return i}catch(e){return console.error("Error decoding base64:",e),new Uint8Array(0)}}isValidBase64(e){if(!e||0===e.length)return!1;if(!/^[A-Za-z0-9+/]*={0,2}$/.test(e))return!1;if(e.length%4!=0)return!1;try{return atob(e),!0}catch(e){return!1}}}class EnhancedFountainDecoder{constructor(){this.initialized=!1,this.metaData=null,this.totalChunks=0,this.sourceChunks={},this.recoveredChunkCount=0,this.codedPackets=[],this.completeCallback=null,this.newlyRecoveredChunks=[],this.lastProcessedChunk=-1,this.fileCompleted=!1,this.packetStats={total:0,degree1:0,degreeN:0,usefulPackets:0}}initialize(e){this.metaData=e,this.totalChunks=e.chunksCount,this.initialized=!0,this.sourceChunks={},this.recoveredChunkCount=0,this.codedPackets=[],this.newlyRecoveredChunks=[],this.fileCompleted=!1,this.packetStats={total:0,degree1:0,degreeN:0,usefulPackets:0},console.log(`Fountain decoder initialized with ${e.chunksCount} chunks, file size: ${e.fileSize} bytes`)}setCompleteCallback(e){this.completeCallback=e}addPacket(e){if(!this.initialized)throw new Error("Fountain decoder not initialized");if(this.packetStats.total++,e.isSystematic){e.isDegreeOne?this.packetStats.degree1++:this.packetStats.degreeN++;let t=!1;return e.systematicDataChunks.forEach((e=>{const i=e.chunkIndex;if(!this.sourceChunks[i]){let o;try{if(o=this.base64ToUint8Array(e.chunkData),debugMode&&(console.log(`🔍 DECODER DEBUG - Processing chunk ${i}:`),console.log(`  Base64 data length: ${e.chunkData.length} chars`),console.log(`  Base64 preview: ${e.chunkData.substring(0,30)}...`),console.log(`  ✅ Base64 decode SUCCESS: ${o.length} bytes`),console.log(`  Decoded first 4 bytes: [${Array.from(o.slice(0,4)).join(", ")}]`),0===i)){const e=255===o[0]&&216===o[1];console.log("  📸 Chunk 0 JPEG header check: "+(e?"✅":"❌"))}}catch(t){console.warn(`❌ Failed to decode base64 for chunk ${i}: ${t.message}`),debugMode&&(console.warn(`  Error details: ${t.stack}`),console.warn(`  Base64 data: ${e.chunkData.substring(0,50)}...`)),console.warn("  Using string conversion fallback"),o=this.stringToUint8Array(e.chunkData),debugMode&&console.warn(`  String conversion result: ${o.length} bytes, first 4: [${Array.from(o.slice(0,4)).join(", ")}]`)}this.storeSourceChunk(i,o),this.newlyRecoveredChunks.push(i),t=!0}})),!!t&&(this.packetStats.usefulPackets++,this.propagateAndDecode(),!0)}this.packetStats.degreeN++;const t=e.sourceChunks.filter((e=>!this.sourceChunks[e]));if(0===t.length)return this.recoveredChunkCount===this.totalChunks&&(console.log("All chunks recovered! Finalizing file..."),this.finalizeFile()),!1;if(1===t.length){const i=t[0],o=new Uint8Array(e.fountainData.length);o.set(e.fountainData);for(const t of e.sourceChunks)t!==i&&this.sourceChunks[t]&&this.xorData(o,this.sourceChunks[t]);return this.storeSourceChunk(i,o),this.newlyRecoveredChunks.push(i),this.packetStats.usefulPackets++,this.propagateAndDecode(),!0}return this.codedPackets.push(e),!0}propagateAndDecode(){let e=!1;for(let t=1;t<=5;t++){let i=!1,o=0;const s=100;console.log(`🔄 Starting decoding pass ${t}/5, recovered: ${this.recoveredChunkCount}/${this.totalChunks}`);do{i=!1,o++;for(let o=this.codedPackets.length-1;o>=0;o--){const s=this.codedPackets[o],n=s.sourceChunks.filter((e=>!this.sourceChunks[e]));if(0!==n.length){if(1===n.length){const r=n[0],a=new Uint8Array(s.fountainData.length);a.set(s.fountainData);for(const e of s.sourceChunks)e!==r&&this.sourceChunks[e]&&this.xorData(a,this.sourceChunks[e]);this.storeSourceChunk(r,a),this.newlyRecoveredChunks.push(r),this.packetStats.usefulPackets++,this.codedPackets.splice(o,1),i=!0,e=!0,console.log(`✅ Pass ${t}: Recovered chunk ${r}, now ${this.recoveredChunkCount}/${this.totalChunks}`)}}else this.codedPackets.splice(o,1)}if(o>=s){console.warn(`⚠️ Pass ${t}: Hit iteration limit (${s}), moving to next pass`);break}}while(i&&this.recoveredChunkCount<this.totalChunks);if(console.log(`📊 Pass ${t} completed: ${o} iterations, progress: ${i}`),this.recoveredChunkCount===this.totalChunks){console.log(`🎉 All chunks recovered in pass ${t}!`);break}!i&&t<5&&console.log(`⚠️ No progress in pass ${t}, continuing to pass ${t+1}`)}if(this.recoveredChunkCount===this.totalChunks)console.log("🎯 All chunks recovered! Finalizing file..."),this.finalizeFile();else{const e=this.codedPackets.length,t=(this.recoveredChunkCount/this.totalChunks*100).toFixed(1);console.log(`📈 Decoding complete: ${this.recoveredChunkCount}/${this.totalChunks} chunks (${t}%), ${e} packets remaining`)}}storeSourceChunk(e,t){this.sourceChunks[e]||(t instanceof Uint8Array||(console.warn(`Chunk ${e} data is not a Uint8Array. Converting...`),t=this.ensureUint8Array(t)),this.sourceChunks[e]=t,this.recoveredChunkCount++,console.debug(`Stored chunk ${e}, now have ${this.recoveredChunkCount}/${this.totalChunks} chunks`),e>this.lastProcessedChunk&&(this.lastProcessedChunk=e))}ensureUint8Array(e){return e instanceof Uint8Array?e:"string"==typeof e?this.stringToUint8Array(e):Array.isArray(e)||ArrayBuffer.isView(e)?new Uint8Array(e):(console.error("Unknown data type, cannot convert to Uint8Array:",typeof e),new Uint8Array(0))}stringToUint8Array(e){const t=new Uint8Array(e.length);for(let i=0;i<e.length;i++)t[i]=e.charCodeAt(i);return t}xorData(e,t){const i=Math.min(e.length,t.length);for(let o=0;o<i;o++)e[o]^=t[o]}base64ToUint8Array(e){try{const t=atob(e),i=new Uint8Array(t.length);for(let e=0;e<t.length;e++)i[e]=t.charCodeAt(e);return i}catch(e){throw new Error(`Base64 decode failed: ${e.message}`)}}getNewlyRecoveredChunks(){const e=[...this.newlyRecoveredChunks];return this.newlyRecoveredChunks=[],e}getRecoveryProgress(){return{recovered:this.recoveredChunkCount,total:this.totalChunks,percentage:Math.round(this.recoveredChunkCount/this.totalChunks*100),packetStats:this.packetStats}}finalizeFile(){if(this.fileCompleted)console.log("File already completed, ignoring duplicate finalization call");else{this.fileCompleted=!0,console.log("Finalizing file reconstruction..."),console.log(`Recovery stats: ${this.recoveredChunkCount}/${this.totalChunks} chunks`),console.log(`Packet stats: ${JSON.stringify(this.packetStats)}`);try{for(let e=0;e<this.totalChunks;e++){if(!this.sourceChunks[e])return void console.error(`Missing chunk ${e} during file reconstruction, cannot finalize`);window.qrFileDecoder&&window.qrFileDecoder.ui&&window.qrFileDecoder.ui.markChunkAsRecovered(e)}let e=this.metaData.fileSize;if(isNaN(e)||e<=0){e=0;for(let t=0;t<this.totalChunks;t++)e+=this.sourceChunks[t].length;console.log(`File size not provided in metadata, calculated: ${e} bytes`)}let t=new Uint8Array(e),i=0;const o=this.metaData.chunkSize||this.sourceChunks[0].length;console.log(`Using chunk size: ${o} bytes`),console.log(`📋 Reconstructing file from ${this.totalChunks} chunks...`);for(let e=0;e<this.totalChunks;e++){const o=this.sourceChunks[e];if(!o){console.error(`❌ Chunk ${e} is missing`);continue}if(!(o instanceof Uint8Array)){console.error(`❌ Chunk ${e} is not a Uint8Array: ${typeof o}`);continue}0===e&&this.metaData.fileType&&this.metaData.fileType.includes("jpeg")&&(255===o[0]&&216===o[1]||(console.warn(`⚠️  Chunk 0 doesn't start with JPEG header [${o[0]}, ${o[1]}] - may indicate chunk order issue`),console.warn(`Expected: [255, 216], Got: [${o[0]}, ${o[1]}]`)));const s=Math.min(o.length,Math.max(0,t.length-i));if(s>0)try{t.set(o.subarray(0,s),i),i+=s}catch(n){if(console.error(`Error copying chunk ${e}:`,n),console.error(`Chunk length: ${o.length}, bytesToCopy: ${s}, offset: ${i}, fileData.length: ${t.length}`),!(i+o.length>t.length))throw n;{console.log(`Expanding buffer from ${t.length} to ${i+o.length}`);const e=new Uint8Array(i+o.length);e.set(t.subarray(0,i)),t=e,t.set(o,i),i+=o.length}}else if(i<t.length){console.log(`Buffer too small, expanding from ${t.length} to ${i+o.length}`);const e=new Uint8Array(i+o.length);e.set(t.subarray(0,i)),t=e,t.set(o,i),i+=o.length}}if(console.log(`File reconstruction complete. Total size: ${t.length} bytes`),t.length>this.metaData.fileSize&&(console.log(`Trimming file from ${t.length} to ${this.metaData.fileSize} bytes`),t=t.slice(0,this.metaData.fileSize)),console.log(`Final file size: ${t.length} bytes`),this.metaData.fileChecksum){const e=this.calculateFileChecksum(t),i=this.metaData.fileChecksum;e===i?console.log(`✅ File integrity verified: checksum ${e}`):(console.error("❌ File integrity check FAILED!"),console.error(`Expected: ${i}, Got: ${e}`),console.error("File may be corrupted - check chunk order and data integrity"))}else console.warn("⚠️  No file checksum available for verification");if(this.metaData.fileType&&this.metaData.fileType.includes("jpeg")){const e=this.verifyJPEGStructure(t);console.log("📸 JPEG structure: "+(e?"✅ Valid":"❌ Invalid")),e||console.error("❌ JPEG structure is invalid - check chunk reconstruction order")}console.log("🔍 ENTERPRISE CHUNK ANALYSIS:"),console.log(`  Total chunks expected: ${this.totalChunks}`),console.log(`  Chunks recovered: ${this.recoveredChunkCount}`),console.log("  Missing chunks: "+(this.totalChunks-this.recoveredChunkCount)),console.log(`  Source chunks available: ${Object.keys(this.sourceChunks).length}`),console.log(`  File size from metadata: ${this.metaData.fileSize} bytes`);this.recoveredChunkCount>=this.totalChunks?(console.log(`✅ ENTERPRISE: File truly complete - all ${this.totalChunks} chunks recovered`),this.completeCallback&&this.completeCallback(t)):(console.warn(`⚠️ ENTERPRISE: File reconstruction attempted but missing ${this.totalChunks-this.recoveredChunkCount} chunks`),console.log(`📊 ENTERPRISE: Only ${this.recoveredChunkCount}/${this.totalChunks} chunks available - file incomplete`),console.log("🔄 ENTERPRISE: Will continue processing to find missing chunks in subsequent loops"))}catch(e){console.error("Error finalizing file:",e)}}}arrayBufferToString(e){return new TextDecoder("utf-8").decode(e)}base64ToArrayBuffer(e){try{const t=atob(e),i=new Uint8Array(t.length);for(let e=0;e<t.length;e++)i[e]=t.charCodeAt(e);return i}catch(e){throw console.error("Base64 decoding error:",e),e}}calculateFileChecksum(e){let t=0;for(let i=0;i<e.length;i++)t=(t<<5)-t+e[i],t|=0;return Math.abs(t).toString(36).substring(0,8)}verifyJPEGStructure(e){if(e.length<4)return!1;const t=255===e[0]&&216===e[1],i=255===e[e.length-2]&&217===e[e.length-1];return t&&i}}class WorkerPoolManager{constructor(e,t){this.workerScript=e,this.workerCount=Math.max(1,Math.min(t,16)),this.workers=[],this.busyWorkers=new Set,this.taskQueue=[],this.resultCallback=null,this.errorCallback=null,this.initializeWorkers()}initializeWorkers(){for(let e=0;e<this.workerCount;e++)try{const e=new Worker(this.workerScript);e.onmessage=t=>{this.resultCallback&&this.resultCallback(t.data),this.busyWorkers.delete(e),this.processNextTask()},e.onerror=t=>{console.error("Worker error:",t),this.errorCallback&&this.errorCallback(t),this.busyWorkers.delete(e),this.processNextTask()},this.workers.push(e)}catch(e){console.error("Failed to create worker:",e),this.errorCallback&&this.errorCallback(e)}}setResultCallback(e){this.resultCallback=e}setErrorCallback(e){this.errorCallback=e}processTask(e){this.taskQueue.push(e),this.processNextTask()}processNextTask(){if(0===this.taskQueue.length||this.busyWorkers.size===this.workers.length)return;const e=this.workers.find((e=>!this.busyWorkers.has(e)));if(!e)return;this.busyWorkers.add(e);const t=this.taskQueue.shift();e.postMessage(t)}terminate(){this.workers.forEach((e=>e.terminate())),this.workers=[],this.busyWorkers.clear(),this.taskQueue=[]}getQueueLength(){return this.taskQueue.length}getBusyWorkerCount(){return this.busyWorkers.size}}class EnhancedVideoProcessor{constructor(e){this.frameCallback=e.frameCallback,this.progressCallback=e.progressCallback,this.errorCallback=e.errorCallback,this.frameInterval=e.frameInterval||20,this.videoElement=document.getElementById("videoPreview"),this.videoFile=null,this.processedFrames=0,this.totalFrames=0,this.startTime=0,this.isProcessing=!1,this.processTimer=null,this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d",{willReadFrequently:!0}),this.frameStats={processed:0,qrCodesDetected:0,processingTimes:[]}}static isWebCodecsSupported(){return"function"==typeof window.VideoDecoder&&"function"==typeof window.VideoEncoder&&"function"==typeof window.EncodedVideoChunk}async initialize(e){this.videoFile=e,this.processedFrames=0,this.frameStats={processed:0,qrCodesDetected:0,processingTimes:[]};try{const t=URL.createObjectURL(e);return this.videoElement.src=t,await new Promise((e=>{this.videoElement.onloadedmetadata=()=>e()})),this.videoElement.addEventListener("ended",(()=>{console.log("🎬 Video ended event fired"),console.log(`🔄 Processing status: ${this.isProcessing}, Loop count: ${this.loopCount||0}`),this.isProcessing&&setTimeout((()=>this.handleVideoEnd()),100)})),this.totalFrames=Math.ceil(30*this.videoElement.duration),this.canvas.width=this.videoElement.videoWidth,this.canvas.height=this.videoElement.videoHeight,console.log(`Video initialized: ${this.videoElement.videoWidth}x${this.videoElement.videoHeight}, duration: ${this.videoElement.duration}s, estimated frames: ${this.totalFrames}`),!0}catch(e){throw this.errorCallback&&this.errorCallback(e),e}}startProcessing(){this.isProcessing||(this.isProcessing=!0,this.startTime=performance.now(),this.loopCount=1,this.videoElement.currentTime=0,this.videoElement.play(),"requestVideoFrameCallback"in HTMLVideoElement.prototype?this.processWithVideoFrameCallback():this.processTimer=setInterval((()=>{this.processCurrentFrame()}),this.frameInterval),console.log(`Video processing started with frame interval: ${this.frameInterval}ms`))}processWithVideoFrameCallback(){const e=(t,i)=>{if(this.isProcessing)if(this.processCurrentFrame(),!this.isProcessing||this.videoElement.paused||this.videoElement.ended){if(this.isProcessing&&this.videoElement.ended)console.log("🔄 Frame callback detected video end"),this.handleVideoEnd();else if(!this.isProcessing)return void console.log("🔄 Frame callback stopping - processing disabled")}else this.videoElement.requestVideoFrameCallback(e)};this.videoElement.requestVideoFrameCallback(e)}processCurrentFrame(){if(!this.isProcessing)return;if(this.videoElement.paused)return console.log("🔄 Video paused - stopping processing"),void(this.isProcessing=!1);if(this.videoElement.ended)return console.log("🔄 ProcessCurrentFrame detected video end"),void this.handleVideoEnd();if(this.rangeMode&&this.endTime&&this.videoElement.currentTime>=this.endTime)return console.log(`🔄 Range mode: reached end time ${this.endTime.toFixed(2)}s, stopping range`),this.rangeMode=!1,this.endTime=null,this.videoElement.pause(),void(this.isProcessing=!1);const e=performance.now();this.processedFrames++,this.frameStats.processed++;try{this.ctx.drawImage(this.videoElement,0,0,this.canvas.width,this.canvas.height);const t=this.ctx.getImageData(0,0,this.canvas.width,this.canvas.height),i=Math.min(this.videoElement.currentTime/this.videoElement.duration,1),o=(performance.now()-this.startTime)/1e3,s=i>0?o/i:0,n=Math.max(0,s-o);this.progressCallback&&this.progressCallback(i,this.processedFrames,this.totalFrames,n),this.frameCallback&&this.frameCallback(t,this.videoElement.currentTime,this.processedFrames);const r=performance.now()-e;if(this.frameStats.processingTimes.push(r),this.frameStats.processed%30==0){const e=this.frameStats.processingTimes.reduce(((e,t)=>e+t),0)/this.frameStats.processingTimes.length;if(console.log(`Avg frame processing time: ${e.toFixed(2)}ms over last ${this.frameStats.processingTimes.length} frames`),this.frameStats.processingTimes=[],e>1.5*this.frameInterval){const t=Math.min(Math.ceil(1.2*e),100);console.log(`Adjusting frame interval from ${this.frameInterval}ms to ${t}ms due to performance`),this.frameInterval=t,this.processTimer&&(clearInterval(this.processTimer),this.processTimer=setInterval((()=>{this.processCurrentFrame()}),this.frameInterval))}}}catch(e){console.error("Error processing frame:",e),this.errorCallback&&this.errorCallback(e)}}stopProcessing(){this.isProcessing=!1,this.videoElement.paused||this.videoElement.pause(),this.processTimer&&(clearInterval(this.processTimer),this.processTimer=null),console.log(`Video processing stopped. Processed ${this.frameStats.processed} frames, detected ${this.frameStats.qrCodesDetected} QR codes`),this.completed()}handleVideoEnd(){console.log(`🔄 Video ended - checking if should loop. Current loop: ${this.loopCount||0}`);const e=document.getElementById("loopInfo");if(e&&(e.textContent="Status: Video ended, checking if should continue..."),this.shouldContinueLooping())this.loopCount=(this.loopCount||0)+1,console.log(`🔄 Video ended, restarting loop ${this.loopCount} with higher frame rate for better detection`),e&&(e.textContent=`Status: Starting loop ${this.loopCount} with faster frame rate...`),this.originalFrameInterval||(this.originalFrameInterval=this.frameInterval),this.loopCount>1&&(this.frameInterval=Math.max(this.frameInterval/2,1),console.log(`⚡ Increased frame rate: interval now ${this.frameInterval}ms (was ${2*this.frameInterval}ms)`)),console.log("🎬 Restarting video from beginning..."),this.videoElement.currentTime=0,this.videoElement.play().then((()=>{console.log(`✅ Video restarted, resuming processing with ${this.frameInterval}ms interval...`),"requestVideoFrameCallback"in HTMLVideoElement.prototype?this.processWithVideoFrameCallback():(this.processTimer&&clearInterval(this.processTimer),this.processTimer=setInterval((()=>{this.processCurrentFrame()}),this.frameInterval))})).catch((e=>{console.error("Failed to restart video:",e),this.completed()}));else{let e="max loops reached";if(this.isFileComplete&&this.isFileComplete())e="file complete";else if(window.qrFileDecoder?.discoveredFiles.size>0){const t=Array.from(window.qrFileDecoder.discoveredFiles.keys()).filter((e=>window.qrFileDecoder.downloadedFiles.has(e))).length;t===window.qrFileDecoder.discoveredFiles.size&&t>0&&(e=`all ${t} discovered files downloaded`)}console.log(`⏹️ ENTERPRISE: Stopping after ${this.loopCount||1} loops (${e})`);const t=document.getElementById("loopInfo");t&&(t.textContent=`Status: Finished - ${e} after ${this.loopCount||1} loops`),this.completed()}}shouldContinueLooping(){if(this.discoveryMode)return console.log("🔍 Discovery mode - no looping, scan once only"),!1;const e=this.loopCount||0;if(console.log(`🔍 shouldContinueLooping check: currentLoop=${e}, maxLoops=5`),e>=5)return console.log(`⏹️ Max loops reached (${e}/5)`),!1;if(this.isFileComplete&&this.isFileComplete())return console.log("✅ File complete - stopping loops"),!1;if(window.qrFileDecoder&&window.qrFileDecoder.discoveredFiles.size>0){const t=Array.from(window.qrFileDecoder.discoveredFiles.keys()),i=Array.from(window.qrFileDecoder.downloadedFiles);if(t.every((e=>i.includes(e)))&&e>=2)return console.log(`🎯 ENTERPRISE SMART STOP: All ${t.length} discovered files downloaded`),console.log(`📁 Downloaded files: ${i.join(", ")}`),console.log(`⏹️ Stopping video processing - mission accomplished after ${e} loops`),this.videoElement&&(this.videoElement.pause(),console.log("⏸️ ENTERPRISE: Video playback stopped - all files downloaded")),!1}if(window.qrFileDecoder){if(!(window.qrFileDecoder.discoveredFiles.size>0))return console.log("🔍 No files discovered yet - continuing to scan"),e<5;{let t=!0,i=0,o=window.qrFileDecoder.discoveredFiles.size;for(const[e,o]of window.qrFileDecoder.discoveredFiles.entries())window.qrFileDecoder.downloadedFiles.has(e)?i++:t=!1;if(console.log(`📊 ENTERPRISE: Download status: ${i}/${o} discovered files downloaded`),t&&i>0)return console.log(`✅ ENTERPRISE EFFICIENCY: All ${i} discovered files downloaded - stopping loops early`),!1;if(!window.qrFileDecoder.discoveryMode&&window.qrFileDecoder.fountainDecoder){const t=window.qrFileDecoder.fountainDecoder.getRecoveryProgress();if(console.log(`📊 Recovery progress: ${t.recovered}/${t.total} chunks (${t.percentage}%)`),t.recovered<t.total&&e<5)return console.log(`🔄 Continuing loop ${e+1} - missing ${t.total-t.recovered} chunks`),!0}}}const t=e<5;return console.log(`🔄 Should continue: ${t}`),t}completed(){if(this.isProcessing=!1,console.log(`Video processing completed after ${this.loopCount||1} loops`),this.discoveryMode&&(console.log(`🔍 Discovery loop 1 completed - found ${window.qrFileDecoder?.discoveredFiles?.size||0} files`),console.log("🔄 Turning OFF discovery mode, switching to normal processing for remaining loops"),this.discoveryMode=!1,window.qrFileDecoder))return window.qrFileDecoder.discoveryMode=!1,window.qrFileDecoder.handleDiscoveryComplete(),void console.log("🔄 Discovery complete - continuing with normal looping for better recovery");this.processTimer&&(clearInterval(this.processTimer),this.processTimer=null)}}class EnhancedQRProcessor{constructor(e){this.onQrDetected=e.onQrDetected,this.onError=e.onError,this.detectionConfidence=e.detectionConfidence||.5,this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d",{willReadFrequently:!0}),this.html5QrCode=null,this.isReady=!1,this.detectionStats={attempts:0,successes:0,failures:0,lastDetectedFrameIndex:-1,duplicates:0},this.recentlySeenQRs=new Map,this.maxCacheSize=50,this.qrElement=document.createElement("div"),this.qrElement.id="qr-reader-hidden",this.qrElement.style.display="none",document.body.appendChild(this.qrElement)}async initialize(){try{return this.html5QrCode=new Html5Qrcode("qr-reader-hidden",{formatsToSupport:[Html5QrcodeSupportedFormats.QR_CODE,Html5QrcodeSupportedFormats.DATA_MATRIX,Html5QrcodeSupportedFormats.CODE_39,Html5QrcodeSupportedFormats.CODE_93,Html5QrcodeSupportedFormats.CODE_128,Html5QrcodeSupportedFormats.EAN_8,Html5QrcodeSupportedFormats.EAN_13,Html5QrcodeSupportedFormats.ITF,Html5QrcodeSupportedFormats.UPC_A,Html5QrcodeSupportedFormats.UPC_E]}),this.isReady=!0,console.log("QR processor initialized successfully"),!0}catch(e){throw this.onError&&this.onError(e),console.error("Failed to initialize HTML5QRCode",e),e}}processFrame(e,t){if(!this.isReady)throw new Error("QR processor not initialized");return this.detectionStats.attempts++,new Promise(((i,o)=>{try{this.canvas.width===e.width&&this.canvas.height===e.height||(this.canvas.width=e.width,this.canvas.height=e.height),this.ctx.putImageData(e,0,0);const o=this.canvas.toDataURL("image/jpeg");this.html5QrCode.scanFile(this.dataURLtoFile(o,"frame.jpg"),!1,void 0).then((o=>{this.detectionStats.successes++;if(this.checkDuplicate(o,t))this.detectionStats.duplicates++,i({success:!1,isDuplicate:!0,frameIndex:t});else{this.addToRecentlySeen(o,t),this.detectionStats.lastDetectedFrameIndex=t,this.detectionStats.successes%10==0&&console.log(`QR detection stats: ${this.detectionStats.successes}/${this.detectionStats.attempts} successful (${this.detectionStats.duplicates} duplicates)`);const s=this.html5QrCode._lastScanResult||null;i({success:!0,qrData:o,frameIndex:t,bounds:this.estimateBounds({result:s,imageData:e})})}})).catch((e=>{this.detectionStats.failures++,i({success:!1,frameIndex:t})}))}catch(e){this.detectionStats.failures++,this.onError&&this.onError(e),i({success:!1,frameIndex:t})}}))}checkDuplicate(e,t){if(this.recentlySeenQRs.has(e)){return t-this.recentlySeenQRs.get(e)<5}return!1}addToRecentlySeen(e,t){if(this.recentlySeenQRs.set(e,t),this.recentlySeenQRs.size>this.maxCacheSize){const e=Array.from(this.recentlySeenQRs.entries());e.sort(((e,t)=>e[1]-t[1]));const t=Math.ceil(.2*this.maxCacheSize);for(let i=0;i<t;i++)e[i]&&this.recentlySeenQRs.delete(e[i][0])}}estimateBounds(e){if(e&&e.result&&e.result.location){const t=e.result.location,i=[t.topLeft.x,t.topRight.x,t.bottomLeft.x,t.bottomRight.x],o=[t.topLeft.y,t.topRight.y,t.bottomLeft.y,t.bottomRight.y],s=Math.min(...i),n=Math.max(...i),r=Math.min(...o),a=Math.max(...o),l=n-s,c=a-r,d=Math.max(l,c);return{x:(s+n)/2-d/2,y:(r+a)/2-d/2,width:d,height:d}}const t=e.imageData||{width:300,height:300},i=t.width/2,o=(t.height,Math.min(t.width,t.height)/2.5);return{x:i-o/2,y:0,width:o,height:o}}dataURLtoFile(e,t){const i=e.split(","),o=i[0].match(/:(.*?);/)[1],s=atob(i[1]);let n=s.length;const r=new Uint8Array(n);for(;n--;)r[n]=s.charCodeAt(n);return new File([r],t,{type:o})}dispose(){if(this.html5QrCode)try{this.html5QrCode.clear()}catch(e){console.error("Error clearing HTML5QRCode",e)}this.qrElement&&this.qrElement.parentNode&&this.qrElement.parentNode.removeChild(this.qrElement),console.log(`QR processor disposed. Final stats: ${JSON.stringify(this.detectionStats)}`)}}class QRFileDecoder{constructor(){this.logger=new Logger("logWindow"),this.ui=new UI(this.logger),this.videoProcessor=null,this.qrProcessor=null,this.packetProcessor=null,this.fountainDecoder=null,this.isProcessing=!1,this.videoFile=null,this.metadataReceived=!1,this.fileMetadata=null,this.recoveredChunks=new Map,this.missingChunks=new Set,this.wakeLock=null,this.settings=this.loadSettings(),this.discoveryMode=!1,this.discoveredFiles=new Map,this.currentActiveFile=null,this.downloadedFiles=new Set,this.qrCodesDetected=0,this.packetsProcessed=0,this.recoveredFileData=null,this.checkCompatibility(),this.initEventListeners(),this.logger.info("QR File Decoder initialized")}checkCompatibility(){EnhancedVideoProcessor.isWebCodecsSupported()||(this.ui.showErrorMessage("WebCodecs API is not supported in your browser. Please use Chrome 94+, Edge 94+, or another compatible browser."),document.getElementById("startScanBtn").disabled=!0),"undefined"==typeof Html5Qrcode&&(this.ui.showErrorMessage("HTML5QRCode library is not available. Please check your internet connection and reload the page."),document.getElementById("startScanBtn").disabled=!0)}resetContents(){this.isProcessing&&this.stopProcessing(),this.qrProcessor&&(this.qrProcessor.dispose(),this.qrProcessor=null),this.videoProcessor&&(this.videoProcessor.stopProcessing(),this.videoProcessor=null),this.metadataReceived=!1,this.fileMetadata=null,this.recoveredChunks=new Map,this.missingChunks=new Set,this.qrCodesDetected=0,this.packetsProcessed=0,this.recoveredFileData=null,this.downloadedFiles=new Set,this.discoveredFiles=new Map,this.ui.resetChunkGrid(),this.ui.updateFileInfo("No file detected yet"),document.getElementById("missingChunks").textContent="Waiting for metadata...",document.getElementById("scanProgressBar").style.width="0%",document.getElementById("scanProgressText").textContent="Frames: 0/0 | Time Remaining: --:-- | Loop: 1",document.getElementById("downloadContainer").style.display="none",document.getElementById("continueBtn").disabled=!0,this.ui.clearQRHighlight(),this.ui.hideErrorMessage(),document.getElementById("startScanBtn").disabled=!this.videoFile,document.getElementById("discoverBtn").disabled=!this.videoFile,this.logger.info("Contents completely reset, ready for new scan")}initEventListeners(){document.getElementById("videoInput").addEventListener("change",this.handleVideoInput.bind(this)),document.getElementById("startScanBtn").addEventListener("click",this.startScanAndDiscover.bind(this)),document.getElementById("continueBtn").addEventListener("click",this.continueProcessing.bind(this)),document.getElementById("stopScanBtn").addEventListener("click",this.stopProcessing.bind(this)),document.getElementById("downloadBtn").addEventListener("click",this.downloadFile.bind(this)),document.getElementById("settingsBtn").addEventListener("click",this.ui.showSettingsModal.bind(this.ui)),document.getElementById("saveSettingsBtn").addEventListener("click",this.saveSettings.bind(this)),document.getElementById("clearLogBtn").addEventListener("click",this.logger.clear.bind(this.logger)),document.getElementById("copyLogBtn").addEventListener("click",this.copyDebugLog.bind(this)),document.querySelectorAll(".log-filter").forEach((e=>{e.addEventListener("click",(e=>{this.logger.setFilter(e.target.dataset.level),this.ui.updateLogFilterButtons(e.target)}))})),document.querySelector(".modal .close").addEventListener("click",this.ui.hideSettingsModal.bind(this.ui)),document.getElementById("resetBtn").addEventListener("click",this.resetContents.bind(this)),document.getElementById("frameInterval").addEventListener("input",(e=>{this.updateSingleSetting("frameInterval",parseInt(e.target.value))})),document.getElementById("qrDetectionConfidence").addEventListener("input",(e=>{this.updateSingleSetting("qrDetectionConfidence",parseFloat(e.target.value))})),document.getElementById("workerCount").addEventListener("input",(e=>{this.updateSingleSetting("workerCount",parseInt(e.target.value))})),document.getElementById("packetWorkerCount").addEventListener("input",(e=>{this.updateSingleSetting("packetWorkerCount",parseInt(e.target.value))}))}async handleVideoInput(e){if(e.target.files&&0!==e.target.files.length){this.videoFile=e.target.files[0],this.logger.info(`Video file selected: ${this.videoFile.name} (${this.formatFileSize(this.videoFile.size)})`);try{const e=URL.createObjectURL(this.videoFile),t=document.getElementById("videoPreview");t.src=e,t.onloadedmetadata=()=>{document.getElementById("startScanBtn").disabled=!1,this.metadataReceived&&this.recoveredChunks.size<this.fileMetadata.chunksCount&&(document.getElementById("continueBtn").disabled=!1),this.logger.info(`Video duration: ${t.duration.toFixed(2)} seconds`)}}catch(e){this.logger.error(`Error loading video: ${e.message}`),this.ui.showErrorMessage(`Error loading video: ${e.message}`)}}}async requestWakeLock(){try{"wakeLock"in navigator&&(this.wakeLock=await navigator.wakeLock.request("screen"),this.logger.info("Screen wake lock activated - screen will stay awake"),this.wakeLock.addEventListener("release",(()=>{this.logger.info("Screen wake lock released")})))}catch(e){this.logger.warn(`Wake lock failed: ${e.message}`)}}releaseWakeLock(){this.wakeLock&&(this.wakeLock.release(),this.wakeLock=null,this.logger.info("Screen wake lock released manually"))}async startProcessing(){if(this.videoFile)if(this.isProcessing)this.logger.warn("Processing already in progress");else{this.isProcessing=!0,await this.requestWakeLock(),this.metadataReceived=!1,this.recoveredChunks.clear(),this.missingChunks.clear(),this.qrCodesDetected=0,this.packetsProcessed=0,this.recoveredFileData=null,document.getElementById("startScanBtn").disabled=!0,document.getElementById("continueBtn").disabled=!0,document.getElementById("stopScanBtn").disabled=!1,document.getElementById("downloadContainer").style.display="none",this.ui.resetChunkGrid(),this.ui.updateFileInfo("Processing video..."),this.ui.clearQRHighlight(),this.ui.hideErrorMessage(),this.logger.info("Starting video processing");try{await this.initializeComponents(),await this.videoProcessor.initialize(this.videoFile),this.videoProcessor.startProcessing(),this.logger.info("Processing started")}catch(e){this.logger.error(`Failed to start processing: ${e.message}`),this.ui.showErrorMessage(`Failed to start processing: ${e.message}`),this.stopProcessing()}}else this.logger.warn("No video file selected")}async initializeComponents(){this.qrProcessor=new EnhancedQRProcessor({onQrDetected:this.handleQRCodeResult.bind(this),onError:e=>this.logger.error(`QR processing error: ${e.message}`),detectionConfidence:this.settings.qrDetectionConfidence}),await this.qrProcessor.initialize(),this.packetProcessor=new PacketProcessor,this.fountainDecoder=new EnhancedFountainDecoder,this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this)),this.videoProcessor=new EnhancedVideoProcessor({frameCallback:this.handleVideoFrame.bind(this),progressCallback:this.ui.updateProgress.bind(this.ui),errorCallback:e=>this.logger.error(`Video processing error: ${e.message}`),frameInterval:this.settings.frameInterval}),this.videoProcessor.isFileComplete=()=>this.metadataReceived&&this.fileMetadata&&this.recoveredChunks.size>=this.fileMetadata.chunksCount}async continueProcessing(){if(!this.isProcessing)if(this.logger.info("Continuing video processing with additional loops..."),this.qrProcessor||(this.logger.info("Reinitializing QR processor for continue..."),this.qrProcessor=new EnhancedQRProcessor({onQrDetected:this.handleQRCodeResult.bind(this),onError:e=>this.logger.error(`QR processing error: ${e.message}`),detectionConfidence:this.settings.qrDetectionConfidence}),await this.qrProcessor.initialize()),this.videoProcessor&&this.videoFile){this.isProcessing=!0,this.videoProcessor.loopCount=(this.videoProcessor.loopCount||1)+1,this.videoProcessor.isProcessing=!0,this.videoProcessor.frameInterval=Math.max(this.videoProcessor.frameInterval/2,1),console.log(`🔄 Manual continue: Starting loop ${this.videoProcessor.loopCount} with ${this.videoProcessor.frameInterval}ms interval`);const e=document.getElementById("loopInfo");e&&(e.textContent=`Status: Manual continue - loop ${this.videoProcessor.loopCount} with faster frame rate...`);const t=this.videoProcessor.videoElement.currentTime;console.log(`🎯 Continue from current position: ${t.toFixed(2)}s (not restarting from beginning)`),this.videoProcessor.videoElement.play().then((()=>{console.log("✅ Manual continue: Video restarted, resuming processing..."),"requestVideoFrameCallback"in HTMLVideoElement.prototype?this.videoProcessor.processWithVideoFrameCallback():(this.videoProcessor.processTimer&&clearInterval(this.videoProcessor.processTimer),this.videoProcessor.processTimer=setInterval((()=>{this.videoProcessor.processCurrentFrame()}),this.videoProcessor.frameInterval))})).catch((e=>{console.error("Failed to continue video processing:",e),this.isProcessing=!1})),document.getElementById("startScanBtn").disabled=!0,document.getElementById("continueBtn").disabled=!0,document.getElementById("stopScanBtn").disabled=!1}else this.logger.error("Cannot continue - video processor or file not available")}async startScanAndDiscover(){if(!this.isProcessing){this.logger.info("Starting scan with automatic file discovery..."),this.discoveryMode=!0,this.discoveredFiles.clear(),this.isProcessing=!0,this.ui.resetChunkGrid(),this.ui.updateFileInfo("Scanning video and discovering files..."),document.getElementById("discoveredFilesContainer").style.display="none",document.getElementById("startScanBtn").disabled=!0,document.getElementById("continueBtn").disabled=!0,document.getElementById("stopScanBtn").disabled=!1;try{await this.initializeComponents(),await this.videoProcessor.initialize(this.videoFile),this.videoProcessor.discoveryMode=!0,this.videoProcessor.startProcessing(),this.logger.info("First loop started - discovering files and capturing chunks simultaneously")}catch(e){this.logger.error(`Failed to start processing: ${e.message}`),this.ui.showErrorMessage(`Failed to start processing: ${e.message}`),this.stopProcessing()}}}startFileProcessing(e,t){this.isProcessing||(this.logger.info(`Starting focused processing for file: ${e} at ${t.toFixed(2)}s`),this.currentActiveFile=e,this.metadataReceived=!1,this.fileMetadata=null,this.recoveredChunks=new Map,this.missingChunks=new Set,this.fountainDecoder&&(this.fountainDecoder=new EnhancedFountainDecoder,this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this))),this.videoProcessor&&(this.videoProcessor.videoElement.currentTime=t,this.videoProcessor.discoveryMode=!1,this.isProcessing=!0,this.videoProcessor.isProcessing=!0,this.videoProcessor.loopCount=1,document.getElementById("startScanBtn").disabled=!0,document.getElementById("discoverBtn").disabled=!0,document.getElementById("continueBtn").disabled=!0,document.getElementById("stopScanBtn").disabled=!1,this.ui.updateFileInfo(`Processing file: ${e}`),this.ui.resetChunkGrid(),this.videoProcessor.videoElement.play()))}stopProcessing(){if(this.isProcessing){if(console.log("🛑 Stop button pressed - halting all processing"),this.isProcessing=!1,this.discoveryMode=!1,this.releaseWakeLock(),this.videoProcessor&&(this.videoProcessor.stopProcessing(),this.videoProcessor.discoveryMode=!1,this.videoProcessor.rangeMode=!1),this.ui.clearQRHighlight(),document.getElementById("startScanBtn").disabled=!1,document.getElementById("stopScanBtn").disabled=!0,this.metadataReceived&&this.recoveredChunks.size<this.fileMetadata.chunksCount&&this.videoFile&&this.videoProcessor&&(document.getElementById("continueBtn").disabled=!1,this.logger.info("Continue button enabled - you can resume processing")),this.videoFile){const e=document.getElementById("discoverBtn");e&&(e.disabled=!1)}if(this.logger.info("All processing stopped - use Continue to resume or Start Scan & Discover to restart"),this.logger.info(`Processing summary: Detected ${this.qrCodesDetected} QR codes, processed ${this.packetsProcessed} packets`),this.metadataReceived){const e=this.fountainDecoder.getRecoveryProgress();this.logger.info(`File recovery progress: ${e.recovered}/${e.total} chunks (${e.percentage}%)`),e.packetStats&&this.logger.info(`Packet statistics: ${JSON.stringify(e.packetStats)}`)}}}async handleVideoFrame(e,t,i){if(this.isProcessing)try{const t=await this.qrProcessor.processFrame(e,i);t.success?(this.qrCodesDetected++,t.bounds?(this.ui.drawQRHighlight(t.bounds.x,t.bounds.y,t.bounds.width,t.bounds.height),this.logger.info(`QR code detected in frame ${i} at position [${t.bounds.x.toFixed(0)}, ${t.bounds.y.toFixed(0)}]`)):this.logger.info(`QR code detected in frame ${i}`),this.handleQRCodeResult(t)):t.isDuplicate||this.ui.clearQRHighlight()}catch(e){this.logger.error(`Error processing frame ${i}: ${e.message}`)}}handleQRCodeResult(e){if(!e.success)return;const{qrData:t,frameIndex:i}=e;this.logger.debug(`QR code detected in frame ${i}: ${t.substring(0,30)}...`);const o=this.packetProcessor.processQRData(t,i);o.success?this.handlePacketResult(o):this.logger.warn(`Failed to process QR data: ${o.error}`)}handlePacketResult(e){if(!e.success)return void this.logger.warn(`Failed to process packet: ${e.error}`);this.packetsProcessed++;const{packetType:t,packetData:i}=e;if("metadata"===t){const e=this.videoProcessor?this.videoProcessor.videoElement.currentTime:0;this.handleMetadataPacket(i,e)}else"data"===t&&this.handleDataPacket(i)}handleMetadataPacket(e,t=0){const i=e.fileName;if(this.discoveryMode){if(console.log(`🔍 DISCOVERY: Processing metadata for ${i} at ${t.toFixed(2)}s`),this.discoveredFiles.has(i)){if(this.discoveredFiles.get(i).lastSeenAt=t,this.logger.debug(`📁 DISCOVERY: Existing file ${i} seen again at ${t.toFixed(2)}s`),this.currentActiveFile&&this.currentActiveFile===i)return void this.logger.debug(`📁 DISCOVERY: Duplicate metadata for current file ${i}`);this.logger.info(`🔄 DISCOVERY: Switching from ${this.currentActiveFile||"none"} to ${i}`),this.switchToFile(e,i)}else this.discoveredFiles.set(i,{metadata:e,firstSeenAt:t,lastSeenAt:t}),this.logger.info(`📁 DISCOVERY: NEW file found: ${i} at ${t.toFixed(2)}s`),this.switchToFile(e,i);this.updateDiscoveredFilesUI()}else{if(this.metadataReceived){if(e.fileName===this.fileMetadata.fileName&&e.fileSize===this.fileMetadata.fileSize&&e.chunksCount===this.fileMetadata.chunksCount)return void this.logger.debug("Received duplicate metadata packet");this.logger.warn("Received metadata for a different file, reinitializing")}if(this.metadataReceived=!0,this.fileMetadata=e,this.ui.initializeChunkGrid(e.chunksCount),this.ui.updateFileInfo(`\n          <div><strong>File Name:</strong> ${e.fileName}</div>\n          <div><strong>File Type:</strong> ${e.fileType}</div>\n          <div><strong>File Size:</strong> ${this.formatFileSize(e.fileSize)}</div>\n          <div><strong>Chunks:</strong> ${e.chunksCount}</div>\n          <div><strong>Protocol Version:</strong> ${e.protocolVersion}</div>\n        `),e.fileChecksum||e.metaChecksum){const t=document.getElementById("fileChecksum"),i=document.getElementById("metaChecksum"),o=document.getElementById("checksumInfo");t&&(t.textContent=e.fileChecksum||"-"),i&&(i.textContent=e.metaChecksum||"-"),o&&(o.style.display="block")}this.fountainDecoder.initialize(e);for(let t=0;t<e.chunksCount;t++)this.missingChunks.add(t);this.updateMissingChunksUI(),this.logger.info(`Metadata received: ${e.fileName} (${this.formatFileSize(e.fileSize)}), ${e.chunksCount} chunks`)}}handleDataPacket(e){if(!this.metadataReceived)return void this.logger.warn("Received data packet before metadata, ignoring");this.discoveryMode&&this.logger.debug(`📦 DISCOVERY: Processing data packet for ${this.currentActiveFile||"unknown file"}`),e.sourceChunks&&e.sourceChunks.forEach((e=>{this.ui.blinkChunk(e)}));if(this.fountainDecoder.addPacket(e)){const e=this.fountainDecoder.getNewlyRecoveredChunks();e.length>0&&(e.forEach((e=>{this.recoveredChunks.set(e,!0),this.missingChunks.delete(e),this.ui.markChunkAsRecovered(e)})),this.updateMissingChunksUI(),this.logger.info(`Recovered ${e.length} new chunks, total: ${this.recoveredChunks.size}/${this.fileMetadata.chunksCount}`))}}updateMissingChunksUI(){const e=this.missingChunks.size,t=this.fileMetadata.chunksCount,i=t-e;document.getElementById("missingChunks").innerHTML=`\n          <div>Recovered chunks: ${i}/${t} (${Math.round(i/t*100)}%)</div>\n          <div>Missing chunks: ${e}</div>\n        `,0===e&&i===t&&this.logger.info("All chunks recovered, finalizing file...")}handleFileComplete(e){this.logger.info("File recovery complete!"),this.releaseWakeLock(),this.recoveredFileData=e,document.getElementById("downloadContainer").style.display="block";const t=document.getElementById("fileInfo").innerHTML;if(document.getElementById("fileInfo").innerHTML=t+'\n          <div style="margin-top: 10px; color: var(--success-color);">\n            <strong>File Successfully Recovered!</strong>\n          </div>\n        ',this.discoveryMode){console.log(`✅ File ${this.fileMetadata.fileName} COMPLETED during discovery - storing and continuing scan`);const t=this.fileMetadata.fileName,i=this.fountainDecoder.recoveredChunkCount,o=this.fileMetadata.chunksCount;if(console.log(`🎯 ENTERPRISE ACCURATE DATA: ${t} has ${i}/${o} chunks (captured at completion moment)`),this.discoveredFiles.has(t)){const i=this.discoveredFiles.get(t);i.completed=!0,i.recoveredData=e,i.recoveredAt=performance.now(),this.logger.info(`💾 DISCOVERY: Stored completed file: ${t} (${e.byteLength} bytes)`),this.downloadedFiles.has(t)?console.log(`⏭️ ENTERPRISE: File ${t} already downloaded during discovery - skipping duplicate`):(console.log(`📥 Auto-downloading completed file during discovery: ${t}`),this.downloadCompletedFile(t),console.log(`🔍 DISCOVERY: File ${t} downloaded but continuing discovery to find all files in video`))}const s=o,n=i;console.log(`🔍 ENTERPRISE UI FIX: Using captured accurate data: ${n}/${s}`),document.getElementById("missingChunks").innerHTML=`\n            <div>Recovered chunks: ${n}/${s} (100%)</div>\n            <div>Missing chunks: 0</div>\n            <div style="color: #16a34a; font-weight: bold;">✅ FILE COMPLETE - DOWNLOADED</div>\n          `,this.ui.updateFileInfo(`✅ File ${t} FULLY COMPLETE (${n}/${s} chunks)! Downloaded and continuing discovery...`);const r={fileName:t,totalChunks:s,recoveredChunks:n};return this.logger.info(`🔄 DISCOVERY: Resetting state after ${t} completion - ready for next file`),this.fountainDecoder=new EnhancedFountainDecoder,this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this)),this.metadataReceived=!1,this.fileMetadata=null,this.recoveredChunks=new Map,this.missingChunks=new Set,this.currentActiveFile=null,setTimeout((()=>{this.ui.resetChunkGrid(),this.ui.updateFileInfo(`🔍 Discovery continuing after ${r.fileName} (${r.recoveredChunks}/${r.totalChunks}) - scanning for more files...`)}),2e3),void this.updateDiscoveredFilesUI()}const i=this.fileMetadata.fileName;if(console.log(`✅ File ${i} completed in normal mode - resetting decoder to continue processing for next files`),this.downloadedFiles.has(i))return console.log(`⏭️ ENTERPRISE: File ${i} already downloaded - skipping duplicate download`),this.logger.info(`File ${i} recovery complete (already downloaded)`),this.fountainDecoder=new EnhancedFountainDecoder,this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this)),this.metadataReceived=!1,this.fileMetadata=null,this.recoveredChunks=new Map,this.missingChunks=new Set,void(this.currentActiveFile=null);console.log(`💾 File ${i} complete - triggering automatic download`),this.downloadFile(),this.fountainDecoder=new EnhancedFountainDecoder,this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this)),this.metadataReceived=!1,this.fileMetadata=null,this.recoveredChunks=new Map,this.missingChunks=new Set,this.currentActiveFile=null}downloadFile(){if(this.recoveredFileData&&this.fileMetadata)try{const e=new Blob([this.recoveredFileData],{type:this.fileMetadata.fileType||"application/octet-stream"}),t=URL.createObjectURL(e),i=document.createElement("a");i.href=t,i.download=this.fileMetadata.fileName,document.body.appendChild(i),i.click(),setTimeout((()=>{document.body.removeChild(i),URL.revokeObjectURL(t)}),100),this.downloadedFiles.add(this.fileMetadata.fileName),this.logger.info(`💾 ENTERPRISE: Auto-downloaded "${this.fileMetadata.fileName}" (${this.formatFileSize(this.recoveredFileData.byteLength)})`),console.log("✅ ENTERPRISE SUCCESS: File download completed automatically for user convenience"),console.log(`📋 ENTERPRISE: Added "${this.fileMetadata.fileName}" to downloaded files list (${this.downloadedFiles.size} total)`),this.discoveryMode?console.log("🔍 DISCOVERY: File downloaded but discovery mode active - continuing to scan entire video"):this.checkAndStopIfAllFilesDownloaded()}catch(e){console.error(`❌ ENTERPRISE ERROR: Auto-download failed for ${this.fileMetadata.fileName}:`,e.message),this.logger.error(`Error downloading file: ${e.message}`),this.ui.showErrorMessage(`Error downloading file: ${e.message}`)}else this.logger.warn("No recovered file data available")}saveSettings(){const e=parseInt(document.getElementById("workerCount").value),t=parseInt(document.getElementById("packetWorkerCount").value),i=parseInt(document.getElementById("frameInterval").value),o=parseFloat(document.getElementById("qrDetectionConfidence").value);this.settings={workerCount:isNaN(e)?4:Math.min(Math.max(e,1),16),packetWorkerCount:isNaN(t)?2:Math.min(Math.max(t,1),8),frameInterval:isNaN(i)?20:Math.min(Math.max(i,0),1e3),qrDetectionConfidence:isNaN(o)?.5:Math.min(Math.max(o,0),1)},this.logger.info(`Settings updated: ${JSON.stringify(this.settings)}`),this.saveSettingsToStorage(),this.ui.hideSettingsModal()}updateSingleSetting(e,t){let i;switch(e){case"workerCount":i=isNaN(t)?4:Math.min(Math.max(t,1),16);break;case"packetWorkerCount":i=isNaN(t)?2:Math.min(Math.max(t,1),8);break;case"frameInterval":i=isNaN(t)?20:Math.min(Math.max(t,0),1e3);break;case"qrDetectionConfidence":i=isNaN(t)?.5:Math.min(Math.max(t,0),1);break;default:return void console.warn(`Unknown setting: ${e}`)}this.settings[e]=i,"frameInterval"===e&&this.videoProcessor&&(this.videoProcessor.frameInterval=i,this.videoProcessor.isProcessing&&this.videoProcessor.processTimer&&(clearInterval(this.videoProcessor.processTimer),this.videoProcessor.processTimer=setInterval((()=>{this.videoProcessor.processCurrentFrame()}),i)),console.log(`⚡ Frame interval updated to ${i}ms`)),console.log(`📝 Setting updated: ${e} = ${i}`),this.saveSettingsToStorage()}loadSettings(){try{const e=localStorage.getItem("qrDecoderSettings");if(e){const t=JSON.parse(e);console.log("📂 Loaded settings from localStorage:",t);const i={workerCount:4,packetWorkerCount:2,frameInterval:20,qrDetectionConfidence:.5};return{workerCount:"number"==typeof t.workerCount?Math.min(Math.max(t.workerCount,1),16):i.workerCount,packetWorkerCount:"number"==typeof t.packetWorkerCount?Math.min(Math.max(t.packetWorkerCount,1),8):i.packetWorkerCount,frameInterval:"number"==typeof t.frameInterval?Math.min(Math.max(t.frameInterval,0),1e3):i.frameInterval,qrDetectionConfidence:"number"==typeof t.qrDetectionConfidence?Math.min(Math.max(t.qrDetectionConfidence,0),1):i.qrDetectionConfidence}}}catch(e){console.warn("Failed to load settings from localStorage:",e)}return console.log("📂 Using default settings"),{workerCount:4,packetWorkerCount:2,frameInterval:20,qrDetectionConfidence:.5}}saveSettingsToStorage(){try{localStorage.setItem("qrDecoderSettings",JSON.stringify(this.settings)),console.log("💾 Settings saved to localStorage")}catch(e){console.warn("Failed to save settings to localStorage:",e)}}switchToFile(e,t){this.logger.info(`🔄 DISCOVERY: Switching to process file: ${t}`),this.currentActiveFile=t,this.fountainDecoder=new EnhancedFountainDecoder,this.fountainDecoder.initialize(e),this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this)),this.metadataReceived=!0,this.fileMetadata=e,this.recoveredChunks=new Map,this.missingChunks=new Set,this.ui.initializeChunkGrid(e.chunksCount),this.ui.updateFileInfo(`\n          <div><strong>DISCOVERY - Current File:</strong> ${e.fileName}</div>\n          <div><strong>File Type:</strong> ${e.fileType}</div>\n          <div><strong>File Size:</strong> ${this.formatFileSize(e.fileSize)}</div>\n          <div><strong>Chunks:</strong> ${e.chunksCount}</div>\n          <div><strong>Time:</strong> ${this.videoProcessor?this.videoProcessor.videoElement.currentTime.toFixed(1):"?"}s</div>\n        `);for(let t=0;t<e.chunksCount;t++)this.missingChunks.add(t);this.updateMissingChunksUI(),this.logger.info(`🎯 DISCOVERY: Now actively processing ${t} - ready for data packets`)}resetForNewFile(e,t){this.logger.info(`🔄 Resetting UI and decoder for new file: ${t}`),this.currentActiveFile=t,this.fountainDecoder=new EnhancedFountainDecoder,this.fountainDecoder.initialize(e),this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this)),this.metadataReceived=!0,this.fileMetadata=e,this.recoveredChunks=new Map,this.missingChunks=new Set,this.ui.initializeChunkGrid(e.chunksCount),this.ui.updateFileInfo(`\n          <div><strong>Current File:</strong> ${e.fileName}</div>\n          <div><strong>File Type:</strong> ${e.fileType}</div>\n          <div><strong>File Size:</strong> ${this.formatFileSize(e.fileSize)}</div>\n          <div><strong>Chunks:</strong> ${e.chunksCount}</div>\n          <div><strong>Discovery Mode:</strong> Active</div>\n        `);for(let t=0;t<e.chunksCount;t++)this.missingChunks.add(t);this.updateMissingChunksUI(),this.logger.info(`🎯 Ready to process ${t} during discovery scan`)}copyDebugLog(){try{const e=document.getElementById("logWindow").querySelectorAll(".log-entry");let t="=== QR File Decoder Debug Log ===\n";t+=`Generated: ${(new Date).toISOString()}\n`,t+=`Video: ${this.videoFile?this.videoFile.name:"None"}\n`,t+=`Discovered Files: ${this.discoveredFiles.size}\n`,t+="=====================================\n\n",e.forEach((e=>{t+=e.textContent+"\n"})),navigator.clipboard.writeText(t).then((()=>{this.logger.info("Debug log copied to clipboard");const e=document.getElementById("copyLogBtn"),t=e.textContent;e.textContent="Copied!",e.style.backgroundColor="#10b981",setTimeout((()=>{e.textContent=t,e.style.backgroundColor=""}),2e3)})).catch((e=>{this.logger.error("Failed to copy log to clipboard: "+e.message)}))}catch(e){this.logger.error("Error copying debug log: "+e.message)}}handleDiscoveryComplete(){if(this.logger.info(`🎯 Discovery complete! Found ${this.discoveredFiles.size} files in video`),this.updateDiscoveredFilesUI(),1===this.discoveredFiles.size){const[e,t]=Array.from(this.discoveredFiles.entries())[0];this.ui.updateFileInfo(`Found 1 file: ${e}. Continuing to process with loops...`)}else this.discoveredFiles.size>1?this.checkAndAutoRepeatIncompleteFiles():this.ui.updateFileInfo("No file metadata found yet. Continuing scan...")}updateDiscoveredFilesUI(){const e=document.getElementById("discoveredFilesContainer"),t=document.getElementById("discoveredFilesList");0!==this.discoveredFiles.size?(e.style.display="block",t.innerHTML="",Array.from(this.discoveredFiles.entries()).forEach((([e,i],o)=>{const s=document.createElement("div");s.style.cssText="margin-bottom: 10px; padding: 10px; border: 1px solid #e5e7eb; border-radius: 4px; background: #f9fafb;";const n=this.formatFileSize(i.metadata.fileSize),r=`${i.firstSeenAt.toFixed(1)}s - ${i.lastSeenAt.toFixed(1)}s`,a=i.completed||!1,l=a?'<span style="background: #dcfce7; color: #16a34a; padding: 2px 6px; border-radius: 8px; font-size: 10px; font-weight: bold;">COMPLETED</span>':'<span style="background: #fef3c7; color: #d97706; padding: 2px 6px; border-radius: 8px; font-size: 10px; font-weight: bold;">NEEDS PROCESSING</span>';s.innerHTML=`\n            <div style="display: flex; justify-content: space-between; align-items: center;">\n              <div>\n                <div style="display: flex; align-items: center; gap: 8px;">\n                  <span style="font-weight: bold; color: #1f2937;">${e}</span>\n                  ${l}\n                </div>\n                <div style="font-size: 12px; color: #6b7280;">\n                  Size: ${n} | Chunks: ${i.metadata.chunksCount} | Time: ${r}\n                </div>\n              </div>\n              <div style="display: flex; gap: 5px;">\n                <button onclick="window.qrFileDecoder.startFileProcessing('${e}', ${i.firstSeenAt})" \n                        style="padding: 6px 12px; background: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer;">\n                  Decode Full\n                </button>\n                <button onclick="window.qrFileDecoder.repeatFileRange('${e}', ${i.firstSeenAt}, ${i.lastSeenAt})" \n                        style="padding: 6px 12px; background: #f59e0b; color: white; border: none; border-radius: 4px; cursor: pointer;">\n                  Repeat Range\n                </button>\n                ${a?`<button onclick="window.qrFileDecoder.downloadCompletedFile('${e}')" \n                        style="padding: 6px 12px; background: #16a34a; color: white; border: none; border-radius: 4px; cursor: pointer;">\n                  Download\n                </button>`:""}\n              </div>\n            </div>\n          `,t.appendChild(s)}))):e.style.display="none"}repeatFileRange(e,t,i){if(this.isProcessing)return;this.logger.info(`Repeating range for ${e}: ${t.toFixed(2)}s - ${i.toFixed(2)}s`),this.currentActiveFile=e,this.discoveryMode=!1;const o=this.discoveredFiles.get(e);o&&o.metadata&&(this.fileMetadata=o.metadata,this.metadataReceived=!0,this.fountainDecoder=new EnhancedFountainDecoder,this.fountainDecoder.initialize(o.metadata),this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this)),this.ui.initializeChunkGrid(o.metadata.chunksCount)),this.videoProcessor&&(this.videoProcessor.videoElement.currentTime=t,this.videoProcessor.discoveryMode=!1,this.videoProcessor.rangeMode=!0,this.videoProcessor.endTime=i,this.isProcessing=!0,this.videoProcessor.isProcessing=!0,this.videoProcessor.loopCount=1,document.getElementById("startScanBtn").disabled=!0,document.getElementById("continueBtn").disabled=!0,document.getElementById("stopScanBtn").disabled=!1,this.ui.updateFileInfo(`Repeating range for: ${e} (${t.toFixed(1)}s - ${i.toFixed(1)}s)`),this.videoProcessor.videoElement.play())}async checkAndAutoRepeatIncompleteFiles(){this.isProcessing=!1,this.ui.updateFileInfo(`Discovery complete - found ${this.discoveredFiles.size} files. Checking completion status...`),this.updateDiscoveredFilesUI();const e=[];for(const[t,i]of this.discoveredFiles.entries())e.push({filename:t,fileInfo:i});if(e.length>0){this.logger.info(`🔄 Found ${e.length} files that may need additional processing`),this.logger.info("🎯 Starting automatic range repeats (5 loops each) for better completion...");for(const{filename:t,fileInfo:i}of e)await this.autoRepeatFileRange(t,i.firstSeenAt,i.lastSeenAt,5);this.logger.info("✅ Automatic range processing complete for all files")}document.getElementById("startScanBtn").disabled=!1,document.getElementById("stopScanBtn").disabled=!0,this.ui.updateFileInfo("All files processed. Select a file above to decode or retry specific ranges.")}async autoRepeatFileRange(e,t,i,o=5){this.logger.info(`🔄 Auto-repeating ${e} range ${o} times: ${t.toFixed(2)}s - ${i.toFixed(2)}s`);for(let s=1;s<=o;s++){this.logger.info(`📹 Auto-repeat loop ${s}/${o} for ${e}`),this.currentActiveFile=e,this.discoveryMode=!1;const n=this.discoveredFiles.get(e);n&&n.metadata&&(this.fileMetadata=n.metadata,this.metadataReceived=!0,this.fountainDecoder=new EnhancedFountainDecoder,this.fountainDecoder.initialize(n.metadata),this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this)),this.ui.initializeChunkGrid(n.metadata.chunksCount)),await this.processVideoRange(t,i,s),s<o&&await new Promise((e=>setTimeout(e,1e3)))}}async processVideoRange(e,t,i){return new Promise((o=>{if(this.videoProcessor){this.videoProcessor.videoElement.currentTime=e,this.videoProcessor.discoveryMode=!1,this.videoProcessor.rangeMode=!0,this.videoProcessor.endTime=t,this.videoProcessor.loopCount=i,this.ui.updateFileInfo(`Auto-processing ${this.currentActiveFile} - Loop ${i} (${e.toFixed(1)}s - ${t.toFixed(1)}s)`),this.videoProcessor.isProcessing=!0,this.videoProcessor.videoElement.play();const s=setInterval((()=>{this.videoProcessor.isProcessing&&!this.videoProcessor.videoElement.paused||(clearInterval(s),o())}),500)}else o()}))}downloadCompletedFile(e){const t=this.discoveredFiles.get(e);if(t&&t.completed&&t.recoveredData)try{const i=new Blob([t.recoveredData],{type:t.metadata.fileType||"application/octet-stream"}),o=URL.createObjectURL(i),s=document.createElement("a");s.href=o,s.download=e,document.body.appendChild(s),s.click(),setTimeout((()=>{document.body.removeChild(s),URL.revokeObjectURL(o)}),100),this.downloadedFiles.add(e),this.logger.info(`📥 ENTERPRISE: Auto-downloaded discovered file: ${e} (${this.formatFileSize(t.recoveredData.byteLength)})`),console.log(`✅ ENTERPRISE SUCCESS: Discovered file "${e}" automatically downloaded`),console.log(`📋 ENTERPRISE: Added "${e}" to downloaded files list (${this.downloadedFiles.size} total)`)}catch(t){console.error(`❌ ENTERPRISE ERROR: Auto-download failed for discovered file ${e}:`,t.message),this.logger.error(`Error downloading file ${e}: ${t.message}`)}else this.logger.warn(`File ${e} is not available for download`)}checkAndStopIfAllFilesDownloaded(){if(0===this.discoveredFiles.size)return;const e=Array.from(this.discoveredFiles.keys()),t=Array.from(this.downloadedFiles),i=this.videoProcessor&&this.videoProcessor.loopCount||1,o=e.every((e=>t.includes(e)));if(console.log(`📊 ENTERPRISE SCALE CHECK: ${t.length}/${e.length} files downloaded, loop ${i}`),o)1===i?console.log(`📊 ENTERPRISE: All ${e.length} files downloaded in discovery loop - will validate at loop 2`):console.log(`✅ ENTERPRISE: All ${e.length} files confirmed downloaded in loop ${i}`);else{const i=e.filter((e=>!t.includes(e)));console.log(`🔄 ENTERPRISE: ${i.length} files still needed: ${i.join(", ")}`)}}formatFileSize(e){return e<1024?`${e} bytes`:e<1048576?`${(e/1024).toFixed(2)} KB`:`${(e/1048576).toFixed(2)} MB`}detectDeviceCapabilities(){const e=navigator.hardwareConcurrency||4,t=navigator.deviceMemory||4;let i=Math.min(Math.max(Math.floor(e/2),1),4),o=50;return(e<=2||t<=2)&&(i=1,o=100),e>=8&&t>=8&&(i=8,o=10),{workerCount:i,packetWorkerCount:Math.max(1,Math.floor(i/2)),frameInterval:o}}}function addDebugButton(){if("localhost"===window.location.hostname||"127.0.0.1"===window.location.hostname){const e=document.querySelector(".controls");if(!e)return;const t=document.createElement("button");t.id="debugToolsBtn",t.textContent="Debug Tools",t.style.backgroundColor="#6b7280",t.addEventListener("click",(()=>{console.log("Debug tools accessed. Use window.debugTools in the console to analyze decoder state."),window.debugTools.analyzeDecoderState()})),e.appendChild(t)}}window.debugTools={analyzeDecoderState:function(){if(!window.qrFileDecoder||!window.qrFileDecoder.fountainDecoder)return void console.error("Decoder not initialized");const e=window.qrFileDecoder.fountainDecoder,t={initialized:e.initialized,totalChunks:e.totalChunks,recoveredChunks:e.recoveredChunkCount,recoveryPercentage:e.recoveredChunkCount/e.totalChunks*100,waitingPackets:e.codedPackets.length,metadata:e.metaData,packetStats:e.packetStats};console.log("==== Decoder State Analysis ===="),console.table(t);const i=[];for(let t=0;t<e.totalChunks;t++)e.sourceChunks[t]||i.push(t);return i.length>0?console.log(`Missing chunks (${i.length}):`,i):console.log("All chunks recovered!"),t},exportRecoveredData:function(){if(!window.qrFileDecoder||!window.qrFileDecoder.recoveredFileData)return void console.error("No recovered file data available");const e=window.qrFileDecoder.recoveredFileData;console.log(`Recovered data length: ${e.byteLength} bytes`);const t=new Uint8Array(e.slice(0,100));return console.log("Data preview (first 100 bytes):",t),{byteLength:e.byteLength,preview:Array.from(t)}}},document.addEventListener("DOMContentLoaded",(()=>{window.qrFileDecoder=new QRFileDecoder,setTimeout(addDebugButton,500)}));</script></body></html>