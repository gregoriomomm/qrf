<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Camera QR Code File Decoder</title>
  <style>
    /* Base styles */
    :root {
      --primary-color: #2563eb;
      --secondary-color: #1d4ed8;
      --success-color: #10b981;
      --warning-color: #f59e0b;
      --error-color: #ef4444;
      --text-color: #1f2937;
      --bg-color: #f9fafb;
      --panel-bg: #ffffff;
      --border-color: #e5e7eb;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.5;
      color: var(--text-color);
      background-color: var(--bg-color);
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }

    h1,
    h2 {
      margin-bottom: 1rem;
    }

    button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: background-color 0.2s;
    }

    button:hover {
      background-color: var(--secondary-color);
    }

    button:disabled {
      background-color: #9ca3af;
      cursor: not-allowed;
    }

    select {
      padding: 8px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
      margin-right: 10px;
    }

    /* Control panel */
    .control-panel {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: var(--panel-bg);
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }

    .controls {
      display: flex;
      gap: 10px;
    }

    /* Video container */
    .video-container {
      position: relative;
      background-color: var(--panel-bg);
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }

    video {
      width: 100%;
      max-height: 400px;
      background-color: #000;
      border-radius: 4px;
    }

    canvas {
      position: absolute;
      top: 15px;
      left: 15px;
      pointer-events: none;
    }

    .progress-container {
      margin-top: 10px;
    }

    .progress-bar {
      height: 10px;
      background-color: var(--primary-color);
      width: 0%;
      border-radius: 5px;
      transition: width 0.3s ease;
    }

    .progress-text {
      font-size: 14px;
      margin-top: 5px;
      text-align: right;
    }

    /* Chunks visualization */
    .chunks-container {
      background-color: var(--panel-bg);
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }

    .chunks-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(20px, 1fr));
      gap: 4px;
      margin-top: 10px;
    }

    .chunk {
      height: 20px;
      background-color: rgba(229, 231, 235, 0.5);
      border: 1px solid var(--border-color);
      border-radius: 2px;
      transition: background-color 0.3s;
    }

    .chunk.pending {
      background-color: rgba(229, 231, 235, 0.5);
    }

    .chunk.received {
      background-color: rgba(16, 185, 129, 0.2);
      border-color: var(--success-color);
    }

    .chunk.blinking {
      animation: blink 0.5s;
    }

    @keyframes blink {
      0% {
        background-color: rgba(245, 158, 11, 0.5);
      }

      100% {
        background-color: rgba(16, 185, 129, 0.2);
      }
    }

    /* File information */
    .file-info-container {
      background-color: var(--panel-bg);
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }

    #downloadContainer {
      margin-top: 15px;
    }

    #downloadBtn {
      background-color: var(--success-color);
    }

    #downloadBtn:hover {
      background-color: #0d9668;
    }

    /* Debug log */
    .debug-container {
      background-color: var(--panel-bg);
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .log-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }

    .log-filter {
      background-color: #e5e7eb;
      color: var(--text-color);
      font-size: 12px;
      padding: 4px 8px;
    }

    .log-filter.active {
      background-color: var(--primary-color);
      color: white;
    }

    .log-window {
      height: 200px;
      overflow-y: auto;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 10px;
      font-family: monospace;
      font-size: 13px;
      background-color: #f1f5f9;
    }

    .log-entry {
      margin-bottom: 4px;
      border-bottom: 1px solid rgba(229, 231, 235, 0.5);
      padding-bottom: 4px;
    }

    .log-debug {
      color: #6b7280;
    }

    .log-info {
      color: #1d4ed8;
    }

    .log-warn {
      color: #b45309;
    }

    .log-error {
      color: #b91c1c;
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
    }

    .modal-content {
      background-color: var(--panel-bg);
      margin: 10% auto;
      padding: 20px;
      border-radius: 8px;
      max-width: 500px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      position: relative;
    }

    .close {
      position: absolute;
      right: 15px;
      top: 10px;
      font-size: 24px;
      cursor: pointer;
    }

    .settings-group {
      margin-bottom: 15px;
    }

    .settings-group label {
      display: block;
      margin-bottom: 5px;
    }

    .settings-group input {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
    }

    #saveSettingsBtn {
      margin-top: 10px;
    }

    /* Error message */
    .error-message {
      background-color: #fef2f2;
      border-left: 4px solid var(--error-color);
      padding: 15px;
      margin-bottom: 20px;
      color: #b91c1c;
      display: none;
    }

    /* Reset button styling */
    #resetBtn {
      background-color: var(--warning-color);
    }

    #resetBtn:hover {
      background-color: #e08c00;
    }

    /* Improved QR highlight styling */
    .scan-line {
      position: absolute;
      height: 2px;
      background-color: rgba(16, 185, 129, 0.8);
      animation: scan-animation 2s infinite;
    }

    @keyframes scan-animation {
      0% {
        opacity: 0.5;
      }

      50% {
        opacity: 1;
      }

      100% {
        opacity: 0.5;
      }
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .control-panel {
        flex-direction: column;
        align-items: flex-start;
      }

      .controls {
        margin-top: 10px;
        width: 100%;
        flex-wrap: wrap;
      }

      video {
        max-height: 300px;
      }

      .chunks-grid {
        grid-template-columns: repeat(auto-fill, minmax(15px, 1fr));
      }

      .chunk {
        height: 15px;
      }
    }
  </style>
</head>

<body>
  <!-- Error message container -->
  <div id="errorMessage" class="error-message"></div>

  <!-- 1. Header with controls -->
  <header class="control-panel">
    <h1>Camera QR Code File Decoder</h1>
    <div class="controls">
      <select id="cameraSelect">
        <option value="">Select Camera</option>
      </select>
      <button id="startCameraBtn">Start Camera</button>
      <button id="stopCameraBtn" disabled>Stop Camera</button>
      <button id="resetBtn">Reset Contents</button>
      <button id="settingsBtn">Advanced Settings</button>
    </div>
  </header>

  <!-- 2. Camera feed and overlay -->
  <div class="video-container">
    <video id="cameraFeed" autoplay playsinline></video>
    <canvas id="overlayCanvas"></canvas>
    <div class="progress-container">
      <div class="progress-bar" id="scanProgressBar"></div>
      <div class="progress-text" id="scanProgressText">QR Codes: 0 | Time: 00:00</div>
    </div>
  </div>

  <!-- 3. Chunk progress visualization -->
  <div class="chunks-container">
    <h2>Chunk Recovery Progress</h2>
    <div class="chunks-grid" id="chunksGrid"></div>
  </div>

  <!-- 4. File information -->
  <div class="file-info-container">
    <h2>File Information</h2>
    <div id="fileInfo">No file detected yet</div>
    <div id="missingChunks">Waiting for metadata...</div>
    <div id="downloadContainer" style="display: none;">
      <button id="downloadBtn">Download Recovered File</button>
    </div>
  </div>

  <!-- 5. Debug log window -->
  <div class="debug-container">
    <h2>Debug Log</h2>
    <div class="log-controls">
      <button class="log-filter active" data-level="all">All</button>
      <button class="log-filter" data-level="debug">Debug</button>
      <button class="log-filter" data-level="info">Info</button>
      <button class="log-filter" data-level="warn">Warnings</button>
      <button class="log-filter" data-level="error">Errors</button>
      <button id="clearLogBtn">Clear Log</button>
    </div>
    <div class="log-window" id="logWindow"></div>
  </div>

  <!-- Settings modal -->
  <div id="settingsModal" class="modal">
    <div class="modal-content">
      <span class="close">&times;</span>
      <h2>Advanced Settings</h2>
      <div class="settings-group">
        <label for="workerCount">QR Processing Workers:</label>
        <input type="number" id="workerCount" min="1" max="16" value="4">
      </div>
      <div class="settings-group">
        <label for="packetWorkerCount">Packet Processing Workers:</label>
        <input type="number" id="packetWorkerCount" min="1" max="8" value="2">
      </div>
      <div class="settings-group">
        <label for="frameInterval">Frame Processing Interval (ms):</label>
        <input type="number" id="frameInterval" min="0" max="1000" value="100">
      </div>
      <div class="settings-group">
        <label for="qrDetectionConfidence">QR Detection Confidence (0-1):</label>
        <input type="number" id="qrDetectionConfidence" min="0" max="1" step="0.1" value="0.5">
      </div>
      <div class="settings-group">
        <label for="cameraResolution">Camera Resolution:</label>
        <select id="cameraResolution">
          <option value="auto">Auto (Default)</option>
          <option value="hd">HD (1280x720)</option>
          <option value="fullhd">Full HD (1920x1080)</option>
          <option value="low">Low (640x480)</option>
        </select>
      </div>
      <button id="saveSettingsBtn">Save Settings</button>
    </div>
  </div>

  <!-- Html5QRCode library -->
  <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>

  <!-- Main script -->
  <script>
    // =============================================
    // Global Variables and Debug Control
    // =============================================
    
    // Global debug mode flag
    let debugMode = false;
    
    // Enable debug mode by pressing Ctrl+Shift+D
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.shiftKey && e.key === 'D') {
        debugMode = !debugMode;
        console.log('ðŸ”§ Debug mode: ' + (debugMode ? 'ENABLED' : 'DISABLED'));
      }
    });
    
    // Warn when tab goes to background (affects camera QR processing)
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        console.warn('âš ï¸ Tab backgrounded - Camera QR processing may be throttled. Keep tab active for best performance.');
      }
    });
    
    // =============================================
    // Logger Implementation
    // =============================================
    class Logger {
      constructor(logElementId) {
        this.logElement = document.getElementById(logElementId);
        this.filter = 'all';
        this.maxEntries = 500;
        this.entries = [];
      }

      debug(message) {
        this.log('debug', message);
      }

      info(message) {
        this.log('info', message);
      }

      warn(message) {
        this.log('warn', message);
      }

      error(message) {
        this.log('error', message);
      }

      log(level, message) {
        // Create entry object
        const entry = {
          timestamp: new Date(),
          level,
          message
        };

        // Add to entries array
        this.entries.push(entry);

        // Remove oldest entries if over max
        if (this.entries.length > this.maxEntries) {
          this.entries.shift();
        }

        // Create log entry element
        const entryElement = document.createElement('div');
        entryElement.className = 'log-entry log-' + (level);

        const timestamp = entry.timestamp.toLocaleTimeString();
        entryElement.innerHTML = '[' + (timestamp) + '] [' + (level.toUpperCase()) + '] ' + (message);

        // Apply filter
        if (this.filter !== 'all' && this.filter !== level) {
          entryElement.style.display = 'none';
        }

        // Add to log window
        this.logElement.appendChild(entryElement);

        // Scroll to bottom
        this.logElement.scrollTop = this.logElement.scrollHeight;
      }

      clear() {
        this.logElement.innerHTML = '';
        this.entries = [];
      }

      setFilter(filter) {
        this.filter = filter;

        // Apply filter to existing entries
        const entries = this.logElement.querySelectorAll('.log-entry');

        entries.forEach(entry => {
          if (filter === 'all') {
            entry.style.display = '';
          } else {
            const entryLevel = Array.from(entry.classList)
              .find(cls => cls.startsWith('log-'))
              .replace('log-', '');
            entry.style.display = entryLevel === filter ? '' : 'none';
          }
        });
      }
    }

    // =============================================
    // UI Management Class
    // =============================================
    class UI {
      constructor(logger) {
        this.logger = logger;
        this.overlayCanvas = document.getElementById('overlayCanvas');
        this.overlayCtx = this.overlayCanvas.getContext('2d');
      }

      resetChunkGrid() {
        const chunksGrid = document.getElementById('chunksGrid');
        chunksGrid.innerHTML = '';
        document.getElementById('scanProgressBar').style.width = '0%';
        document.getElementById('scanProgressText').textContent = 'QR Codes: 0 | Time: 00:00';
        document.getElementById('downloadContainer').style.display = 'none';
      }

      initializeChunkGrid(chunksCount) {
        const chunksGrid = document.getElementById('chunksGrid');
        chunksGrid.innerHTML = '';

        // Create chunk elements
        for (let i = 0; i < chunksCount; i++) {
          const chunkElement = document.createElement('div');
          chunkElement.className = 'chunk pending';
          chunkElement.dataset.index = i;
          chunksGrid.appendChild(chunkElement);
        }
      }

      updateProgress(progress, qrCodesDetected, elapsedTime) {
        // Update progress bar
        const progressBar = document.getElementById('scanProgressBar');
        progressBar.style.width = (progress * 100) + '%';

        // Update progress text
        const progressText = document.getElementById('scanProgressText');
        const minutes = Math.floor(elapsedTime / 60);
        const seconds = Math.floor(elapsedTime % 60);
        const timeString = (minutes.toString().padStart(2, '0')) + ':' + (seconds.toString().padStart(2, '0'));

        progressText.textContent = 'QR Codes: ' + (qrCodesDetected) + ' | Time: ' + (timeString);
      }

      updateFileInfo(htmlContent) {
        document.getElementById('fileInfo').innerHTML = htmlContent;
      }

      blinkChunk(chunkIndex) {
        const chunkElement = document.querySelector('.chunk[data-index="' + (chunkIndex) + '"]');
        if (chunkElement) {
          chunkElement.classList.remove('blinking');
          // Force reflow
          void chunkElement.offsetWidth;
          chunkElement.classList.add('blinking');
        }
      }

      markChunkAsRecovered(chunkIndex) {
        const chunkElement = document.querySelector('.chunk[data-index="' + (chunkIndex) + '"]');
        if (chunkElement) {
          chunkElement.classList.remove('pending');
          chunkElement.classList.add('received');
        }
      }

      showSettingsModal() {
        document.getElementById('settingsModal').style.display = 'block';
      }

      hideSettingsModal() {
        document.getElementById('settingsModal').style.display = 'none';
      }

      updateLogFilterButtons(activeButton) {
        document.querySelectorAll('.log-filter').forEach(btn => {
          btn.classList.remove('active');
        });

        activeButton.classList.add('active');
      }

      showErrorMessage(message) {
        const errorElement = document.getElementById('errorMessage');
        errorElement.textContent = message;
        errorElement.style.display = 'block';
      }

      hideErrorMessage() {
        const errorElement = document.getElementById('errorMessage');
        errorElement.style.display = 'none';
      }

      // Draw QR highlight with fixed position adjustment
      drawQRHighlight(x, y, width, height, padding = 10) {
        // Resize canvas to match video dimensions
        const video = document.getElementById('cameraFeed');
        if (this.overlayCanvas.width !== video.clientWidth ||
          this.overlayCanvas.height !== video.clientHeight) {
          this.overlayCanvas.width = video.clientWidth;
          this.overlayCanvas.height = video.clientHeight;
        }

        // Clear previous drawings
        this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);

        // Calculate scale factors
        const scaleX = video.clientWidth / video.videoWidth;
        const scaleY = video.clientHeight / video.videoHeight;

        // Adjust coordinates with padding
        const verticalOffset = 30; // Adjustment for vertical alignment
        const scaledX = (x - padding) * scaleX;
        const scaledY = (y - padding - verticalOffset) * scaleY; 

        // Use a square to ensure proper QR code coverage
        const scaledSize = Math.max((width + padding * 2) * scaleX, (height + padding * 2) * scaleY);
        const scaledWidth = scaledSize;
        const scaledHeight = scaledSize;

        // Draw rectangle
        this.overlayCtx.strokeStyle = '#10b981';
        this.overlayCtx.lineWidth = 3;
        this.overlayCtx.beginPath();
        this.overlayCtx.rect(scaledX, scaledY, scaledWidth, scaledHeight);
        this.overlayCtx.stroke();

        // Draw scanlines
        const scanlineCount = 3;
        const scanlineSpacing = scaledHeight / (scanlineCount + 1);
        this.overlayCtx.beginPath();
        for (let i = 1; i <= scanlineCount; i++) {
          const lineY = scaledY + scanlineSpacing * i;
          this.overlayCtx.moveTo(scaledX, lineY);
          this.overlayCtx.lineTo(scaledX + scaledWidth, lineY);
        }
        this.overlayCtx.stroke();

        // Draw corner markers
        const markerSize = 15;
        this.overlayCtx.fillStyle = '#10b981';

        // Top-left
        this.overlayCtx.fillRect(scaledX - markerSize / 2, scaledY - markerSize / 2, markerSize, markerSize);
        // Top-right
        this.overlayCtx.fillRect(scaledX + scaledWidth - markerSize / 2, scaledY - markerSize / 2, markerSize, markerSize);
        // Bottom-left
        this.overlayCtx.fillRect(scaledX - markerSize / 2, scaledY + scaledHeight - markerSize / 2, markerSize, markerSize);
        // Bottom-right
        this.overlayCtx.fillRect(scaledX + scaledWidth - markerSize / 2, scaledY + scaledHeight - markerSize / 2, markerSize, markerSize);
      }
      
      clearQRHighlight() {
        if (this.overlayCtx) {
          this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
        }
      }
    }

    // =============================================
    // Packet Processor Implementation
    // =============================================
    class PacketProcessor {
      constructor() {
        // No initialization needed for packet processing
      }

      processQRData(qrData, frameIndex) {
        try {
          // Detect packet type
          if (qrData.startsWith('M:')) {
            return this.processMetadataPacket(qrData, frameIndex);
          } else if (qrData.startsWith('D:')) {
            return this.processDataPacket(qrData, frameIndex);
          } else {
            throw new Error('Unknown packet format: ' + (qrData.substring(0, 10)) + '...');
          }
        } catch (error) {
          return {
            success: false,
            error: error.message,
            frameIndex
          };
        }
      }

      processMetadataPacket(metaString, frameIndex) {
        // Format: M:<version>:<filename>:<filetype>:<filesize>:<chunks>:<packets>:<maxdegree>:<density>:<fps>:<chunksize>:<redund>:<ecl>:<checksum>:<ltparams>
        const parts = metaString.split(':');

        if (parts.length < 10) {
          throw new Error('Invalid metadata packet format: ' + (metaString.substring(0, 30)) + '...');
        }

        let fileSize = -1;
        try {
          fileSize = parseInt(parts[4])
        } catch (e) {
          console.error('Invalid file size: ' + (parts[4]));
        }


        // Extract metadata
        const metadata = {
          protocolVersion: parts[1],
          fileName: this.decodeURIComponentSafe(parts[2]),
          fileType: this.decodeURIComponentSafe(parts[3]),
          fileSize: fileSize,
          chunksCount: parseInt(parts[5]),
          packetCount: parseInt(parts[6]),
          maxDegree: parseInt(parts[7]),
          density: parseFloat(parts[8]),
          fps: parts[9],
          chunkSize: parseInt(parts[10] || '1024'),
          redundancy: parseInt(parts[11] || '0'),
          ecl: parts[12] || 'L',
          checksum: parts[13] || '',
          ltParams: parts.slice(14).join(':')
        };

        // Validate metadata
        if (isNaN(metadata.fileSize) || metadata.fileSize <= 0) {
          metadata.fileSize = -1;
          console.error('Invalid file size: ' + (parts[4]));
        }

        if (isNaN(metadata.chunksCount) || metadata.chunksCount <= 0) {
          throw new Error('Invalid chunk count: ' + (parts[5]));
        }

        return {
          success: true,
          packetType: 'metadata',
          packetData: metadata,
          frameIndex
        };
      }

      processDataPacket(dataString, frameIndex) {
        // Format: D:<packetId>:<seed>:<seedBase>:<numChunks>:<degree>:<data>
        // Enhanced Format: D:<packetId>:<seed>:<seedBase>:<numChunks>:<degree>:<sourceIndices>:<xorData>
        const parts = dataString.split(':');

        if (parts.length < 7) {
          throw new Error('Invalid data packet format: ' + (dataString.substring(0, 30)) + '...');
        }

        const packetId = parseInt(parts[1]);
        const seed = parseInt(parts[2]);
        const seedBase = parseInt(parts[3]);
        const numChunks = parseInt(parts[4]);
        const chunkCount = parseInt(parts[5]); // This is chunk count, not degree!

        // Parse source chunks and data
        let sourceChunks = [];
        let systematicDataChunks = [];
        let fountainData = null;
        let format = "standard";

        // CORRECTED: Detect packet type by format analysis
        const allDataPart = parts.slice(6).join(':');
        
        if (parts[6] && parts[6].includes(',')) {
          // FOUNTAIN PACKET: Comma-separated indices in field 6 (always chunkCount=1)
          const sourceIndices = parts[6].split(',').map(idx => parseInt(idx));
          const actualDegree = sourceIndices.length; // TRUE degree from comma count
          
          if (debugMode) {
            console.debug('Fountain packet ' + (packetId) + ' with degree=' + (actualDegree) + ' (XOR of ' + (sourceIndices.join(',')) + ')');
          }
          
          format = "enhanced";
          sourceChunks = sourceIndices;
          
          try {
            // Field 7 contains base64 XOR data
            fountainData = this.base64ToUint8Array(parts[7]);
          } catch (e) {
            console.error('Failed to decode fountain XOR data: ' + (e.message));
            throw e;
          }
          
        } else {
          // SYSTEMATIC PACKET: Field 5 = chunkCount (1, 2, 3, 4+)
          if (debugMode) {
            console.debug('Systematic packet ' + (packetId) + ' with chunkCount=' + (chunkCount));
          }
          
          // Parse chunkCount records separated by pipe |
          const records = allDataPart.split('|');
          
          if (debugMode) {
            console.debug('Processing ' + (records.length) + ' systematic records (expected: ' + (chunkCount) + ')');
          }
          
          for (let i = 0; i < records.length; i++) {
            const record = records[i];
            const chunkParts = record.split(':', 2);
            
            if (chunkParts.length === 2) {
              const chunkIndex = parseInt(chunkParts[0]);
              const chunkData = chunkParts[1];

              if (chunkIndex >= 0 && chunkIndex < numChunks) {
                sourceChunks.push(chunkIndex);
                systematicDataChunks.push({ chunkIndex: chunkIndex, chunkData: chunkData });
                
                if (debugMode) {
                  console.debug('  Record ' + (i+1) + ': chunk ' + (chunkIndex) + ' (' + (chunkData.length) + ' base64 chars)');
                }
              } else {
                console.warn('  Invalid chunk index ' + (chunkIndex) + ' in record ' + (i+1));
              }
            } else {
              console.warn('  Invalid record format: ' + (record));
            }
          }
        }
          // Check if this is the enhanced format with explicit source indices and XOR data
          if (parts.length >= 8) {
            // Enhanced format - process directly
            format = "enhanced";
            
            // Part 6 contains explicit comma-separated indices
            try {
              sourceChunks = parts[6].split(',').map(idx => parseInt(idx));
              
              // Part 7 contains base64-encoded XOR data
              fountainData = this.base64ToUint8Array(parts[7]);
              
              console.debug('Enhanced fountain packet ' + (packetId) + ' with degree ' + (degree) + ', explicit source chunks: ' + (sourceChunks.join(',')));
            } catch (e) {
              console.error('Error parsing enhanced fountain packet: ' + (e.message) + ', falling back to legacy mode');
              // If we fail to parse the enhanced format, fall back to legacy mode
              format = "legacy";
            }
          } 
          
          // Legacy format handling or fallback
          if (format !== "enhanced") {
            // For older packets or fallback, determine chunks from seed as before
            const rng = this.createPRNG(seed);
            sourceChunks = this.selectChunksLT(rng, degree, numChunks);
            
            // Get the data part (everything after the 6th colon)
            const allDataPart = parts.slice(6).join(':');
            
            // For legacy format packets, assume the data is string-represented chunks
            // For the first implementation of fountains, convert from string
            if (allDataPart.includes('|')) {
              // This is the old format with concatenated chunks
              // We need to split it to extract the actual data
              const chunksData = allDataPart.split('|');
              const chunkContentArray = [];
              
              // Extract the actual data and recreate the proper XOR'd data
              for (let i = 0; i < chunksData.length; i++) {
                const chunkParts = chunksData[i].split(':', 2);
                if (chunkParts.length === 2) {
                  const chunkData = chunkParts[1];
                  chunkContentArray.push(this.stringToUint8Array(chunkData));
                }
              }
              
              // Manually XOR the chunks together
              if (chunkContentArray.length > 0) {
                fountainData = chunkContentArray[0];
                for (let i = 1; i < chunkContentArray.length; i++) {
                  // XOR the next chunk with the current result
                  this.xorUint8Arrays(fountainData, chunkContentArray[i]);
                }
              }
            } else {
              // Simple string to array conversion
              fountainData = this.stringToUint8Array(allDataPart);
            }
            
            console.debug('Legacy fountain packet ' + (packetId) + ' with degree ' + (degree) + ', generated source chunks: ' + (sourceChunks.join(',')));
          }
        
        // Check for truncated data
        let isTruncated = false;
        let originalLength = 0;

        // Only try to find truncation markers in original format
        if (format !== "enhanced" && format !== "legacy") {
          const allDataPart = parts.slice(6).join(':'); 
          const truncatedIndex = allDataPart.indexOf(':t:');
          if (truncatedIndex > 0) {
            isTruncated = true;
            const truncatedParts = allDataPart.substring(truncatedIndex + 3).split(':');
            originalLength = parseInt(truncatedParts[0] || '0');
          }
        }

        return {
          success: true,
          packetType: 'data',
          packetData: {
            packetId,
            seed,
            seedBase,
            degree,
            fountainData,
            systematicDataChunks,
            sourceChunks,
            isDegreeOne: degree === 1,
            isTruncated,
            originalLength,
            format  // Include the detected format for debugging
          },
          frameIndex
        };
      }

      // Safe URI decoding with fallback
      decodeURIComponentSafe(str) {
        try {
          return decodeURIComponent(str);
        } catch (e) {
          return str;
        }
      }

      // Create pseudo-random number generator
      createPRNG(seed) {
        let s = seed;
        return function () {
          s = Math.sin(s) * 10000;
          return s - Math.floor(s);
        };
      }

      // Select chunks using LT coding algorithm with robust distribution
      selectChunksLT(rng, degree, numChunks) {
        const indices = [];

        // Ensure we don't try to select more chunks than available
        const actualDegree = Math.min(degree, numChunks);

        // In LT codes, chunks are selected uniformly at random without replacement
        while (indices.length < actualDegree) {
          const index = Math.floor(rng() * numChunks);

          // Avoid duplicate chunks in the same packet
          if (!indices.includes(index)) {
            indices.push(index);
          }
        }

        return indices;
      }

      // Convert string to Uint8Array
      stringToUint8Array(str) {
        const arr = new Uint8Array(str.length);
        for (let i = 0; i < str.length; i++) {
          arr[i] = str.charCodeAt(i);
        }
        return arr;
      }

      // Method to manually XOR two Uint8Arrays in-place (first array is modified)
      xorUint8Arrays(target, source) {
        const minLength = Math.min(target.length, source.length);
        for (let i = 0; i < minLength; i++) {
          target[i] ^= source[i];
        }
      }

      // Add base64 decoder for XOR data
      base64ToUint8Array(base64) {
        try {
          const binaryString = atob(base64);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          return bytes;
        } catch (e) {
          throw new Error(`Base64 decode failed: ${e.message}`);
        }
      }

      stringToUint8Array(str) {
        const arr = new Uint8Array(str.length);
        for (let i = 0; i < str.length; i++) {
          arr[i] = str.charCodeAt(i);
        }
        return arr;
      }
    }

    // =============================================
    // Enhanced Fountain Decoder Implementation
    // =============================================
    class EnhancedFountainDecoder {
      constructor() {
        this.initialized = false;
        this.metaData = null;
        this.totalChunks = 0;

        // Decoded source chunks
        this.sourceChunks = {};
        this.recoveredChunkCount = 0;

        // Intermediate coded packets waiting to be decoded
        this.codedPackets = [];

        // Callback for when file is complete
        this.completeCallback = null;

        // Track newly recovered chunks
        this.newlyRecoveredChunks = [];

        // Debug info
        this.lastProcessedChunk = -1;
        this.packetStats = {
          total: 0,
          degree1: 0,
          degreeN: 0,
          usefulPackets: 0
        };
      }

      initialize(metadata) {
        this.metaData = metadata;
        this.totalChunks = metadata.chunksCount;
        this.initialized = true;

        // Reset decoder state
        this.sourceChunks = {};
        this.recoveredChunkCount = 0;
        this.codedPackets = [];
        this.newlyRecoveredChunks = [];
        this.packetStats = {
          total: 0,
          degree1: 0,
          degreeN: 0,
          usefulPackets: 0
        };

        console.log('Fountain decoder initialized with ' + (metadata.chunksCount) + ' chunks, file size: ' + (metadata.fileSize) + ' bytes');
      }

      setCompleteCallback(callback) {
        this.completeCallback = callback;
      }

      // Main method to add a packet for decoding
      addPacket(packet) {
        if (!this.initialized) {
          throw new Error("Fountain decoder not initialized");
        }

        this.packetStats.total++;

        // Handle systematic (degree 1) packets
        if (packet.isDegreeOne) {
          this.packetStats.degree1++;
          let anyNewChunks = false;

          packet.systematicDataChunks.forEach(chunk => {
            const chunkIndex = chunk.chunkIndex;
            if (!this.sourceChunks[chunkIndex]) {
              // For systematic packets, convert the string data to Uint8Array
              const chunkData = this.stringToUint8Array(chunk.chunkData);
              this.storeSourceChunk(chunkIndex, chunkData);
              this.newlyRecoveredChunks.push(chunkIndex);
              anyNewChunks = true;
            }
          });

          if (anyNewChunks) {
            this.packetStats.usefulPackets++;
            this.propagateAndDecode();
            return true;
          }
          return false;
        }

        // Handle fountain packets (degree > 1)
        this.packetStats.degreeN++;

        // Check if all source chunks in this packet are already recovered
        const missingChunks = packet.sourceChunks.filter(
          chunkIndex => !this.sourceChunks[chunkIndex]
        );

        // If we already have all chunks, skip this packet
        if (missingChunks.length === 0) {
          // Check if all chunks are recovered
          if (this.recoveredChunkCount === this.totalChunks) {
            console.log("All chunks recovered! Finalizing file...");
            this.finalizeFile();
          }
          return false;
        }

        // If we're missing just one chunk, we can recover it immediately
        if (missingChunks.length === 1) {
          const missingChunkIndex = missingChunks[0];

          // Create a copy of the fountain data to work with
          const resultData = new Uint8Array(packet.fountainData.length);
          resultData.set(packet.fountainData);

          // XOR with all the chunks we already have to get the missing one
          for (const chunkIndex of packet.sourceChunks) {
            if (chunkIndex !== missingChunkIndex && this.sourceChunks[chunkIndex]) {
              this.xorData(resultData, this.sourceChunks[chunkIndex]);
            }
          }

          // Store the recovered chunk
          this.storeSourceChunk(missingChunkIndex, resultData);
          this.newlyRecoveredChunks.push(missingChunkIndex);
          this.packetStats.usefulPackets++;
          this.propagateAndDecode();
          return true;
        }

        // Otherwise, store the fountain packet for later processing
        this.codedPackets.push(packet);
        return true;
      }

      // Process stored coded packets when new chunks are available
      propagateAndDecode() {
        let progress = true;

        while (progress) {
          progress = false;

          // Try to decode more chunks using the coded packets
          for (let i = this.codedPackets.length - 1; i >= 0; i--) {
            const packet = this.codedPackets[i];

            // Count missing chunks in this packet
            const missingChunks = packet.sourceChunks.filter(
              chunkIndex => !this.sourceChunks[chunkIndex]
            );

            if (missingChunks.length === 0) {
              // All chunks in this packet are recovered, remove it
              this.codedPackets.splice(i, 1);
              continue;
            }

            if (missingChunks.length === 1) {
              // We can recover exactly one chunk
              const missingChunkIndex = missingChunks[0];

              // Create a copy of the fountain data
              const resultData = new Uint8Array(packet.fountainData.length);
              resultData.set(packet.fountainData);

              // XOR with all the chunks we already have
              for (const chunkIndex of packet.sourceChunks) {
                if (chunkIndex !== missingChunkIndex && this.sourceChunks[chunkIndex]) {
                  this.xorData(resultData, this.sourceChunks[chunkIndex]);
                }
              }

              // Store the recovered chunk
              this.storeSourceChunk(missingChunkIndex, resultData);
              this.newlyRecoveredChunks.push(missingChunkIndex);
              this.packetStats.usefulPackets++;

              // Remove this packet as it's been used
              this.codedPackets.splice(i, 1);

              progress = true;
            }
          }
        }

        // Check if all chunks are recovered
        if (this.recoveredChunkCount === this.totalChunks) {
          console.log("All chunks recovered! Finalizing file...");
          this.finalizeFile();
        }
        
      }

      // Store a source chunk in our decoded data
      storeSourceChunk(index, data) {
        if (!this.sourceChunks[index]) {
          // Make sure data is a Uint8Array
          if (!(data instanceof Uint8Array)) {
            console.warn('Chunk ' + (index) + ' data is not a Uint8Array. Converting...');
            data = this.ensureUint8Array(data);
          }

          this.sourceChunks[index] = data;
          this.recoveredChunkCount++;
          console.debug('Stored chunk ' + (index) + ', now have ' + (this.recoveredChunkCount) + '/' + (this.totalChunks) + ' chunks');

          // Track progress for debugging
          if (index > this.lastProcessedChunk) {
            this.lastProcessedChunk = index;
          }
        }
      }

      // Helper to ensure data is a Uint8Array
      ensureUint8Array(data) {
        if (data instanceof Uint8Array) {
          return data;
        }

        if (typeof data === 'string') {
          return this.stringToUint8Array(data);
        }

        // If it's an array-like object, convert it
        if (Array.isArray(data) || ArrayBuffer.isView(data)) {
          return new Uint8Array(data);
        }

        console.error("Unknown data type, cannot convert to Uint8Array:", typeof data);
        return new Uint8Array(0);
      }

      // Convert string to Uint8Array
      stringToUint8Array(str) {
        const arr = new Uint8Array(str.length);
        for (let i = 0; i < str.length; i++) {
          arr[i] = str.charCodeAt(i);
        }
        return arr;
      }

      // XOR two binary arrays
      xorData(target, source) {
        const minLength = Math.min(target.length, source.length);
        for (let i = 0; i < minLength; i++) {
          target[i] ^= source[i];
        }
      }

      // Base64 decoder for chunk data (added to fountain decoder class)
      base64ToUint8Array(base64) {
        try {
          const binaryString = atob(base64);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          return bytes;
        } catch (e) {
          throw new Error('Base64 decode failed: ' + (e.message));
        }
      }

      // Get the list of newly recovered chunks since the last check
      getNewlyRecoveredChunks() {
        const chunks = [...this.newlyRecoveredChunks];
        this.newlyRecoveredChunks = [];
        return chunks;
      }

      // Get the current recovery progress
      getRecoveryProgress() {
        return {
          recovered: this.recoveredChunkCount,
          total: this.totalChunks,
          percentage: Math.round((this.recoveredChunkCount / this.totalChunks) * 100),
          packetStats: this.packetStats
        };
      }

      // Final step: reconstruct the file from decoded chunks
      finalizeFile() {
        console.log("Finalizing file reconstruction...");
        console.log('Recovery stats: ' + (this.recoveredChunkCount) + '/' + (this.totalChunks) + ' chunks');
        console.log('Packet stats: ' + (JSON.stringify(this.packetStats)));

        try {
          // First, verify we have all chunks
          for (let i = 0; i < this.totalChunks; i++) {
            if (!this.sourceChunks[i]) {
              console.error('Missing chunk ' + (i) + ' during file reconstruction, cannot finalize');
              return;
            }
          }

          // Get the actual file size from metadata
          let fileSize = this.metaData.fileSize;
          if (isNaN(fileSize) || fileSize <= 0) {
            // If file size not provided, calculate from chunks
            fileSize = 0;
            for (let i = 0; i < this.totalChunks; i++) {
              fileSize += this.sourceChunks[i].length;
            }
            console.log('File size not provided in metadata, calculated: ' + (fileSize) + ' bytes');
          }

          // Create final file data buffer
          let fileData = new Uint8Array(fileSize);
          let offset = 0;

          // Determine chunk size from metadata or first chunk
          const chunkSize = this.metaData.chunkSize || this.sourceChunks[0].length;
          console.log('Using chunk size: ' + (chunkSize) + ' bytes');

          // Combine all chunks in order
          for (let i = 0; i < this.totalChunks; i++) {
            const chunk = this.sourceChunks[i];

            // Ensure chunk exists and is a Uint8Array
            if (!chunk) {
              console.error('Chunk ' + (i) + ' is missing');
              continue;
            }

            if (!(chunk instanceof Uint8Array)) {
              console.error('Chunk ' + (i) + ' is not a Uint8Array: ' + (typeof chunk));
              continue;
            }

            // Calculate how much of this chunk to copy (handle last chunk)
            const bytesToCopy = Math.min(chunk.length, fileData.length - offset);

            try {
              fileData.set(chunk.subarray(0, bytesToCopy), offset);
              offset += bytesToCopy;
            } catch (e) {
              console.error('Error copying chunk ' + (i) + ':', e);
              console.error('Chunk length: ' + (chunk.length) + ', bytesToCopy: ' + (bytesToCopy) + ', offset: ' + (offset) + ', fileData.length: ' + (fileData.length));
              throw e;
            }

            if (offset >= fileData.length) {
              break;
            }
          }

          console.log('File reconstruction complete. Total size: ' + (fileData.length) + ' bytes');

          // Handle base64 encoding 
          try {
            console.log("Decoding base64 data...");
            const base64String = this.arrayBufferToString(fileData);
            fileData = this.base64ToArrayBuffer(base64String);
            console.log('Base64 decoded size: ' + (fileData.length) + ' bytes');
          } catch (e) {
            console.error("Error decoding base64:", e);
            // Continue with the original data if base64 decoding fails
          }


          // Notify completion
          if (this.completeCallback) {
            this.completeCallback(fileData);
          }
        } catch (error) {
          console.error("Error finalizing file:", error);
        }
      }

      arrayBufferToString(buffer) {
        const decoder = new TextDecoder('utf-8');
        return decoder.decode(buffer);
      }

      base64ToArrayBuffer(base64) {
        try {
          const binary = atob(base64);
          const bytes = new Uint8Array(binary.length);
          for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
          }
          return bytes;
        } catch (e) {
          console.error("Base64 decoding error:", e);
          throw e;
        }
      }
    }

    // =============================================
    // QR Processor Implementation
    // =============================================
    class EnhancedQRProcessor {
      constructor(options) {
        this.onQrDetected = options.onQrDetected;
        this.onError = options.onError;
        this.detectionConfidence = options.detectionConfidence || 0.5;

        // Create canvas for frame processing
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });

        // Stats
        this.detectionStats = {
          attempts: 0,
          successes: 0,
          failures: 0,
          lastDetectedFrameIndex: -1,
          duplicates: 0
        };

        // Cache of recently seen QR codes to detect duplicates
        this.recentlySeenQRs = new Map();
        this.maxCacheSize = 50;

        // Create a hidden element for the QR code reader
        this.qrElement = document.createElement('div');
        this.qrElement.id = 'qr-reader-hidden';
        this.qrElement.style.display = 'none';
        document.body.appendChild(this.qrElement);
      }

      async initialize() {
        try {
          // Initialize HTML5QRCode
          this.html5QrCode = new Html5Qrcode('qr-reader-hidden', {
            formatsToSupport: [
              Html5QrcodeSupportedFormats.QR_CODE,
              Html5QrcodeSupportedFormats.DATA_MATRIX,
              Html5QrcodeSupportedFormats.CODE_39,
              Html5QrcodeSupportedFormats.CODE_93,
              Html5QrcodeSupportedFormats.CODE_128,
              Html5QrcodeSupportedFormats.EAN_8,
              Html5QrcodeSupportedFormats.EAN_13,
              Html5QrcodeSupportedFormats.ITF,
              Html5QrcodeSupportedFormats.UPC_A,
              Html5QrcodeSupportedFormats.UPC_E
            ]
          });

          this.isReady = true;
          console.log("QR processor initialized successfully");
          return true;
        } catch (error) {
          if (this.onError) {
            this.onError(error);
          }
          console.error("Failed to initialize HTML5QRCode", error);
          throw error;
        }
      }

      processFrame(imageData, frameIndex) {
        if (!this.isReady) {
          throw new Error("QR processor not initialized");
        }

        this.detectionStats.attempts++;

        return new Promise((resolve, reject) => {
          try {
            // Make sure canvas is the right size
            if (this.canvas.width !== imageData.width || this.canvas.height !== imageData.height) {
              this.canvas.width = imageData.width;
              this.canvas.height = imageData.height;
            }

            // Draw image data to canvas
            this.ctx.putImageData(imageData, 0, 0);

            // Convert to data URL
            const dataUrl = this.canvas.toDataURL('image/jpeg');

            // Use HTML5QRCode to scan the image
            this.html5QrCode.scanFile(
              this.dataURLtoFile(dataUrl, 'frame.jpg'),
              /* showImage= */ false,
              /* defaultZoomValueIfZoomFeatureEnabled= */ undefined)
              .then(decodedText => {
                // QR code found
                this.detectionStats.successes++;

                // Check if this is a duplicate (same QR code detected in recent frames)
                const isDuplicate = this.checkDuplicate(decodedText, frameIndex);

                if (isDuplicate) {
                  this.detectionStats.duplicates++;
                  resolve({
                    success: false,
                    isDuplicate: true,
                    frameIndex: frameIndex
                  });
                } else {
                  // Track this detected QR code
                  this.addToRecentlySeen(decodedText, frameIndex);

                  this.detectionStats.lastDetectedFrameIndex = frameIndex;

                  // If every 10 successful detections, log stats
                  if (this.detectionStats.successes % 10 === 0) {
                    console.log('QR detection stats: ' + (this.detectionStats.successes) + '/' + (this.detectionStats.attempts) + ' successful (' + (this.detectionStats.duplicates) + ' duplicates)');
                  }

                  // Get the last decodedResult from the html5QrCode instance (if available)
                  const lastResult = this.html5QrCode._lastScanResult || null;

                  resolve({
                    success: true,
                    qrData: decodedText,
                    frameIndex: frameIndex,
                    bounds: this.estimateBounds({
                      result: lastResult,
                      imageData: imageData
                    })
                  });
                }
              })
              .catch(error => {
                // No QR code found or error
                this.detectionStats.failures++;
                resolve({
                  success: false,
                  frameIndex: frameIndex
                });
              });
          } catch (error) {
            // Error during processing
            this.detectionStats.failures++;
            if (this.onError) {
              this.onError(error);
            }
            resolve({
              success: false,
              frameIndex: frameIndex
            });
          }
        });
      }
      
      // Check if a QR code is a duplicate of one we've seen recently
      checkDuplicate(qrData, frameIndex) {
        if (this.recentlySeenQRs.has(qrData)) {
          const lastSeenFrame = this.recentlySeenQRs.get(qrData);
          // If we saw this QR code within the last 5 frames, consider it a duplicate
          return (frameIndex - lastSeenFrame) < 5;
        }
        return false;
      }

      // Add a QR code to the recently seen cache
      addToRecentlySeen(qrData, frameIndex) {
        // Add/update this QR code
        this.recentlySeenQRs.set(qrData, frameIndex);

        // If cache is too big, remove oldest entries
        if (this.recentlySeenQRs.size > this.maxCacheSize) {
          const entries = Array.from(this.recentlySeenQRs.entries());
          // Sort by frame index (ascending)
          entries.sort((a, b) => a[1] - b[1]);
          // Remove oldest 20% of entries
          const entriesToRemove = Math.ceil(this.maxCacheSize * 0.2);
          for (let i = 0; i < entriesToRemove; i++) {
            if (entries[i]) {
              this.recentlySeenQRs.delete(entries[i][0]);
            }
          }
        }
      }

      // Helper function to estimate QR code bounds
      estimateBounds(decodedResult) {
        // If decodedResult contains location info (from Html5QrCode), use it
        if (decodedResult && decodedResult.result && decodedResult.result.location) {
          const loc = decodedResult.result.location;

          // Calculate bounds from the QR code points
          const xValues = [loc.topLeft.x, loc.topRight.x, loc.bottomLeft.x, loc.bottomRight.x];
          const yValues = [loc.topLeft.y, loc.topRight.y, loc.bottomLeft.y, loc.bottomRight.y];

          const minX = Math.min(...xValues);
          const maxX = Math.max(...xValues);
          const minY = Math.min(...yValues);
          const maxY = Math.max(...yValues);

          // Since QR codes are square, use the larger dimension to ensure full coverage
          const width = maxX - minX;
          const height = maxY - minY;
          const size = Math.max(width, height);

          // Center the square around the detected QR code
          const centerX = (minX + maxX) / 2;
          const centerY = (minY + maxY) / 2;

          return {
            x: centerX - size / 2,
            y: centerY - size / 2,
            width: size,
            height: size
          };
        }

        // Fallback to a square centered estimation
        const imageData = decodedResult.imageData || {
          width: 300,
          height: 300
        };

        const centerX = imageData.width / 2;
        const centerY = imageData.height / 2;
        const size = Math.min(imageData.width, imageData.height) / 2.5;

        return {
          x: centerX - size / 2,
          y: 0,
          width: size,
          height: size
        };
      }
      
      // Convert data URL to File object
      dataURLtoFile(dataurl, filename) {
        const arr = dataurl.split(',');
        const mime = arr[0].match(/:(.*?);/)[1];
        const bstr = atob(arr[1]);
        let n = bstr.length;
        const u8arr = new Uint8Array(n);

        while (n--) {
          u8arr[n] = bstr.charCodeAt(n);
        }

        return new File([u8arr], filename, { type: mime });
      }

      // Clean up resources
      dispose() {
        if (this.html5QrCode) {
          // Clean up HTML5QRCode
          try {
            this.html5QrCode.clear();
          } catch (error) {
            console.error("Error clearing HTML5QRCode", error);
          }
        }

        // Remove the QR element from the document
        if (this.qrElement && this.qrElement.parentNode) {
          this.qrElement.parentNode.removeChild(this.qrElement);
        }

        console.log('QR processor disposed. Final stats: ' + (JSON.stringify(this.detectionStats)));
      }
    }

    // =============================================
    // Camera Processor for Camera-Based QR Scanning
    // =============================================
    class CameraProcessor {
      constructor(options) {
        this.frameCallback = options.frameCallback;
        this.progressCallback = options.progressCallback;
        this.errorCallback = options.errorCallback;
        this.frameInterval = options.frameInterval || 100;
        
        this.videoElement = document.getElementById('cameraFeed');
        this.isProcessing = false;
        this.processTimer = null;
        this.currentStream = null;
        this.cameraSelect = document.getElementById('cameraSelect');
        
        // Initialize frame processing canvas
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
        
        // Stats
        this.frameStats = {
          processed: 0,
          qrCodesDetected: 0,
          processingTimes: []
        };
        
        this.startTime = 0;
        this.currentFrame = 0;
      }
      
      async listCameras() {
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const videoDevices = devices.filter(device => device.kind === 'videoinput');
          
          // Clear previous options
          while (this.cameraSelect.firstChild) {
            this.cameraSelect.removeChild(this.cameraSelect.firstChild);
          }
          
          // Add default option
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.textContent = 'Select Camera';
          this.cameraSelect.appendChild(defaultOption);
          
          // Add cameras to dropdown
          videoDevices.forEach((device, index) => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.textContent = device.label || 'Camera ' + (index + 1);
            this.cameraSelect.appendChild(option);
          });
          
          // If only one camera is available, select it automatically
          if (videoDevices.length === 1) {
            this.cameraSelect.value = videoDevices[0].deviceId;
          }
          
          return videoDevices.length > 0;
        } catch (error) {
          console.error('Error listing cameras:', error);
          if (this.errorCallback) {
            this.errorCallback(error);
          }
          return false;
        }
      }
      
      async initialize(deviceId = null, resolution = 'auto') {
        try {
          // Stop any existing streams
          if (this.currentStream) {
            this.stopCamera();
          }
          
          // Set up camera constraints
          const constraints = {
            video: {
              facingMode: 'environment', // Prefer back camera on mobile
            },
            audio: false
          };
          
          // If device ID is provided, use it
          if (deviceId) {
            constraints.video.deviceId = { exact: deviceId };
          }
          
          // Apply resolution settings
          if (resolution === 'hd') {
            constraints.video.width = { ideal: 1280 };
            constraints.video.height = { ideal: 720 };
          } else if (resolution === 'fullhd') {
            constraints.video.width = { ideal: 1920 };
            constraints.video.height = { ideal: 1080 };
          } else if (resolution === 'low') {
            constraints.video.width = { ideal: 640 };
            constraints.video.height = { ideal: 480 };
          }
          
          // Get camera stream
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          this.currentStream = stream;
          this.videoElement.srcObject = stream;
          
          // Wait for video to be ready
          await new Promise(resolve => {
            this.videoElement.onloadedmetadata = () => {
              this.videoElement.play();
              resolve();
            };
          });
          
          // Set canvas dimensions to match video
          this.canvas.width = this.videoElement.videoWidth;
          this.canvas.height = this.videoElement.videoHeight;
          
          console.log('Camera initialized: ' + (this.videoElement.videoWidth) + 'x' + (this.videoElement.videoHeight));
          
          return true;
        } catch (error) {
          console.error('Error initializing camera:', error);
          if (this.errorCallback) {
            this.errorCallback(error);
          }
          return false;
        }
      }
      
      startProcessing() {
        if (this.isProcessing) return;
        
        this.isProcessing = true;
        this.startTime = performance.now();
        this.currentFrame = 0;
        this.frameStats = {
          processed: 0,
          qrCodesDetected: 0,
          processingTimes: []
        };
        
        // Use requestVideoFrameCallback if available
        if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
          this.processWithVideoFrameCallback();
        } else {
          // Fallback to setInterval
          this.processTimer = setInterval(() => {
            this.processCurrentFrame();
          }, this.frameInterval);
        }
        
        console.log('Camera processing started with frame interval: ' + (this.frameInterval) + 'ms');
      }
      
      processWithVideoFrameCallback() {
        const processFrame = (now, metadata) => {
          if (!this.isProcessing) return;
          
          this.processCurrentFrame();
          
          // Request next frame if still processing
          if (this.isProcessing && this.videoElement.readyState === this.videoElement.HAVE_ENOUGH_DATA) {
            this.videoElement.requestVideoFrameCallback(processFrame);
          }
        };
        
        this.videoElement.requestVideoFrameCallback(processFrame);
      }
      
      processCurrentFrame() {
        if (!this.isProcessing || !this.videoElement.readyState === this.videoElement.HAVE_ENOUGH_DATA) return;
        
        const processingStart = performance.now();
        
        try {
          // Extract frame
          this.currentFrame++;
          this.frameStats.processed++;
          
          // Draw current frame to canvas
          this.ctx.drawImage(this.videoElement, 0, 0, this.canvas.width, this.canvas.height);
          
          // Get frame data
          const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
          
          // Calculate elapsed time
          const elapsedTime = (performance.now() - this.startTime) / 1000;
          
          // Calculate progress (based on chunks recovered rather than time)
          // This will be updated by the main decoder class
          const progress = 0;
          
          // Call progress callback
          if (this.progressCallback) {
            this.progressCallback(progress, this.frameStats.qrCodesDetected, elapsedTime);
          }
          
          // Call frame callback
          if (this.frameCallback) {
            this.frameCallback(imageData, elapsedTime, this.currentFrame);
          }
          
          // Track processing time
          const processingTime = performance.now() - processingStart;
          this.frameStats.processingTimes.push(processingTime);
          
          // Calculate average processing time every 30 frames
          if (this.frameStats.processed % 30 === 0) {
            const avgTime = this.frameStats.processingTimes.reduce((sum, time) => sum + time, 0) /
              this.frameStats.processingTimes.length;
            console.log('Avg frame processing time: ' + (avgTime.toFixed(2)) + 'ms over last ' + (this.frameStats.processingTimes.length) + ' frames');
            
            // Reset the array to avoid memory growth
            this.frameStats.processingTimes = [];
            
            // Adjust frame interval if needed
            if (avgTime > this.frameInterval * 1.5) {
              // Processing is taking too long, increase interval
              const newInterval = Math.min(Math.ceil(avgTime * 1.2), 200);
              console.log('Adjusting frame interval from ' + (this.frameInterval) + 'ms to ' + (newInterval) + 'ms due to performance');
              this.frameInterval = newInterval;
              
              // Update timer if using setInterval
              if (this.processTimer) {
                clearInterval(this.processTimer);
                this.processTimer = setInterval(() => {
                  this.processCurrentFrame();
                }, this.frameInterval);
              }
            }
          }
        } catch (error) {
          console.error('Error processing frame:', error);
          if (this.errorCallback) {
            this.errorCallback(error);
          }
        }
      }
      
      stopProcessing() {
        this.isProcessing = false;
        
        // Clear timer if using interval
        if (this.processTimer) {
          clearInterval(this.processTimer);
          this.processTimer = null;
        }
        
        console.log('Camera processing stopped. Processed ' + (this.frameStats.processed) + ' frames, detected ' + (this.frameStats.qrCodesDetected) + ' QR codes');
      }
      
      stopCamera() {
        this.stopProcessing();
        
        // Stop all tracks in the stream
        if (this.currentStream) {
          this.currentStream.getTracks().forEach(track => track.stop());
          this.currentStream = null;
        }
        
        // Clear video source
        this.videoElement.srcObject = null;
        
        console.log('Camera stopped');
      }
    }

    // =============================================
    // Main QR File Decoder Class (Integration)
    // =============================================
    class QRFileDecoder {
      constructor() {
        this.logger = new Logger('logWindow');
        this.ui = new UI(this.logger);

        // Initialize components
        this.cameraProcessor = null;
        this.qrProcessor = null;
        this.packetProcessor = null;
        this.fountainDecoder = null;

        // Application state
        this.isProcessing = false;
        this.metadataReceived = false;
        this.fileMetadata = null;
        this.recoveredChunks = new Map();
        this.missingChunks = new Set();
        this.settings = {
          workerCount: 4,
          packetWorkerCount: 2,
          frameInterval: 100,
          qrDetectionConfidence: 0.5,
          cameraResolution: 'auto'
        };

        // Debug counters
        this.qrCodesDetected = 0;
        this.packetsProcessed = 0;

        // Recovered file data
        this.recoveredFileData = null;

        // Initialize
        this.checkCompatibility();
        this.initEventListeners();

        this.logger.info("Camera-based QR File Decoder initialized");
        
        // Initialize camera list
        this.initializeCameraList();
      }
      
      async initializeCameraList() {
        try {
          // Check if media devices are supported
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error("Camera access not supported in this browser");
          }

          // First try to enumerate devices without permission (may have limited info)
          let devices = [];
          try {
            devices = await navigator.mediaDevices.enumerateDevices();
          } catch (enumError) {
            console.warn("Failed to enumerate devices:", enumError);
          }

          // Check if we already have camera permission
          let hasPermission = false;
          try {
            const permissions = await navigator.permissions.query({ name: 'camera' });
            hasPermission = permissions.state === 'granted';
          } catch (permError) {
            console.warn("Failed to check camera permission:", permError);
          }

          // If no permission, request it
          if (!hasPermission) {
            try {
              // Request camera permission with minimal constraints
              const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                  width: { ideal: 320 }, 
                  height: { ideal: 240 } 
                } 
              });
              
              // Stop the stream immediately
              stream.getTracks().forEach(track => track.stop());
            } catch (permissionError) {
              // Handle specific permission errors
              if (permissionError.name === 'NotAllowedError') {
                throw new Error("Camera permission denied. Please allow camera access and refresh the page.");
              } else if (permissionError.name === 'NotFoundError') {
                throw new Error("No camera found. Please connect a camera and refresh the page.");
              } else if (permissionError.name === 'NotReadableError') {
                throw new Error("Camera is in use by another application. Please close other apps using the camera.");
              } else {
                throw new Error('Camera access failed: ' + (permissionError.message));
              }
            }
          }
          
          // Now list available cameras with proper error handling
          if (this.cameraProcessor) {
            const success = await this.cameraProcessor.listCameras();
            if (!success) {
              throw new Error("Failed to list available cameras");
            }
          } else {
            // Create camera processor if not exists
            this.cameraProcessor = new CameraProcessor({
              frameCallback: this.handleVideoFrame.bind(this),
              progressCallback: this.handleProgress.bind(this),
              errorCallback: (error) => this.logger.error('Camera error: ' + (error.message))
            });
            
            const success = await this.cameraProcessor.listCameras();
            if (!success) {
              throw new Error("Failed to list available cameras");
            }
          }
          
          // Verify we have at least one camera option
          const cameraSelect = document.getElementById('cameraSelect');
          if (cameraSelect.options.length <= 1) {
            throw new Error("No cameras available. Please connect a camera and refresh the page.");
          }
          
          this.logger.info('Camera list initialized successfully with ' + (cameraSelect.options.length - 1) + ' camera(s)');
        } catch (error) {
          this.logger.error('Failed to initialize camera list: ' + (error.message));
          this.ui.showErrorMessage(error.message);
          
          // Disable camera functionality
          document.getElementById('startCameraBtn').disabled = true;
          document.getElementById('cameraSelect').disabled = true;
        }
      }

      checkCompatibility() {
        // Check for camera support with fallbacks
        const hasModernAPI = navigator.mediaDevices && navigator.mediaDevices.getUserMedia;
        const hasLegacyAPI = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
        
        if (!hasModernAPI && !hasLegacyAPI) {
          this.ui.showErrorMessage("Camera access is not supported in your browser. Please use a modern browser with camera support.");
          document.getElementById('startCameraBtn').disabled = true;
        } else if (!hasModernAPI) {
          this.ui.showErrorMessage("Using legacy camera API. Some features may not work optimally.");
        }

        // Check for HTML5QRCode library
        if (typeof Html5Qrcode === 'undefined') {
          this.ui.showErrorMessage("HTML5QRCode library is not available. Please check your internet connection and reload the page.");
          document.getElementById('startCameraBtn').disabled = true;
        }
      }

      resetContents() {
        if (this.isProcessing) {
          this.stopProcessing();
        }

        // Reset all application state
        this.metadataReceived = false;
        this.fileMetadata = null;
        this.recoveredChunks = new Map();
        this.missingChunks = new Set();
        this.qrCodesDetected = 0;
        this.packetsProcessed = 0;
        this.recoveredFileData = null;

        // Reset UI elements
        this.ui.resetChunkGrid();
        this.ui.updateFileInfo("No file detected yet");
        document.getElementById('missingChunks').textContent = "Waiting for metadata...";
        document.getElementById('scanProgressBar').style.width = '0%';
        document.getElementById('scanProgressText').textContent = 'QR Codes: 0 | Time: 00:00';
        document.getElementById('downloadContainer').style.display = 'none';
        this.ui.clearQRHighlight();
        this.ui.hideErrorMessage();

        this.logger.info("Contents reset, ready for new scan");
      }

      initEventListeners() {
        // Button clicks
        document.getElementById('startCameraBtn').addEventListener('click', this.startCamera.bind(this));
        document.getElementById('stopCameraBtn').addEventListener('click', this.stopCamera.bind(this));
        document.getElementById('resetBtn').addEventListener('click', this.resetContents.bind(this));
        document.getElementById('downloadBtn').addEventListener('click', this.downloadFile.bind(this));
        document.getElementById('settingsBtn').addEventListener('click', this.ui.showSettingsModal.bind(this.ui));
        document.getElementById('saveSettingsBtn').addEventListener('click', this.saveSettings.bind(this));
        document.getElementById('clearLogBtn').addEventListener('click', this.logger.clear.bind(this.logger));

        // Log filters
        document.querySelectorAll('.log-filter').forEach(btn => {
          btn.addEventListener('click', (e) => {
            this.logger.setFilter(e.target.dataset.level);
            this.ui.updateLogFilterButtons(e.target);
          });
        });

        // Settings modal close
        document.querySelector('.modal .close').addEventListener('click', this.ui.hideSettingsModal.bind(this.ui));
      }

      async startCamera() {
        if (this.isProcessing) {
          this.logger.warn("Processing already in progress");
          return;
        }
        
        const cameraSelect = document.getElementById('cameraSelect');
        const selectedCamera = cameraSelect.value;
        
        // Check if camera select is disabled (no cameras available)
        if (cameraSelect.disabled) {
          this.logger.error("No cameras available. Please check camera connection and refresh the page.");
          this.ui.showErrorMessage("No cameras available. Please check camera connection and refresh the page.");
          return;
        }
        
        if (!selectedCamera && cameraSelect.options.length > 1) {
          this.logger.warn("Please select a camera from the dropdown");
          this.ui.showErrorMessage("Please select a camera from the dropdown");
          return;
        }
        
        this.isProcessing = true;
        
        // Update UI
        document.getElementById('startCameraBtn').disabled = true;
        document.getElementById('stopCameraBtn').disabled = false;
        document.getElementById('downloadContainer').style.display = 'none';
        this.ui.resetChunkGrid();
        this.ui.updateFileInfo("Initializing camera...");
        this.ui.clearQRHighlight();
        this.ui.hideErrorMessage();
        
        try {
          // Initialize components
          await this.initializeComponents();
          
          // Start camera with selected device
          const success = await this.cameraProcessor.initialize(
            selectedCamera, 
            this.settings.cameraResolution
          );
          
          if (success) {
            this.cameraProcessor.startProcessing();
            this.ui.updateFileInfo("Camera active. Point at QR codes to scan...");
            this.logger.info("Camera processing started");
          } else {
            throw new Error("Failed to initialize camera");
          }
        } catch (error) {
          this.logger.error('Failed to start camera: ' + (error.message));
          this.ui.showErrorMessage('Failed to start camera: ' + (error.message));
          this.stopCamera();
        }
      }

      async initializeComponents() {
        // Initialize Camera processor if not already created
        if (!this.cameraProcessor) {
          this.cameraProcessor = new CameraProcessor({
            frameCallback: this.handleVideoFrame.bind(this),
            progressCallback: this.handleProgress.bind(this),
            errorCallback: (error) => this.logger.error('Camera error: ' + (error.message)),
            frameInterval: this.settings.frameInterval
          });
        } else {
          // Update frame interval if needed
          this.cameraProcessor.frameInterval = this.settings.frameInterval;
        }

        // Initialize QR processor
        this.qrProcessor = new EnhancedQRProcessor({
          onQrDetected: this.handleQRCodeResult.bind(this),
          onError: (error) => this.logger.error('QR processing error: ' + (error.message)),
          detectionConfidence: this.settings.qrDetectionConfidence
        });

        await this.qrProcessor.initialize();

        // Initialize packet processor
        this.packetProcessor = new PacketProcessor();

        // Initialize fountain decoder
        this.fountainDecoder = new EnhancedFountainDecoder();
        this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this));
      }

      stopCamera() {
        if (!this.isProcessing) return;

        this.isProcessing = false;

        // Stop camera processing
        if (this.cameraProcessor) {
          this.cameraProcessor.stopCamera();
        }

        // Clean up QR processor
        if (this.qrProcessor) {
          this.qrProcessor.dispose();
        }

        // Clear QR highlight
        this.ui.clearQRHighlight();

        // Update UI
        document.getElementById('startCameraBtn').disabled = false;
        document.getElementById('stopCameraBtn').disabled = true;
        this.logger.info("Camera processing stopped");

        // Show stats
        this.logger.info('Processing summary: Detected ' + (this.qrCodesDetected) + ' QR codes, processed ' + (this.packetsProcessed) + ' packets');

        if (this.metadataReceived) {
          const progress = this.fountainDecoder.getRecoveryProgress();
          this.logger.info('File recovery progress: ' + (progress.recovered) + '/' + (progress.total) + ' chunks (' + (progress.percentage) + '%)');
          if (progress.packetStats) {
            this.logger.info('Packet statistics: ' + (JSON.stringify(progress.packetStats)));
          }
        }
      }
      
      stopProcessing() {
        // Combined stop function that stops both camera and processing
        this.stopCamera();
      }
      
      handleProgress(progress, qrCodesDetected, elapsedTime) {
        // Calculate real progress based on recovered chunks
        if (this.metadataReceived && this.fileMetadata) {
          const recoveredChunks = this.fountainDecoder.getRecoveryProgress().recovered;
          const totalChunks = this.fileMetadata.chunksCount;
          progress = recoveredChunks / totalChunks;
        }
        
        this.ui.updateProgress(progress, qrCodesDetected, elapsedTime);
      }

      async handleVideoFrame(imageData, timestamp, frameIndex) {
        if (!this.isProcessing) return;

        try {
          // Process frame for QR codes
          const result = await this.qrProcessor.processFrame(imageData, frameIndex);

          if (result.success) {
            this.qrCodesDetected++;
            
            // Update camera processor stats
            if (this.cameraProcessor) {
              this.cameraProcessor.frameStats.qrCodesDetected++;
            }

            // Draw QR highlight if bounds are available
            if (result.bounds) {
              this.ui.drawQRHighlight(
                result.bounds.x,
                result.bounds.y,
                result.bounds.width,
                result.bounds.height
              );

              // Log detection
              this.logger.info('QR code detected in frame ' + (frameIndex) + ' at position [' + (result.bounds.x.toFixed(0)) + ', ' + (result.bounds.y.toFixed(0)) + ']');
            } else {
              this.logger.info('QR code detected in frame ' + (frameIndex));
            }

            // Process QR data
            this.handleQRCodeResult(result);
          } else if (result.isDuplicate) {
            // Skip duplicate QR codes silently
          } else {
            // Clear QR highlight if no QR code detected
            this.ui.clearQRHighlight();
          }
        } catch (error) {
          this.logger.error('Error processing frame ' + (frameIndex) + ': ' + (error.message));
        }
      }

      handleQRCodeResult(result) {
        if (!result.success) {
          return;
        }

        const { qrData, frameIndex } = result;
        this.logger.debug('QR code detected in frame ' + (frameIndex) + ': ' + (qrData.substring(0, 30)) + '...');

        // Process the QR data
        const packetResult = this.packetProcessor.processQRData(qrData, frameIndex);

        if (packetResult.success) {
          this.handlePacketResult(packetResult);
        } else {
          this.logger.warn('Failed to process QR data: ' + (packetResult.error));
        }
      }

      handlePacketResult(result) {
        if (!result.success) {
          this.logger.warn('Failed to process packet: ' + (result.error));
          return;
        }

        this.packetsProcessed++;
        const { packetType, packetData } = result;

        if (packetType === 'metadata') {
          this.handleMetadataPacket(packetData);
        } else if (packetType === 'data') {
          this.handleDataPacket(packetData);
        }
      }

      handleMetadataPacket(metadata) {
        // Check if we already have metadata and if it matches
        if (this.metadataReceived) {
          // Compare key properties to see if this is the same file
          if (metadata.fileName === this.fileMetadata.fileName &&
            metadata.fileSize === this.fileMetadata.fileSize &&
            metadata.chunksCount === this.fileMetadata.chunksCount) {
            // Same file, just log and return
            this.logger.debug("Received duplicate metadata packet");
            return;
          } else {
            // Different file, log and reinitialize
            this.logger.warn("Received metadata for a different file, reinitializing");
          }
        }

        this.metadataReceived = true;
        this.fileMetadata = metadata;

        // Initialize UI with metadata
        this.ui.initializeChunkGrid(metadata.chunksCount);
        this.ui.updateFileInfo('\n          <div><strong>File Name:</strong> ' + (metadata.fileName) + '</div>\n          <div><strong>File Type:</strong> ' + (metadata.fileType) + '</div>\n          <div><strong>File Size:</strong> ' + (this.formatFileSize(metadata.fileSize)) + '</div>\n          <div><strong>Chunks:</strong> ' + (metadata.chunksCount) + '</div>\n          <div><strong>Protocol Version:</strong> ' + (metadata.protocolVersion) + '</div>\n        ');

        // Initialize fountain decoder with metadata
        this.fountainDecoder.initialize(metadata);

        // Initialize missing chunks set
        for (let i = 0; i < metadata.chunksCount; i++) {
          this.missingChunks.add(i);
        }

        this.updateMissingChunksUI();

        this.logger.info('Metadata received: ' + (metadata.fileName) + ' (' + (this.formatFileSize(metadata.fileSize)) + '), ' + (metadata.chunksCount) + ' chunks');
      }

      handleDataPacket(packet) {
        // Skip if metadata hasn't been received
        if (!this.metadataReceived) {
          this.logger.warn("Received data packet before metadata, ignoring");
          return;
        }

        // Always blink source chunks to show detection, even for duplicates
        if (packet.sourceChunks) {
          packet.sourceChunks.forEach(chunkIndex => {
            this.ui.blinkChunk(chunkIndex);
          });
        }

        // Add packet to fountain decoder
        const wasAdded = this.fountainDecoder.addPacket(packet);

        if (wasAdded) {
          // Update recovered chunks
          const newlyRecovered = this.fountainDecoder.getNewlyRecoveredChunks();
          if (newlyRecovered.length > 0) {
            newlyRecovered.forEach(chunkIndex => {
              this.recoveredChunks.set(chunkIndex, true);
              this.missingChunks.delete(chunkIndex);
              this.ui.markChunkAsRecovered(chunkIndex);
            });

            this.updateMissingChunksUI();
            this.logger.info('Recovered ' + (newlyRecovered.length) + ' new chunks, total: ' + (this.recoveredChunks.size) + '/' + (this.fileMetadata.chunksCount));
          }
        }
      }

      updateMissingChunksUI() {
        const missingCount = this.missingChunks.size;
        const totalCount = this.fileMetadata.chunksCount;
        const recoveredCount = totalCount - missingCount;

        document.getElementById('missingChunks').innerHTML = '\n          <div>Recovered chunks: ' + (recoveredCount) + '/' + (totalCount) + ' (' + (Math.round(recoveredCount / totalCount * 100)) + '%)</div>\n          <div>Missing chunks: ' + (missingCount) + '</div>\n        ';

        // If all chunks are recovered, show recovery status
        if (missingCount === 0 && recoveredCount === totalCount) {
          this.logger.info("All chunks recovered, finalizing file...");
        }
      }

      handleFileComplete(fileData) {
        this.logger.info("File recovery complete!");

        // Store the recovered file data
        this.recoveredFileData = fileData;

        // Show download button
        document.getElementById('downloadContainer').style.display = 'block';

        // Update file info with success message
        const fileInfo = document.getElementById('fileInfo').innerHTML;
        document.getElementById('fileInfo').innerHTML = fileInfo + '\n          <div style="margin-top: 10px; color: var(--success-color);">\n            <strong>File Successfully Recovered!</strong>\n          </div>\n        ';

        // Automatically trigger the download
        this.downloadFile();
      }

      downloadFile() {
        if (!this.recoveredFileData || !this.fileMetadata) {
          this.logger.warn("No recovered file data available");
          return;
        }

        try {
          // Create blob from recovered data
          const blob = new Blob([this.recoveredFileData], { type: this.fileMetadata.fileType || 'application/octet-stream' });

          // Create download link
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = this.fileMetadata.fileName;
          document.body.appendChild(a);
          a.click();

          // Clean up
          setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          }, 100);

          this.logger.info('File "' + (this.fileMetadata.fileName) + '" downloaded (' + (this.formatFileSize(this.recoveredFileData.byteLength)) + ')');
        } catch (error) {
          this.logger.error('Error downloading file: ' + (error.message));
          this.ui.showErrorMessage('Error downloading file: ' + (error.message));
        }
      }

      saveSettings() {
        // Get values from settings form
        const workerCount = parseInt(document.getElementById('workerCount').value);
        const packetWorkerCount = parseInt(document.getElementById('packetWorkerCount').value);
        const frameInterval = parseInt(document.getElementById('frameInterval').value);
        const qrDetectionConfidence = parseFloat(document.getElementById('qrDetectionConfidence').value);
        const cameraResolution = document.getElementById('cameraResolution').value;

        // Validate and update settings
        this.settings = {
          workerCount: isNaN(workerCount) ? 4 : Math.min(Math.max(workerCount, 1), 16),
          packetWorkerCount: isNaN(packetWorkerCount) ? 2 : Math.min(Math.max(packetWorkerCount, 1), 8),
          frameInterval: isNaN(frameInterval) ? 100 : Math.min(Math.max(frameInterval, 0), 1000),
          qrDetectionConfidence: isNaN(qrDetectionConfidence) ? 0.5 : Math.min(Math.max(qrDetectionConfidence, 0), 1),
          cameraResolution: ['auto', 'hd', 'fullhd', 'low'].includes(cameraResolution) ? cameraResolution : 'auto'
        };

        // Update camera processor settings if exists
        if (this.cameraProcessor) {
          this.cameraProcessor.frameInterval = this.settings.frameInterval;
        }

        this.logger.info('Settings updated: ' + (JSON.stringify(this.settings)));
        this.ui.hideSettingsModal();
      }

      formatFileSize(bytes) {
        if (bytes < 1024) return (bytes) + ' bytes';
        if (bytes < 1024 * 1024) return ((bytes / 1024).toFixed(2)) + ' KB';
        return ((bytes / (1024 * 1024)).toFixed(2)) + ' MB';
      }
    }

    // Initialize when the document is loaded
    document.addEventListener('DOMContentLoaded', () => {
      window.qrFileDecoder = new QRFileDecoder();
    });
  </script>
</body>

</html>
