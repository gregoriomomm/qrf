<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Camera QR Code File Decoder</title><style>:root {
--primary-color: #2563eb;
--secondary-color: #1d4ed8;
--success-color: #10b981;
--warning-color: #f59e0b;
--error-color: #ef4444;
--text-color: #1f2937;
--bg-color: #f9fafb;
--panel-bg: #ffffff;
--border-color: #e5e7eb;
}
* {
box-sizing: border-box;
margin: 0;
padding: 0;
}
body {
font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
line-height: 1.5;
color: var(--text-color);
background-color: var(--bg-color);
padding: 20px;
max-width: 1200px;
margin: 0 auto;
}
h1,
h2 {
margin-bottom: 1rem;
}
button {
background-color: var(--primary-color);
color: white;
border: none;
padding: 8px 16px;
border-radius: 4px;
cursor: pointer;
font-weight: 500;
transition: background-color 0.2s;
}
button:hover {
background-color: var(--secondary-color);
}
button:disabled {
background-color: #9ca3af;
cursor: not-allowed;
}
select {
padding: 8px;
border-radius: 4px;
border: 1px solid var(--border-color);
margin-right: 10px;
}
.control-panel {
display: flex;
justify-content: space-between;
align-items: center;
background-color: var(--panel-bg);
padding: 15px;
border-radius: 8px;
box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
margin-bottom: 20px;
}
.controls {
display: flex;
gap: 10px;
}
.video-container {
position: relative;
background-color: var(--panel-bg);
padding: 15px;
border-radius: 8px;
box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
margin-bottom: 20px;
}
video {
width: 100%;
max-height: 400px;
background-color: #000;
border-radius: 4px;
}
canvas {
position: absolute;
top: 15px;
left: 15px;
pointer-events: none;
}
.progress-container {
margin-top: 10px;
}
.progress-bar {
height: 10px;
background-color: var(--primary-color);
width: 0%;
border-radius: 5px;
transition: width 0.3s ease;
}
.progress-text {
font-size: 14px;
margin-top: 5px;
text-align: right;
}
.chunks-container {
background-color: var(--panel-bg);
padding: 15px;
border-radius: 8px;
box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
margin-bottom: 20px;
}
.chunks-grid {
display: grid;
grid-template-columns: repeat(auto-fill, minmax(20px, 1fr));
gap: 4px;
margin-top: 10px;
}
.chunk {
height: 20px;
background-color: rgba(229, 231, 235, 0.5);
border: 1px solid var(--border-color);
border-radius: 2px;
transition: background-color 0.3s;
}
.chunk.pending {
background-color: rgba(229, 231, 235, 0.5);
}
.chunk.received {
background-color: rgba(16, 185, 129, 0.2);
border-color: var(--success-color);
}
.chunk.blinking {
animation: blink 0.5s;
}
@keyframes blink {
0% {
background-color: rgba(245, 158, 11, 0.5);
}
100% {
background-color: rgba(16, 185, 129, 0.2);
}
}
.file-info-container {
background-color: var(--panel-bg);
padding: 15px;
border-radius: 8px;
box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
margin-bottom: 20px;
}
#downloadContainer {
margin-top: 15px;
}
#downloadBtn {
background-color: var(--success-color);
}
#downloadBtn:hover {
background-color: #0d9668;
}
.debug-container {
background-color: var(--panel-bg);
padding: 15px;
border-radius: 8px;
box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}
.log-controls {
display: flex;
gap: 8px;
margin-bottom: 10px;
}
.log-filter {
background-color: #e5e7eb;
color: var(--text-color);
font-size: 12px;
padding: 4px 8px;
}
.log-filter.active {
background-color: var(--primary-color);
color: white;
}
.log-window {
height: 200px;
overflow-y: auto;
border: 1px solid var(--border-color);
border-radius: 4px;
padding: 10px;
font-family: monospace;
font-size: 13px;
background-color: #f1f5f9;
}
.log-entry {
margin-bottom: 4px;
border-bottom: 1px solid rgba(229, 231, 235, 0.5);
padding-bottom: 4px;
}
.log-debug {
color: #6b7280;
}
.log-info {
color: #1d4ed8;
}
.log-warn {
color: #b45309;
}
.log-error {
color: #b91c1c;
}
.modal {
display: none;
position: fixed;
z-index: 1000;
left: 0;
top: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.5);
}
.modal-content {
background-color: var(--panel-bg);
margin: 10% auto;
padding: 20px;
border-radius: 8px;
max-width: 500px;
box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
position: relative;
}
.close {
position: absolute;
right: 15px;
top: 10px;
font-size: 24px;
cursor: pointer;
}
.settings-group {
margin-bottom: 15px;
}
.settings-group label {
display: block;
margin-bottom: 5px;
}
.settings-group input {
width: 100%;
padding: 8px;
border: 1px solid var(--border-color);
border-radius: 4px;
}
#saveSettingsBtn {
margin-top: 10px;
}
.error-message {
background-color: #fef2f2;
border-left: 4px solid var(--error-color);
padding: 15px;
margin-bottom: 20px;
color: #b91c1c;
display: none;
}
#resetBtn {
background-color: var(--warning-color);
}
#resetBtn:hover {
background-color: #e08c00;
}
.scan-line {
position: absolute;
height: 2px;
background-color: rgba(16, 185, 129, 0.8);
animation: scan-animation 2s infinite;
}
@keyframes scan-animation {
0% {
opacity: 0.5;
}
50% {
opacity: 1;
}
100% {
opacity: 0.5;
}
}
@media (max-width: 768px) {
.control-panel {
flex-direction: column;
align-items: flex-start;
}
.controls {
margin-top: 10px;
width: 100%;
flex-wrap: wrap;
}
video {
max-height: 300px;
}
.chunks-grid {
grid-template-columns: repeat(auto-fill, minmax(15px, 1fr));
}
.chunk {
height: 15px;
}
}</style></head><body><div id="errorMessage" class="error-message"></div><header class="control-panel"><h1>Camera QR Code File Decoder</h1><div class="controls"><select id="cameraSelect"><option value="">Select Camera</option></select><button id="startCameraBtn">Start Camera</button><button id="stopCameraBtn" disabled>Stop Camera</button><button id="resetBtn">Reset Contents</button><button id="settingsBtn">Advanced Settings</button></div></header><div class="video-container"><video id="cameraFeed" autoplay playsinline></video><canvas id="overlayCanvas"></canvas><div class="progress-container"><div class="progress-bar" id="scanProgressBar"></div><div class="progress-text" id="scanProgressText">QR Codes: 0 | Time: 00:00</div></div></div><div class="chunks-container"><h2>Chunk Recovery Progress</h2><div class="chunks-grid" id="chunksGrid"></div></div><div class="file-info-container"><h2>File Information</h2><div id="fileInfo">No file detected yet</div><div id="missingChunks">Waiting for metadata...</div><div id="downloadContainer" style="display: none;"><button id="downloadBtn">Download Recovered File</button></div></div><div class="debug-container"><h2>Debug Log</h2><div class="log-controls"><button class="log-filter active" data-level="all">All</button><button class="log-filter" data-level="debug">Debug</button><button class="log-filter" data-level="info">Info</button><button class="log-filter" data-level="warn">Warnings</button><button class="log-filter" data-level="error">Errors</button><button id="clearLogBtn">Clear Log</button></div><div class="log-window" id="logWindow"></div></div><div id="settingsModal" class="modal"><div class="modal-content"><span class="close">&times;</span><h2>Advanced Settings</h2><div class="settings-group"><label for="workerCount">QR Processing Workers:</label><input type="number" id="workerCount" min="1" max="16" value="4"></div><div class="settings-group"><label for="packetWorkerCount">Packet Processing Workers:</label><input type="number" id="packetWorkerCount" min="1" max="8" value="2"></div><div class="settings-group"><label for="frameInterval">Frame Processing Interval (ms):</label><input type="number" id="frameInterval" min="0" max="1000" value="100"></div><div class="settings-group"><label for="qrDetectionConfidence">QR Detection Confidence (0-1):</label><input type="number" id="qrDetectionConfidence" min="0" max="1" step="0.1" value="0.5"></div><div class="settings-group"><label for="cameraResolution">Camera Resolution:</label><select id="cameraResolution"><option value="auto">Auto (Default)</option><option value="hd">HD (1280x720)</option><option value="fullhd">Full HD (1920x1080)</option><option value="low">Low (640x480)</option></select></div><button id="saveSettingsBtn">Save Settings</button></div></div><script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script><script>let debugMode = false;
document.addEventListener('keydown', (e) => {
if (e.ctrlKey && e.shiftKey && e.key === 'D') {
debugMode = !debugMode;
console.log(`🔧 Debug mode: ${debugMode ? 'ENABLED' : 'DISABLED'}`);
}
});
document.addEventListener('visibilitychange', () => {
if (document.hidden) {
console.warn('⚠️ Tab backgrounded - Camera QR processing may be throttled. Keep tab active for best performance.');
}
});
class Logger {
constructor(logElementId) {
this.logElement = document.getElementById(logElementId);
this.filter = 'all';
this.maxEntries = 500;
this.entries = [];
}
debug(message) {
this.log('debug', message);
}
info(message) {
this.log('info', message);
}
warn(message) {
this.log('warn', message);
}
error(message) {
this.log('error', message);
}
log(level, message) {
const entry = {
timestamp: new Date(),
level,
message
};
this.entries.push(entry);
if (this.entries.length > this.maxEntries) {
this.entries.shift();
}
const entryElement = document.createElement('div');
entryElement.className = `log-entry log-${level}`;
const timestamp = entry.timestamp.toLocaleTimeString();
entryElement.innerHTML = `[${timestamp}] [${level.toUpperCase()}] ${message}`;
if (this.filter !== 'all' && this.filter !== level) {
entryElement.style.display = 'none';
}
this.logElement.appendChild(entryElement);
this.logElement.scrollTop = this.logElement.scrollHeight;
}
clear() {
this.logElement.innerHTML = '';
this.entries = [];
}
setFilter(filter) {
this.filter = filter;
const entries = this.logElement.querySelectorAll('.log-entry');
entries.forEach(entry => {
if (filter === 'all') {
entry.style.display = '';
} else {
const entryLevel = Array.from(entry.classList)
.find(cls => cls.startsWith('log-'))
.replace('log-', '');
entry.style.display = entryLevel === filter ? '' : 'none';
}
});
}
}
class UI {
constructor(logger) {
this.logger = logger;
this.overlayCanvas = document.getElementById('overlayCanvas');
this.overlayCtx = this.overlayCanvas.getContext('2d');
}
resetChunkGrid() {
const chunksGrid = document.getElementById('chunksGrid');
chunksGrid.innerHTML = '';
document.getElementById('scanProgressBar').style.width = '0%';
document.getElementById('scanProgressText').textContent = 'QR Codes: 0 | Time: 00:00';
document.getElementById('downloadContainer').style.display = 'none';
}
initializeChunkGrid(chunksCount) {
const chunksGrid = document.getElementById('chunksGrid');
chunksGrid.innerHTML = '';
for (let i = 0; i < chunksCount; i++) {
const chunkElement = document.createElement('div');
chunkElement.className = 'chunk pending';
chunkElement.dataset.index = i;
chunksGrid.appendChild(chunkElement);
}
}
updateProgress(progress, qrCodesDetected, elapsedTime) {
const progressBar = document.getElementById('scanProgressBar');
progressBar.style.width = `${progress * 100}%`;
const progressText = document.getElementById('scanProgressText');
const minutes = Math.floor(elapsedTime / 60);
const seconds = Math.floor(elapsedTime % 60);
const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
progressText.textContent = `QR Codes: ${qrCodesDetected} | Time: ${timeString}`;
}
updateFileInfo(htmlContent) {
document.getElementById('fileInfo').innerHTML = htmlContent;
}
blinkChunk(chunkIndex) {
const chunkElement = document.querySelector(`.chunk[data-index="${chunkIndex}"]`);
if (chunkElement) {
chunkElement.classList.remove('blinking');
void chunkElement.offsetWidth;
chunkElement.classList.add('blinking');
}
}
markChunkAsRecovered(chunkIndex) {
const chunkElement = document.querySelector(`.chunk[data-index="${chunkIndex}"]`);
if (chunkElement) {
chunkElement.classList.remove('pending');
chunkElement.classList.add('received');
}
}
showSettingsModal() {
document.getElementById('settingsModal').style.display = 'block';
}
hideSettingsModal() {
document.getElementById('settingsModal').style.display = 'none';
}
updateLogFilterButtons(activeButton) {
document.querySelectorAll('.log-filter').forEach(btn => {
btn.classList.remove('active');
});
activeButton.classList.add('active');
}
showErrorMessage(message) {
const errorElement = document.getElementById('errorMessage');
errorElement.textContent = message;
errorElement.style.display = 'block';
}
hideErrorMessage() {
const errorElement = document.getElementById('errorMessage');
errorElement.style.display = 'none';
}
drawQRHighlight(x, y, width, height, padding = 10) {
const video = document.getElementById('cameraFeed');
if (this.overlayCanvas.width !== video.clientWidth ||
this.overlayCanvas.height !== video.clientHeight) {
this.overlayCanvas.width = video.clientWidth;
this.overlayCanvas.height = video.clientHeight;
}
this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
const scaleX = video.clientWidth / video.videoWidth;
const scaleY = video.clientHeight / video.videoHeight;
const verticalOffset = 30;
const scaledX = (x - padding) * scaleX;
const scaledY = (y - padding - verticalOffset) * scaleY;
const scaledSize = Math.max((width + padding * 2) * scaleX, (height + padding * 2) * scaleY);
const scaledWidth = scaledSize;
const scaledHeight = scaledSize;
this.overlayCtx.strokeStyle = '#10b981';
this.overlayCtx.lineWidth = 3;
this.overlayCtx.beginPath();
this.overlayCtx.rect(scaledX, scaledY, scaledWidth, scaledHeight);
this.overlayCtx.stroke();
const scanlineCount = 3;
const scanlineSpacing = scaledHeight / (scanlineCount + 1);
this.overlayCtx.beginPath();
for (let i = 1; i <= scanlineCount; i++) {
const lineY = scaledY + scanlineSpacing * i;
this.overlayCtx.moveTo(scaledX, lineY);
this.overlayCtx.lineTo(scaledX + scaledWidth, lineY);
}
this.overlayCtx.stroke();
const markerSize = 15;
this.overlayCtx.fillStyle = '#10b981';
this.overlayCtx.fillRect(scaledX - markerSize / 2, scaledY - markerSize / 2, markerSize, markerSize);
this.overlayCtx.fillRect(scaledX + scaledWidth - markerSize / 2, scaledY - markerSize / 2, markerSize, markerSize);
this.overlayCtx.fillRect(scaledX - markerSize / 2, scaledY + scaledHeight - markerSize / 2, markerSize, markerSize);
this.overlayCtx.fillRect(scaledX + scaledWidth - markerSize / 2, scaledY + scaledHeight - markerSize / 2, markerSize, markerSize);
}
clearQRHighlight() {
if (this.overlayCtx) {
this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
}
}
}
class PacketProcessor {
constructor() {
}
processQRData(qrData, frameIndex) {
try {
if (qrData.startsWith('M:')) {
return this.processMetadataPacket(qrData, frameIndex);
} else if (qrData.startsWith('D:')) {
return this.processDataPacket(qrData, frameIndex);
} else {
throw new Error(`Unknown packet format: ${qrData.substring(0, 10)}...`);
}
} catch (error) {
return {
success: false,
error: error.message,
frameIndex
};
}
}
processMetadataPacket(metaString, frameIndex) {
const parts = metaString.split(':');
if (parts.length < 10) {
throw new Error(`Invalid metadata packet format: ${metaString.substring(0, 30)}...`);
}
let fileSize = -1;
try {
fileSize = parseInt(parts[4])
} catch (e) {
console.error(`Invalid file size: ${parts[4]}`);
}
const metadata = {
protocolVersion: parts[1],
fileName: this.decodeURIComponentSafe(parts[2]),
fileType: this.decodeURIComponentSafe(parts[3]),
fileSize: fileSize,
chunksCount: parseInt(parts[5]),
packetCount: parseInt(parts[6]),
maxDegree: parseInt(parts[7]),
density: parseFloat(parts[8]),
fps: parts[9],
chunkSize: parseInt(parts[10] || '1024'),
redundancy: parseInt(parts[11] || '0'),
ecl: parts[12] || 'L',
checksum: parts[13] || '',
ltParams: parts.slice(14).join(':')
};
if (isNaN(metadata.fileSize) || metadata.fileSize <= 0) {
metadata.fileSize = -1;
console.error(`Invalid file size: ${parts[4]}`);
}
if (isNaN(metadata.chunksCount) || metadata.chunksCount <= 0) {
throw new Error(`Invalid chunk count: ${parts[5]}`);
}
return {
success: true,
packetType: 'metadata',
packetData: metadata,
frameIndex
};
}
processDataPacket(dataString, frameIndex) {
const parts = dataString.split(':');
if (parts.length < 7) {
throw new Error(`Invalid data packet format: ${dataString.substring(0, 30)}...`);
}
const packetId = parseInt(parts[1]);
const seed = parseInt(parts[2]);
const seedBase = parseInt(parts[3]);
const numChunks = parseInt(parts[4]);
const chunkCount = parseInt(parts[5]);
let sourceChunks = [];
let systematicDataChunks = [];
let fountainData = null;
let format = "standard";
const allDataPart = parts.slice(6).join(':');
if (parts[6] && parts[6].includes(',')) {
const sourceIndices = parts[6].split(',').map(idx => parseInt(idx));
const actualDegree = sourceIndices.length;
if (debugMode) {
console.debug(`Fountain packet ${packetId} with degree=${actualDegree} (XOR of ${sourceIndices.join(',')})`);
}
format = "enhanced";
sourceChunks = sourceIndices;
try {
fountainData = this.base64ToUint8Array(parts[7]);
} catch (e) {
console.error(`Failed to decode fountain XOR data: ${e.message}`);
throw e;
}
} else {
if (debugMode) {
console.debug(`Systematic packet ${packetId} with chunkCount=${chunkCount}`);
}
const records = allDataPart.split('|');
if (debugMode) {
console.debug(`Processing ${records.length} systematic records (expected: ${chunkCount})`);
}
for (let i = 0; i < records.length; i++) {
const record = records[i];
const chunkParts = record.split(':', 2);
if (chunkParts.length === 2) {
const chunkIndex = parseInt(chunkParts[0]);
const chunkData = chunkParts[1];
if (chunkIndex >= 0 && chunkIndex < numChunks) {
sourceChunks.push(chunkIndex);
systematicDataChunks.push({ chunkIndex: chunkIndex, chunkData: chunkData });
if (debugMode) {
console.debug(` Record ${i+1}: chunk ${chunkIndex} (${chunkData.length} base64 chars)`);
}
} else {
console.warn(` Invalid chunk index ${chunkIndex} in record ${i+1}`);
}
} else {
console.warn(` Invalid record format: ${record}`);
}
}
}
if (parts.length >= 8) {
format = "enhanced";
try {
sourceChunks = parts[6].split(',').map(idx => parseInt(idx));
fountainData = this.base64ToUint8Array(parts[7]);
console.debug(`Enhanced fountain packet ${packetId} with degree ${degree}, explicit source chunks: ${sourceChunks.join(',')}`);
} catch (e) {
console.error(`Error parsing enhanced fountain packet: ${e.message}, falling back to legacy mode`);
format = "legacy";
}
}
if (format !== "enhanced") {
const rng = this.createPRNG(seed);
sourceChunks = this.selectChunksLT(rng, degree, numChunks);
const allDataPart = parts.slice(6).join(':');
if (allDataPart.includes('|')) {
const chunksData = allDataPart.split('|');
const chunkContentArray = [];
for (let i = 0; i < chunksData.length; i++) {
const chunkParts = chunksData[i].split(':', 2);
if (chunkParts.length === 2) {
const chunkData = chunkParts[1];
chunkContentArray.push(this.stringToUint8Array(chunkData));
}
}
if (chunkContentArray.length > 0) {
fountainData = chunkContentArray[0];
for (let i = 1; i < chunkContentArray.length; i++) {
this.xorUint8Arrays(fountainData, chunkContentArray[i]);
}
}
} else {
fountainData = this.stringToUint8Array(allDataPart);
}
console.debug(`Legacy fountain packet ${packetId} with degree ${degree}, generated source chunks: ${sourceChunks.join(',')}`);
}
}
this.xorUint8Arrays = function(target, source) {
const minLength = Math.min(target.length, source.length);
for (let i = 0; i < minLength; i++) {
target[i] ^= source[i];
}
};
this.base64ToUint8Array = function(base64) {
try {
const binaryString = atob(base64);
const bytes = new Uint8Array(binaryString.length);
for (let i = 0; i < binaryString.length; i++) {
bytes[i] = binaryString.charCodeAt(i);
}
return bytes;
} catch (e) {
console.error("Error decoding base64:", e);
return new Uint8Array(0);
}
};
let isTruncated = false;
let originalLength = 0;
if (format !== "enhanced" && format !== "legacy") {
const allDataPart = parts.slice(6).join(':');
const truncatedIndex = allDataPart.indexOf(':t:');
if (truncatedIndex > 0) {
isTruncated = true;
const truncatedParts = allDataPart.substring(truncatedIndex + 3).split(':');
originalLength = parseInt(truncatedParts[0] || '0');
}
}
return {
success: true,
packetType: 'data',
packetData: {
packetId,
seed,
seedBase,
degree,
fountainData,
systematicDataChunks,
sourceChunks,
isDegreeOne: degree === 1,
isTruncated,
originalLength,
format
},
frameIndex
};
}
decodeURIComponentSafe(str) {
try {
return decodeURIComponent(str);
} catch (e) {
return str;
}
}
createPRNG(seed) {
let s = seed;
return function () {
s = Math.sin(s) * 10000;
return s - Math.floor(s);
};
}
selectChunksLT(rng, degree, numChunks) {
const indices = [];
const actualDegree = Math.min(degree, numChunks);
while (indices.length < actualDegree) {
const index = Math.floor(rng() * numChunks);
if (!indices.includes(index)) {
indices.push(index);
}
}
return indices;
}
stringToUint8Array(str) {
const arr = new Uint8Array(str.length);
for (let i = 0; i < str.length; i++) {
arr[i] = str.charCodeAt(i);
}
return arr;
}
}
class EnhancedFountainDecoder {
constructor() {
this.initialized = false;
this.metaData = null;
this.totalChunks = 0;
this.sourceChunks = {};
this.recoveredChunkCount = 0;
this.codedPackets = [];
this.completeCallback = null;
this.newlyRecoveredChunks = [];
this.lastProcessedChunk = -1;
this.packetStats = {
total: 0,
degree1: 0,
degreeN: 0,
usefulPackets: 0
};
}
initialize(metadata) {
this.metaData = metadata;
this.totalChunks = metadata.chunksCount;
this.initialized = true;
this.sourceChunks = {};
this.recoveredChunkCount = 0;
this.codedPackets = [];
this.newlyRecoveredChunks = [];
this.packetStats = {
total: 0,
degree1: 0,
degreeN: 0,
usefulPackets: 0
};
console.log(`Fountain decoder initialized with ${metadata.chunksCount} chunks, file size: ${metadata.fileSize} bytes`);
}
setCompleteCallback(callback) {
this.completeCallback = callback;
}
addPacket(packet) {
if (!this.initialized) {
throw new Error("Fountain decoder not initialized");
}
this.packetStats.total++;
if (packet.isDegreeOne) {
this.packetStats.degree1++;
let anyNewChunks = false;
packet.systematicDataChunks.forEach(chunk => {
const chunkIndex = chunk.chunkIndex;
if (!this.sourceChunks[chunkIndex]) {
const chunkData = this.stringToUint8Array(chunk.chunkData);
this.storeSourceChunk(chunkIndex, chunkData);
this.newlyRecoveredChunks.push(chunkIndex);
anyNewChunks = true;
}
});
if (anyNewChunks) {
this.packetStats.usefulPackets++;
this.propagateAndDecode();
return true;
}
return false;
}
this.packetStats.degreeN++;
const missingChunks = packet.sourceChunks.filter(
chunkIndex => !this.sourceChunks[chunkIndex]
);
if (missingChunks.length === 0) {
if (this.recoveredChunkCount === this.totalChunks) {
console.log("All chunks recovered! Finalizing file...");
this.finalizeFile();
}
return false;
}
if (missingChunks.length === 1) {
const missingChunkIndex = missingChunks[0];
const resultData = new Uint8Array(packet.fountainData.length);
resultData.set(packet.fountainData);
for (const chunkIndex of packet.sourceChunks) {
if (chunkIndex !== missingChunkIndex && this.sourceChunks[chunkIndex]) {
this.xorData(resultData, this.sourceChunks[chunkIndex]);
}
}
this.storeSourceChunk(missingChunkIndex, resultData);
this.newlyRecoveredChunks.push(missingChunkIndex);
this.packetStats.usefulPackets++;
this.propagateAndDecode();
return true;
}
this.codedPackets.push(packet);
return true;
}
propagateAndDecode() {
let progress = true;
while (progress) {
progress = false;
for (let i = this.codedPackets.length - 1; i >= 0; i--) {
const packet = this.codedPackets[i];
const missingChunks = packet.sourceChunks.filter(
chunkIndex => !this.sourceChunks[chunkIndex]
);
if (missingChunks.length === 0) {
this.codedPackets.splice(i, 1);
continue;
}
if (missingChunks.length === 1) {
const missingChunkIndex = missingChunks[0];
const resultData = new Uint8Array(packet.fountainData.length);
resultData.set(packet.fountainData);
for (const chunkIndex of packet.sourceChunks) {
if (chunkIndex !== missingChunkIndex && this.sourceChunks[chunkIndex]) {
this.xorData(resultData, this.sourceChunks[chunkIndex]);
}
}
this.storeSourceChunk(missingChunkIndex, resultData);
this.newlyRecoveredChunks.push(missingChunkIndex);
this.packetStats.usefulPackets++;
this.codedPackets.splice(i, 1);
progress = true;
}
}
}
if (this.recoveredChunkCount === this.totalChunks) {
console.log("All chunks recovered! Finalizing file...");
this.finalizeFile();
}
}
storeSourceChunk(index, data) {
if (!this.sourceChunks[index]) {
if (!(data instanceof Uint8Array)) {
console.warn(`Chunk ${index} data is not a Uint8Array. Converting...`);
data = this.ensureUint8Array(data);
}
this.sourceChunks[index] = data;
this.recoveredChunkCount++;
console.debug(`Stored chunk ${index}, now have ${this.recoveredChunkCount}/${this.totalChunks} chunks`);
if (index > this.lastProcessedChunk) {
this.lastProcessedChunk = index;
}
}
}
ensureUint8Array(data) {
if (data instanceof Uint8Array) {
return data;
}
if (typeof data === 'string') {
return this.stringToUint8Array(data);
}
if (Array.isArray(data) || ArrayBuffer.isView(data)) {
return new Uint8Array(data);
}
console.error("Unknown data type, cannot convert to Uint8Array:", typeof data);
return new Uint8Array(0);
}
stringToUint8Array(str) {
const arr = new Uint8Array(str.length);
for (let i = 0; i < str.length; i++) {
arr[i] = str.charCodeAt(i);
}
return arr;
}
xorData(target, source) {
const minLength = Math.min(target.length, source.length);
for (let i = 0; i < minLength; i++) {
target[i] ^= source[i];
}
}
base64ToUint8Array(base64) {
try {
const binaryString = atob(base64);
const bytes = new Uint8Array(binaryString.length);
for (let i = 0; i < binaryString.length; i++) {
bytes[i] = binaryString.charCodeAt(i);
}
return bytes;
} catch (e) {
throw new Error(`Base64 decode failed: ${e.message}`);
}
}
getNewlyRecoveredChunks() {
const chunks = [...this.newlyRecoveredChunks];
this.newlyRecoveredChunks = [];
return chunks;
}
getRecoveryProgress() {
return {
recovered: this.recoveredChunkCount,
total: this.totalChunks,
percentage: Math.round((this.recoveredChunkCount / this.totalChunks) * 100),
packetStats: this.packetStats
};
}
finalizeFile() {
console.log("Finalizing file reconstruction...");
console.log(`Recovery stats: ${this.recoveredChunkCount}/${this.totalChunks} chunks`);
console.log(`Packet stats: ${JSON.stringify(this.packetStats)}`);
try {
for (let i = 0; i < this.totalChunks; i++) {
if (!this.sourceChunks[i]) {
console.error(`Missing chunk ${i} during file reconstruction, cannot finalize`);
return;
}
}
let fileSize = this.metaData.fileSize;
if (isNaN(fileSize) || fileSize <= 0) {
fileSize = 0;
for (let i = 0; i < this.totalChunks; i++) {
fileSize += this.sourceChunks[i].length;
}
console.log(`File size not provided in metadata, calculated: ${fileSize} bytes`);
}
let fileData = new Uint8Array(fileSize);
let offset = 0;
const chunkSize = this.metaData.chunkSize || this.sourceChunks[0].length;
console.log(`Using chunk size: ${chunkSize} bytes`);
for (let i = 0; i < this.totalChunks; i++) {
const chunk = this.sourceChunks[i];
if (!chunk) {
console.error(`Chunk ${i} is missing`);
continue;
}
if (!(chunk instanceof Uint8Array)) {
console.error(`Chunk ${i} is not a Uint8Array: ${typeof chunk}`);
continue;
}
const bytesToCopy = Math.min(chunk.length, fileData.length - offset);
try {
fileData.set(chunk.subarray(0, bytesToCopy), offset);
offset += bytesToCopy;
} catch (e) {
console.error(`Error copying chunk ${i}:`, e);
console.error(`Chunk length: ${chunk.length}, bytesToCopy: ${bytesToCopy}, offset: ${offset}, fileData.length: ${fileData.length}`);
throw e;
}
if (offset >= fileData.length) {
break;
}
}
console.log(`File reconstruction complete. Total size: ${fileData.length} bytes`);
try {
console.log("Decoding base64 data...");
const base64String = this.arrayBufferToString(fileData);
fileData = this.base64ToArrayBuffer(base64String);
console.log(`Base64 decoded size: ${fileData.length} bytes`);
} catch (e) {
console.error("Error decoding base64:", e);
}
if (this.completeCallback) {
this.completeCallback(fileData);
}
} catch (error) {
console.error("Error finalizing file:", error);
}
}
arrayBufferToString(buffer) {
const decoder = new TextDecoder('utf-8');
return decoder.decode(buffer);
}
base64ToArrayBuffer(base64) {
try {
const binary = atob(base64);
const bytes = new Uint8Array(binary.length);
for (let i = 0; i < binary.length; i++) {
bytes[i] = binary.charCodeAt(i);
}
return bytes;
} catch (e) {
console.error("Base64 decoding error:", e);
throw e;
}
}
}
class EnhancedQRProcessor {
constructor(options) {
this.onQrDetected = options.onQrDetected;
this.onError = options.onError;
this.detectionConfidence = options.detectionConfidence || 0.5;
this.canvas = document.createElement('canvas');
this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
this.detectionStats = {
attempts: 0,
successes: 0,
failures: 0,
lastDetectedFrameIndex: -1,
duplicates: 0
};
this.recentlySeenQRs = new Map();
this.maxCacheSize = 50;
this.qrElement = document.createElement('div');
this.qrElement.id = 'qr-reader-hidden';
this.qrElement.style.display = 'none';
document.body.appendChild(this.qrElement);
}
async initialize() {
try {
this.html5QrCode = new Html5Qrcode('qr-reader-hidden', {
formatsToSupport: [
Html5QrcodeSupportedFormats.QR_CODE,
Html5QrcodeSupportedFormats.DATA_MATRIX,
Html5QrcodeSupportedFormats.CODE_39,
Html5QrcodeSupportedFormats.CODE_93,
Html5QrcodeSupportedFormats.CODE_128,
Html5QrcodeSupportedFormats.EAN_8,
Html5QrcodeSupportedFormats.EAN_13,
Html5QrcodeSupportedFormats.ITF,
Html5QrcodeSupportedFormats.UPC_A,
Html5QrcodeSupportedFormats.UPC_E
]
});
this.isReady = true;
console.log("QR processor initialized successfully");
return true;
} catch (error) {
if (this.onError) {
this.onError(error);
}
console.error("Failed to initialize HTML5QRCode", error);
throw error;
}
}
processFrame(imageData, frameIndex) {
if (!this.isReady) {
throw new Error("QR processor not initialized");
}
this.detectionStats.attempts++;
return new Promise((resolve, reject) => {
try {
if (this.canvas.width !== imageData.width || this.canvas.height !== imageData.height) {
this.canvas.width = imageData.width;
this.canvas.height = imageData.height;
}
this.ctx.putImageData(imageData, 0, 0);
const dataUrl = this.canvas.toDataURL('image/jpeg');
this.html5QrCode.scanFile(
this.dataURLtoFile(dataUrl, 'frame.jpg'),
false,
undefined)
.then(decodedText => {
this.detectionStats.successes++;
const isDuplicate = this.checkDuplicate(decodedText, frameIndex);
if (isDuplicate) {
this.detectionStats.duplicates++;
resolve({
success: false,
isDuplicate: true,
frameIndex: frameIndex
});
} else {
this.addToRecentlySeen(decodedText, frameIndex);
this.detectionStats.lastDetectedFrameIndex = frameIndex;
if (this.detectionStats.successes % 10 === 0) {
console.log(`QR detection stats: ${this.detectionStats.successes}/${this.detectionStats.attempts} successful (${this.detectionStats.duplicates} duplicates)`);
}
const lastResult = this.html5QrCode._lastScanResult || null;
resolve({
success: true,
qrData: decodedText,
frameIndex: frameIndex,
bounds: this.estimateBounds({
result: lastResult,
imageData: imageData
})
});
}
})
.catch(error => {
this.detectionStats.failures++;
resolve({
success: false,
frameIndex: frameIndex
});
});
} catch (error) {
this.detectionStats.failures++;
if (this.onError) {
this.onError(error);
}
resolve({
success: false,
frameIndex: frameIndex
});
}
});
}
checkDuplicate(qrData, frameIndex) {
if (this.recentlySeenQRs.has(qrData)) {
const lastSeenFrame = this.recentlySeenQRs.get(qrData);
return (frameIndex - lastSeenFrame) < 5;
}
return false;
}
addToRecentlySeen(qrData, frameIndex) {
this.recentlySeenQRs.set(qrData, frameIndex);
if (this.recentlySeenQRs.size > this.maxCacheSize) {
const entries = Array.from(this.recentlySeenQRs.entries());
entries.sort((a, b) => a[1] - b[1]);
const entriesToRemove = Math.ceil(this.maxCacheSize * 0.2);
for (let i = 0; i < entriesToRemove; i++) {
if (entries[i]) {
this.recentlySeenQRs.delete(entries[i][0]);
}
}
}
}
estimateBounds(decodedResult) {
if (decodedResult && decodedResult.result && decodedResult.result.location) {
const loc = decodedResult.result.location;
const xValues = [loc.topLeft.x, loc.topRight.x, loc.bottomLeft.x, loc.bottomRight.x];
const yValues = [loc.topLeft.y, loc.topRight.y, loc.bottomLeft.y, loc.bottomRight.y];
const minX = Math.min(...xValues);
const maxX = Math.max(...xValues);
const minY = Math.min(...yValues);
const maxY = Math.max(...yValues);
const width = maxX - minX;
const height = maxY - minY;
const size = Math.max(width, height);
const centerX = (minX + maxX) / 2;
const centerY = (minY + maxY) / 2;
return {
x: centerX - size / 2,
y: centerY - size / 2,
width: size,
height: size
};
}
const imageData = decodedResult.imageData || {
width: 300,
height: 300
};
const centerX = imageData.width / 2;
const centerY = imageData.height / 2;
const size = Math.min(imageData.width, imageData.height) / 2.5;
return {
x: centerX - size / 2,
y: 0,
width: size,
height: size
};
}
dataURLtoFile(dataurl, filename) {
const arr = dataurl.split(',');
const mime = arr[0].match(/:(.*?);/)[1];
const bstr = atob(arr[1]);
let n = bstr.length;
const u8arr = new Uint8Array(n);
while (n--) {
u8arr[n] = bstr.charCodeAt(n);
}
return new File([u8arr], filename, { type: mime });
}
dispose() {
if (this.html5QrCode) {
try {
this.html5QrCode.clear();
} catch (error) {
console.error("Error clearing HTML5QRCode", error);
}
}
if (this.qrElement && this.qrElement.parentNode) {
this.qrElement.parentNode.removeChild(this.qrElement);
}
console.log(`QR processor disposed. Final stats: ${JSON.stringify(this.detectionStats)}`);
}
}
class CameraProcessor {
constructor(options) {
this.frameCallback = options.frameCallback;
this.progressCallback = options.progressCallback;
this.errorCallback = options.errorCallback;
this.frameInterval = options.frameInterval || 100;
this.videoElement = document.getElementById('cameraFeed');
this.isProcessing = false;
this.processTimer = null;
this.currentStream = null;
this.cameraSelect = document.getElementById('cameraSelect');
this.canvas = document.createElement('canvas');
this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
this.frameStats = {
processed: 0,
qrCodesDetected: 0,
processingTimes: []
};
this.startTime = 0;
this.currentFrame = 0;
}
async listCameras() {
try {
const devices = await navigator.mediaDevices.enumerateDevices();
const videoDevices = devices.filter(device => device.kind === 'videoinput');
while (this.cameraSelect.firstChild) {
this.cameraSelect.removeChild(this.cameraSelect.firstChild);
}
const defaultOption = document.createElement('option');
defaultOption.value = '';
defaultOption.textContent = 'Select Camera';
this.cameraSelect.appendChild(defaultOption);
videoDevices.forEach((device, index) => {
const option = document.createElement('option');
option.value = device.deviceId;
option.textContent = device.label || `Camera ${index + 1}`;
this.cameraSelect.appendChild(option);
});
if (videoDevices.length === 1) {
this.cameraSelect.value = videoDevices[0].deviceId;
}
return videoDevices.length > 0;
} catch (error) {
console.error('Error listing cameras:', error);
if (this.errorCallback) {
this.errorCallback(error);
}
return false;
}
}
async initialize(deviceId = null, resolution = 'auto') {
try {
if (this.currentStream) {
this.stopCamera();
}
const constraints = {
video: {
facingMode: 'environment',
},
audio: false
};
if (deviceId) {
constraints.video.deviceId = { exact: deviceId };
}
if (resolution === 'hd') {
constraints.video.width = { ideal: 1280 };
constraints.video.height = { ideal: 720 };
} else if (resolution === 'fullhd') {
constraints.video.width = { ideal: 1920 };
constraints.video.height = { ideal: 1080 };
} else if (resolution === 'low') {
constraints.video.width = { ideal: 640 };
constraints.video.height = { ideal: 480 };
}
const stream = await navigator.mediaDevices.getUserMedia(constraints);
this.currentStream = stream;
this.videoElement.srcObject = stream;
await new Promise(resolve => {
this.videoElement.onloadedmetadata = () => {
this.videoElement.play();
resolve();
};
});
this.canvas.width = this.videoElement.videoWidth;
this.canvas.height = this.videoElement.videoHeight;
console.log(`Camera initialized: ${this.videoElement.videoWidth}x${this.videoElement.videoHeight}`);
return true;
} catch (error) {
console.error('Error initializing camera:', error);
if (this.errorCallback) {
this.errorCallback(error);
}
return false;
}
}
startProcessing() {
if (this.isProcessing) return;
this.isProcessing = true;
this.startTime = performance.now();
this.currentFrame = 0;
this.frameStats = {
processed: 0,
qrCodesDetected: 0,
processingTimes: []
};
if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
this.processWithVideoFrameCallback();
} else {
this.processTimer = setInterval(() => {
this.processCurrentFrame();
}, this.frameInterval);
}
console.log(`Camera processing started with frame interval: ${this.frameInterval}ms`);
}
processWithVideoFrameCallback() {
const processFrame = (now, metadata) => {
if (!this.isProcessing) return;
this.processCurrentFrame();
if (this.isProcessing && this.videoElement.readyState === this.videoElement.HAVE_ENOUGH_DATA) {
this.videoElement.requestVideoFrameCallback(processFrame);
}
};
this.videoElement.requestVideoFrameCallback(processFrame);
}
processCurrentFrame() {
if (!this.isProcessing || !this.videoElement.readyState === this.videoElement.HAVE_ENOUGH_DATA) return;
const processingStart = performance.now();
try {
this.currentFrame++;
this.frameStats.processed++;
this.ctx.drawImage(this.videoElement, 0, 0, this.canvas.width, this.canvas.height);
const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
const elapsedTime = (performance.now() - this.startTime) / 1000;
const progress = 0;
if (this.progressCallback) {
this.progressCallback(progress, this.frameStats.qrCodesDetected, elapsedTime);
}
if (this.frameCallback) {
this.frameCallback(imageData, elapsedTime, this.currentFrame);
}
const processingTime = performance.now() - processingStart;
this.frameStats.processingTimes.push(processingTime);
if (this.frameStats.processed % 30 === 0) {
const avgTime = this.frameStats.processingTimes.reduce((sum, time) => sum + time, 0) /
this.frameStats.processingTimes.length;
console.log(`Avg frame processing time: ${avgTime.toFixed(2)}ms over last ${this.frameStats.processingTimes.length} frames`);
this.frameStats.processingTimes = [];
if (avgTime > this.frameInterval * 1.5) {
const newInterval = Math.min(Math.ceil(avgTime * 1.2), 200);
console.log(`Adjusting frame interval from ${this.frameInterval}ms to ${newInterval}ms due to performance`);
this.frameInterval = newInterval;
if (this.processTimer) {
clearInterval(this.processTimer);
this.processTimer = setInterval(() => {
this.processCurrentFrame();
}, this.frameInterval);
}
}
}
} catch (error) {
console.error('Error processing frame:', error);
if (this.errorCallback) {
this.errorCallback(error);
}
}
}
stopProcessing() {
this.isProcessing = false;
if (this.processTimer) {
clearInterval(this.processTimer);
this.processTimer = null;
}
console.log(`Camera processing stopped. Processed ${this.frameStats.processed} frames, detected ${this.frameStats.qrCodesDetected} QR codes`);
}
stopCamera() {
this.stopProcessing();
if (this.currentStream) {
this.currentStream.getTracks().forEach(track => track.stop());
this.currentStream = null;
}
this.videoElement.srcObject = null;
console.log('Camera stopped');
}
}
class QRFileDecoder {
constructor() {
this.logger = new Logger('logWindow');
this.ui = new UI(this.logger);
this.cameraProcessor = null;
this.qrProcessor = null;
this.packetProcessor = null;
this.fountainDecoder = null;
this.isProcessing = false;
this.metadataReceived = false;
this.fileMetadata = null;
this.recoveredChunks = new Map();
this.missingChunks = new Set();
this.settings = {
workerCount: 4,
packetWorkerCount: 2,
frameInterval: 100,
qrDetectionConfidence: 0.5,
cameraResolution: 'auto'
};
this.qrCodesDetected = 0;
this.packetsProcessed = 0;
this.recoveredFileData = null;
this.checkCompatibility();
this.initEventListeners();
this.logger.info("Camera-based QR File Decoder initialized");
this.initializeCameraList();
}
async initializeCameraList() {
try {
if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
throw new Error("Camera access not supported in this browser");
}
let devices = [];
try {
devices = await navigator.mediaDevices.enumerateDevices();
} catch (enumError) {
console.warn("Failed to enumerate devices:", enumError);
}
let hasPermission = false;
try {
const permissions = await navigator.permissions.query({ name: 'camera' });
hasPermission = permissions.state === 'granted';
} catch (permError) {
console.warn("Failed to check camera permission:", permError);
}
if (!hasPermission) {
try {
const stream = await navigator.mediaDevices.getUserMedia({
video: {
width: { ideal: 320 },
height: { ideal: 240 }
}
});
stream.getTracks().forEach(track => track.stop());
} catch (permissionError) {
if (permissionError.name === 'NotAllowedError') {
throw new Error("Camera permission denied. Please allow camera access and refresh the page.");
} else if (permissionError.name === 'NotFoundError') {
throw new Error("No camera found. Please connect a camera and refresh the page.");
} else if (permissionError.name === 'NotReadableError') {
throw new Error("Camera is in use by another application. Please close other apps using the camera.");
} else {
throw new Error(`Camera access failed: ${permissionError.message}`);
}
}
}
if (this.cameraProcessor) {
const success = await this.cameraProcessor.listCameras();
if (!success) {
throw new Error("Failed to list available cameras");
}
} else {
this.cameraProcessor = new CameraProcessor({
frameCallback: this.handleVideoFrame.bind(this),
progressCallback: this.handleProgress.bind(this),
errorCallback: (error) => this.logger.error(`Camera error: ${error.message}`)
});
const success = await this.cameraProcessor.listCameras();
if (!success) {
throw new Error("Failed to list available cameras");
}
}
const cameraSelect = document.getElementById('cameraSelect');
if (cameraSelect.options.length <= 1) {
throw new Error("No cameras available. Please connect a camera and refresh the page.");
}
this.logger.info(`Camera list initialized successfully with ${cameraSelect.options.length - 1} camera(s)`);
} catch (error) {
this.logger.error(`Failed to initialize camera list: ${error.message}`);
this.ui.showErrorMessage(error.message);
document.getElementById('startCameraBtn').disabled = true;
document.getElementById('cameraSelect').disabled = true;
}
}
checkCompatibility() {
if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
this.ui.showErrorMessage("Camera access is not supported in your browser. Please use a modern browser with camera support.");
document.getElementById('startCameraBtn').disabled = true;
}
if (typeof Html5Qrcode === 'undefined') {
this.ui.showErrorMessage("HTML5QRCode library is not available. Please check your internet connection and reload the page.");
document.getElementById('startCameraBtn').disabled = true;
}
}
resetContents() {
if (this.isProcessing) {
this.stopProcessing();
}
this.metadataReceived = false;
this.fileMetadata = null;
this.recoveredChunks = new Map();
this.missingChunks = new Set();
this.qrCodesDetected = 0;
this.packetsProcessed = 0;
this.recoveredFileData = null;
this.ui.resetChunkGrid();
this.ui.updateFileInfo("No file detected yet");
document.getElementById('missingChunks').textContent = "Waiting for metadata...";
document.getElementById('scanProgressBar').style.width = '0%';
document.getElementById('scanProgressText').textContent = 'QR Codes: 0 | Time: 00:00';
document.getElementById('downloadContainer').style.display = 'none';
this.ui.clearQRHighlight();
this.ui.hideErrorMessage();
this.logger.info("Contents reset, ready for new scan");
}
initEventListeners() {
document.getElementById('startCameraBtn').addEventListener('click', this.startCamera.bind(this));
document.getElementById('stopCameraBtn').addEventListener('click', this.stopCamera.bind(this));
document.getElementById('resetBtn').addEventListener('click', this.resetContents.bind(this));
document.getElementById('downloadBtn').addEventListener('click', this.downloadFile.bind(this));
document.getElementById('settingsBtn').addEventListener('click', this.ui.showSettingsModal.bind(this.ui));
document.getElementById('saveSettingsBtn').addEventListener('click', this.saveSettings.bind(this));
document.getElementById('clearLogBtn').addEventListener('click', this.logger.clear.bind(this.logger));
document.querySelectorAll('.log-filter').forEach(btn => {
btn.addEventListener('click', (e) => {
this.logger.setFilter(e.target.dataset.level);
this.ui.updateLogFilterButtons(e.target);
});
});
document.querySelector('.modal .close').addEventListener('click', this.ui.hideSettingsModal.bind(this.ui));
}
async startCamera() {
if (this.isProcessing) {
this.logger.warn("Processing already in progress");
return;
}
const cameraSelect = document.getElementById('cameraSelect');
const selectedCamera = cameraSelect.value;
if (cameraSelect.disabled) {
this.logger.error("No cameras available. Please check camera connection and refresh the page.");
this.ui.showErrorMessage("No cameras available. Please check camera connection and refresh the page.");
return;
}
if (!selectedCamera && cameraSelect.options.length > 1) {
this.logger.warn("Please select a camera from the dropdown");
this.ui.showErrorMessage("Please select a camera from the dropdown");
return;
}
this.isProcessing = true;
document.getElementById('startCameraBtn').disabled = true;
document.getElementById('stopCameraBtn').disabled = false;
document.getElementById('downloadContainer').style.display = 'none';
this.ui.resetChunkGrid();
this.ui.updateFileInfo("Initializing camera...");
this.ui.clearQRHighlight();
this.ui.hideErrorMessage();
try {
await this.initializeComponents();
const success = await this.cameraProcessor.initialize(
selectedCamera,
this.settings.cameraResolution
);
if (success) {
this.cameraProcessor.startProcessing();
this.ui.updateFileInfo("Camera active. Point at QR codes to scan...");
this.logger.info("Camera processing started");
} else {
throw new Error("Failed to initialize camera");
}
} catch (error) {
this.logger.error(`Failed to start camera: ${error.message}`);
this.ui.showErrorMessage(`Failed to start camera: ${error.message}`);
this.stopCamera();
}
}
async initializeComponents() {
if (!this.cameraProcessor) {
this.cameraProcessor = new CameraProcessor({
frameCallback: this.handleVideoFrame.bind(this),
progressCallback: this.handleProgress.bind(this),
errorCallback: (error) => this.logger.error(`Camera error: ${error.message}`),
frameInterval: this.settings.frameInterval
});
} else {
this.cameraProcessor.frameInterval = this.settings.frameInterval;
}
this.qrProcessor = new EnhancedQRProcessor({
onQrDetected: this.handleQRCodeResult.bind(this),
onError: (error) => this.logger.error(`QR processing error: ${error.message}`),
detectionConfidence: this.settings.qrDetectionConfidence
});
await this.qrProcessor.initialize();
this.packetProcessor = new PacketProcessor();
this.fountainDecoder = new EnhancedFountainDecoder();
this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this));
}
stopCamera() {
if (!this.isProcessing) return;
this.isProcessing = false;
if (this.cameraProcessor) {
this.cameraProcessor.stopCamera();
}
if (this.qrProcessor) {
this.qrProcessor.dispose();
}
this.ui.clearQRHighlight();
document.getElementById('startCameraBtn').disabled = false;
document.getElementById('stopCameraBtn').disabled = true;
this.logger.info("Camera processing stopped");
this.logger.info(`Processing summary: Detected ${this.qrCodesDetected} QR codes, processed ${this.packetsProcessed} packets`);
if (this.metadataReceived) {
const progress = this.fountainDecoder.getRecoveryProgress();
this.logger.info(`File recovery progress: ${progress.recovered}/${progress.total} chunks (${progress.percentage}%)`);
if (progress.packetStats) {
this.logger.info(`Packet statistics: ${JSON.stringify(progress.packetStats)}`);
}
}
}
stopProcessing() {
this.stopCamera();
}
handleProgress(progress, qrCodesDetected, elapsedTime) {
if (this.metadataReceived && this.fileMetadata) {
const recoveredChunks = this.fountainDecoder.getRecoveryProgress().recovered;
const totalChunks = this.fileMetadata.chunksCount;
progress = recoveredChunks / totalChunks;
}
this.ui.updateProgress(progress, qrCodesDetected, elapsedTime);
}
async handleVideoFrame(imageData, timestamp, frameIndex) {
if (!this.isProcessing) return;
try {
const result = await this.qrProcessor.processFrame(imageData, frameIndex);
if (result.success) {
this.qrCodesDetected++;
if (this.cameraProcessor) {
this.cameraProcessor.frameStats.qrCodesDetected++;
}
if (result.bounds) {
this.ui.drawQRHighlight(
result.bounds.x,
result.bounds.y,
result.bounds.width,
result.bounds.height
);
this.logger.info(`QR code detected in frame ${frameIndex} at position [${result.bounds.x.toFixed(0)}, ${result.bounds.y.toFixed(0)}]`);
} else {
this.logger.info(`QR code detected in frame ${frameIndex}`);
}
this.handleQRCodeResult(result);
} else if (result.isDuplicate) {
} else {
this.ui.clearQRHighlight();
}
} catch (error) {
this.logger.error(`Error processing frame ${frameIndex}: ${error.message}`);
}
}
handleQRCodeResult(result) {
if (!result.success) {
return;
}
const { qrData, frameIndex } = result;
this.logger.debug(`QR code detected in frame ${frameIndex}: ${qrData.substring(0, 30)}...`);
const packetResult = this.packetProcessor.processQRData(qrData, frameIndex);
if (packetResult.success) {
this.handlePacketResult(packetResult);
} else {
this.logger.warn(`Failed to process QR data: ${packetResult.error}`);
}
}
handlePacketResult(result) {
if (!result.success) {
this.logger.warn(`Failed to process packet: ${result.error}`);
return;
}
this.packetsProcessed++;
const { packetType, packetData } = result;
if (packetType === 'metadata') {
this.handleMetadataPacket(packetData);
} else if (packetType === 'data') {
this.handleDataPacket(packetData);
}
}
handleMetadataPacket(metadata) {
if (this.metadataReceived) {
if (metadata.fileName === this.fileMetadata.fileName &&
metadata.fileSize === this.fileMetadata.fileSize &&
metadata.chunksCount === this.fileMetadata.chunksCount) {
this.logger.debug("Received duplicate metadata packet");
return;
} else {
this.logger.warn("Received metadata for a different file, reinitializing");
}
}
this.metadataReceived = true;
this.fileMetadata = metadata;
this.ui.initializeChunkGrid(metadata.chunksCount);
this.ui.updateFileInfo(`
<div><strong>File Name:</strong> ${metadata.fileName}</div><div><strong>File Type:</strong> ${metadata.fileType}</div><div><strong>File Size:</strong> ${this.formatFileSize(metadata.fileSize)}</div><div><strong>Chunks:</strong> ${metadata.chunksCount}</div><div><strong>Protocol Version:</strong> ${metadata.protocolVersion}</div>
`);
this.fountainDecoder.initialize(metadata);
for (let i = 0; i < metadata.chunksCount; i++) {
this.missingChunks.add(i);
}
this.updateMissingChunksUI();
this.logger.info(`Metadata received: ${metadata.fileName} (${this.formatFileSize(metadata.fileSize)}), ${metadata.chunksCount} chunks`);
}
handleDataPacket(packet) {
if (!this.metadataReceived) {
this.logger.warn("Received data packet before metadata, ignoring");
return;
}
if (packet.sourceChunks) {
packet.sourceChunks.forEach(chunkIndex => {
this.ui.blinkChunk(chunkIndex);
});
}
const wasAdded = this.fountainDecoder.addPacket(packet);
if (wasAdded) {
const newlyRecovered = this.fountainDecoder.getNewlyRecoveredChunks();
if (newlyRecovered.length > 0) {
newlyRecovered.forEach(chunkIndex => {
this.recoveredChunks.set(chunkIndex, true);
this.missingChunks.delete(chunkIndex);
this.ui.markChunkAsRecovered(chunkIndex);
});
this.updateMissingChunksUI();
this.logger.info(`Recovered ${newlyRecovered.length} new chunks, total: ${this.recoveredChunks.size}/${this.fileMetadata.chunksCount}`);
}
}
}
updateMissingChunksUI() {
const missingCount = this.missingChunks.size;
const totalCount = this.fileMetadata.chunksCount;
const recoveredCount = totalCount - missingCount;
document.getElementById('missingChunks').innerHTML = `
<div>Recovered chunks: ${recoveredCount}/${totalCount} (${Math.round(recoveredCount / totalCount * 100)}%)</div><div>Missing chunks: ${missingCount}</div>
`;
if (missingCount === 0 && recoveredCount === totalCount) {
this.logger.info("All chunks recovered, finalizing file...");
}
}
handleFileComplete(fileData) {
this.logger.info("File recovery complete!");
this.recoveredFileData = fileData;
document.getElementById('downloadContainer').style.display = 'block';
const fileInfo = document.getElementById('fileInfo').innerHTML;
document.getElementById('fileInfo').innerHTML = fileInfo + `
<div style="margin-top: 10px; color: var(--success-color);"><strong>File Successfully Recovered!</strong></div>
`;
this.downloadFile();
}
downloadFile() {
if (!this.recoveredFileData || !this.fileMetadata) {
this.logger.warn("No recovered file data available");
return;
}
try {
const blob = new Blob([this.recoveredFileData], { type: this.fileMetadata.fileType || 'application/octet-stream' });
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = this.fileMetadata.fileName;
document.body.appendChild(a);
a.click();
setTimeout(() => {
document.body.removeChild(a);
URL.revokeObjectURL(url);
}, 100);
this.logger.info(`File "${this.fileMetadata.fileName}" downloaded (${this.formatFileSize(this.recoveredFileData.byteLength)})`);
} catch (error) {
this.logger.error(`Error downloading file: ${error.message}`);
this.ui.showErrorMessage(`Error downloading file: ${error.message}`);
}
}
saveSettings() {
const workerCount = parseInt(document.getElementById('workerCount').value);
const packetWorkerCount = parseInt(document.getElementById('packetWorkerCount').value);
const frameInterval = parseInt(document.getElementById('frameInterval').value);
const qrDetectionConfidence = parseFloat(document.getElementById('qrDetectionConfidence').value);
const cameraResolution = document.getElementById('cameraResolution').value;
this.settings = {
workerCount: isNaN(workerCount) ? 4 : Math.min(Math.max(workerCount, 1), 16),
packetWorkerCount: isNaN(packetWorkerCount) ? 2 : Math.min(Math.max(packetWorkerCount, 1), 8),
frameInterval: isNaN(frameInterval) ? 100 : Math.min(Math.max(frameInterval, 0), 1000),
qrDetectionConfidence: isNaN(qrDetectionConfidence) ? 0.5 : Math.min(Math.max(qrDetectionConfidence, 0), 1),
cameraResolution: ['auto', 'hd', 'fullhd', 'low'].includes(cameraResolution) ? cameraResolution : 'auto'
};
if (this.cameraProcessor) {
this.cameraProcessor.frameInterval = this.settings.frameInterval;
}
this.logger.info(`Settings updated: ${JSON.stringify(this.settings)}`);
this.ui.hideSettingsModal();
}
formatFileSize(bytes) {
if (bytes < 1024) return `${bytes} bytes`;
if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB`;
return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
}
}
document.addEventListener('DOMContentLoaded', () => {
window.qrFileDecoder = new QRFileDecoder();
});</script></body></html>