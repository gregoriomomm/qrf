<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Video QR Code Decoder</title>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: sans-serif;
        }

        .container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }

        .tabs {
            display: flex;
            background: #f0f0f0;
            border-bottom: 1px solid #ddd;
        }

        .tab {
            padding: 12px 20px;
            cursor: pointer;
            border-right: 1px solid #ddd;
        }

        .tab.active {
            background: #fff;
            font-weight: bold;
        }

        .tab-content {
            display: none;
            flex: 1;
            overflow: hidden;
        }

        .tab-content.active {
            display: flex;
        }

        .panel {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .left-panel {
            width: 60%;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #222;
            position: relative;
            padding: 10px;
        }

        .controls {
            margin-bottom: 10px;
            z-index: 10;
        }

        button {
            margin: 5px;
            padding: 8px 15px;
            font-size: 14px;
            cursor: pointer;
        }

        .video-container {
            position: relative;
            width: 100%;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #liveVideo, #processingVideo {
            max-width: 100%;
            max-height: 100%;
            background: black;
            z-index: 5;
        }

        .scan-region {
            position: absolute;
            border: 2px solid red;
            width: 200px;
            height: 200px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 6;
        }

        .right-panel {
            width: 40%;
            display: flex;
            flex-direction: column;
            padding: 10px;
            background: #f0f0f0;
        }

        .grid {
            --cell-size: 20px;
            display: grid;
            gap: 1px;
            height: auto;
            max-height: 30%;
            width: 100%;
            place-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background: #1a1a1a;
            border-radius: 4px;
            overflow-y: auto;
            position: relative;
        }
        
        /* Improve performance for large grids */
        @media (min-width: 768px) {
            .grid {
                grid-template-columns: repeat(auto-fill, minmax(12px, 1fr)) !important;
            }
        }
        
        /* For very large frame counts */
        .grid.large-count {
            --cell-size: 10px;
            gap: 1px;
            grid-template-columns: repeat(auto-fill, minmax(8px, 1fr)) !important;
        }
        
        .status-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-family: monospace;
            background: #333;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
        }
        
        .counter-box {
            display: inline-block;
            padding: 3px 8px;
            margin-right: 5px;
            background: #222;
            border-radius: 3px;
            color: lime;
        }

        .progress-container {
            height: 20px;
            background: #2a2a2a;
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
            border: 1px solid #333;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            width: 0%;
            text-align: center;
            color: white;
            font-size: 12px;
            line-height: 20px;
            transition: width 0.3s;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .grid-cell {
            background: darkred;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            text-align: center;
            transition: background 0.2s, transform 0.1s;
            width: var(--cell-size);
            height: var(--cell-size);
            position: relative;
            cursor: pointer;
            user-select: none;
        }

        .grid-cell:hover {
            transform: scale(1.1);
            z-index: 2;
        }

        .grid-cell.received {
            background: #4CAF50;
            box-shadow: 0 0 2px rgba(76, 175, 80, 0.8);
        }

        .grid-cell.blinking {
            background: yellow !important;
            color: black;
            animation: pulse 0.4s;
            transform: scale(1.2);
            z-index: 10;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1.2); }
        }
        
        .grid-stats {
            grid-column: 1 / -1;
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            background: #333;
            border-radius: 4px;
            text-align: center;
            font-family: monospace;
            color: white;
        }
        
        .grid-stats-received {
            color: #4CAF50;
            font-weight: bold;
        }
        
        .grid-stats-missing {
            color: #f44336;
            font-weight: bold;
        }

        .log {
            flex: 1;
            background: black;
            color: lime;
            padding: 10px;
            overflow-y: auto;
            white-space: pre;
            font-family: monospace;
            margin-top: 10px;
        }

        .hidden {
            display: none;
        }

        #canvas {
            display: none;
        }

        #fileInput {
            display: none;
        }

        .dropzone {
            border: 2px dashed #ccc;
            border-radius: 5px;
            padding: 25px;
            text-align: center;
            margin: 15px 0;
            background: #f9f9f9;
            cursor: pointer;
        }

        .dropzone:hover {
            background: #f0f0f0;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="tabs">
            <div class="tab active" data-tab="live">Live Camera</div>
            <div class="tab" data-tab="video">Video File</div>
        </div>

        <!-- Live Camera Tab -->
        <div class="tab-content active" id="live-tab">
            <div class="panel">
                <div class="left-panel">
                    <div class="controls">
                        <button id="startLiveBtn">Start Camera</button>
                        <button id="stopLiveBtn" disabled>Stop Camera</button>
                    </div>
                    <div class="video-container">
                        <video id="liveVideo" playsinline></video>
                        <div class="scan-region"></div>
                    </div>
                </div>
                <div class="right-panel">
                    <div class="status-container">
                        <div>Frames: <span class="counter-box" id="liveFramesCounter">0</span></div>
                        <div>QR detected: <span class="counter-box" id="liveQrCounter">0</span></div>
                    </div>
                    <div class="grid" id="liveGrid"></div>
                    <div class="log" id="liveLog"></div>
                </div>
            </div>
        </div>

        <!-- Video File Tab -->
        <div class="tab-content" id="video-tab">
            <div class="panel">
                <div class="left-panel">
                    <div class="controls">
                        <button id="openVideoBtn">Open Video</button>
                        <button id="processVideoBtn" disabled>Process Video</button>
                        <button id="stopProcessingBtn" disabled>Stop Processing</button>
                    </div>
                    <div class="video-container">
                        <video id="processingVideo" controls></video>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar" id="progressBar"></div>
                    </div>
                    <input type="file" id="fileInput" accept="video/*" />
                    <div class="dropzone">
                        <p>Drop video file here or click to select</p>
                    </div>
                </div>
                <div class="right-panel">
                    <div class="status-container">
                        <div>Frames: <span class="counter-box" id="videoFramesCounter">0</span></div>
                        <div>QR detected: <span class="counter-box" id="videoQrCounter">0</span></div>
                        <div>Time: <span class="counter-box" id="videoTimeDisplay">0.0s</span></div>
                    </div>
                    <div class="grid" id="videoGrid"></div>
                    <div class="log" id="videoLog"></div>
                </div>
            </div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // DOM Elements
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        const canvas = document.getElementById('canvas');
        // Initialize canvas with willReadFrequently to avoid warnings
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        canvas.willReadFrequently = true;
        
        // Live tab elements
        const liveVideo = document.getElementById('liveVideo');
        const startLiveBtn = document.getElementById('startLiveBtn');
        const stopLiveBtn = document.getElementById('stopLiveBtn');
        const liveGrid = document.getElementById('liveGrid');
        const liveLog = document.getElementById('liveLog');
        const liveFramesCounter = document.getElementById('liveFramesCounter');
        const liveQrCounter = document.getElementById('liveQrCounter');
        
        // Video tab elements
        const processingVideo = document.getElementById('processingVideo');
        const openVideoBtn = document.getElementById('openVideoBtn');
        const processVideoBtn = document.getElementById('processVideoBtn');
        const stopProcessingBtn = document.getElementById('stopProcessingBtn');
        const fileInput = document.getElementById('fileInput');
        const dropzone = document.querySelector('.dropzone');
        const videoGrid = document.getElementById('videoGrid');
        const videoLog = document.getElementById('videoLog');
        const progressBar = document.getElementById('progressBar');
        const videoFramesCounter = document.getElementById('videoFramesCounter');
        const videoQrCounter = document.getElementById('videoQrCounter');
        const videoTimeDisplay = document.getElementById('videoTimeDisplay');

        // State variables
        let liveStream = null;
        let isLiveScanning = false;
        let isProcessingVideo = false;
        let currentProcessingFrame = 0;
        let totalFrames = 0;
        let capturedFramesCount = 0;
        let framesCapturedWithQR = 0;
        let isWaitingForSeek = false;
        let lastSeekTime = 0;
        
        // Data storage
        let startReceived = false;
        let totalFramesExpected = 0;
        let fileName = '';
        let fileSize = 0;
        let framesData = [];
        let framesReceived = [];
        let lastQrData = null;
        let lastQrTime = 0;
        let logMessages = {
            live: [],
            video: []
        };

        // Tab switching
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                
                // Update active tab
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Update active content
                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(`${tabName}-tab`).classList.add('active');
                
                // Stop any active processes when switching tabs
                if (tabName === 'live' && isProcessingVideo) {
                    stopVideoProcessing();
                } else if (tabName === 'video' && isLiveScanning) {
                    stopLiveScanning();
                }
            });
        });

        // Logging functions
        function showLog(message, type = 'live') {
            logMessages[type].push(message);
            const logElement = type === 'live' ? liveLog : videoLog;
            logElement.textContent = logMessages[type].join('\n');
            logElement.scrollTop = logElement.scrollHeight;
        }

        function resetState(type = 'live') {
            startReceived = false;
            totalFramesExpected = 0;
            fileName = '';
            fileSize = 0;
            framesData = [];
            framesReceived = [];
            lastQrData = null;
            lastQrTime = 0;
            
            if (type === 'live') {
                stopLiveBtn.disabled = true;
                startLiveBtn.disabled = false;
                liveVideo.style.display = 'none';
                isLiveScanning = false;
                logMessages.live = [];
                liveLog.textContent = '';
                liveGrid.innerHTML = '';
                capturedFramesCount = 0;
                framesCapturedWithQR = 0;
                liveFramesCounter.textContent = '0';
                liveQrCounter.textContent = '0';
            } else {
                processVideoBtn.disabled = true;
                stopProcessingBtn.disabled = true;
                currentProcessingFrame = 0;
                totalFrames = 0;
                isProcessingVideo = false;
                progressBar.style.width = '0%';
                progressBar.textContent = '';
                logMessages.video = [];
                videoLog.textContent = '';
                videoGrid.innerHTML = '';
                capturedFramesCount = 0;
                framesCapturedWithQR = 0;
                videoFramesCounter.textContent = '0';
                videoQrCounter.textContent = '0';
            }
        }

        function updateGrid(type = 'live') {
            const grid = type === 'live' ? liveGrid : videoGrid;
            grid.innerHTML = '';
            
            if (totalFramesExpected <= 0) return;
            
            // Add class for very large frame counts
            if (totalFramesExpected > 1000) {
                grid.classList.add('large-count');
            } else {
                grid.classList.remove('large-count');
            }
            
            // Calculate optimal grid layout based on screen size and frame count
            const gridWidth = grid.clientWidth;
            
            // Adjust cell size based on number of frames
            let cellSize;
            if (totalFramesExpected > 5000) {
                cellSize = 8;  // Tiny cells for massive frame counts
            } else if (totalFramesExpected > 1000) {
                cellSize = 10; // Very small cells for large frame counts
            } else if (totalFramesExpected > 500) {
                cellSize = 15; // Small cells
            } else {
                cellSize = Math.min(30, Math.max(15, Math.floor(gridWidth / 20))); // Dynamic cell size
            }
            
            const columns = Math.floor(gridWidth / cellSize);
            
            grid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
            grid.style.setProperty('--cell-size', `${cellSize}px`);
            
            // Create a document fragment for better performance
            const fragment = document.createDocumentFragment();
            
            // For very large numbers, create group indicators rather than individual cells
            if (totalFramesExpected > 2000) {
                // Use a grouped approach for better performance
                const groupSize = Math.ceil(totalFramesExpected / 500); // About 500 visual elements
                
                for (let i = 0; i < totalFramesExpected; i += groupSize) {
                    const endIdx = Math.min(i + groupSize - 1, totalFramesExpected - 1);
                    
                    // Calculate how many frames are received in this group
                    let receivedInGroup = 0;
                    for (let j = i; j <= endIdx; j++) {
                        if (framesReceived[j]) receivedInGroup++;
                    }
                    
                    // Create a group cell
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.setAttribute('data-start', i + 1);
                    cell.setAttribute('data-end', endIdx + 1);
                    
                    // Calculate completion percentage
                    const groupCompletionPct = Math.round((receivedInGroup / (endIdx - i + 1)) * 100);
                    
                    // Visual styling based on completion
                    if (receivedInGroup === endIdx - i + 1) {
                        // Fully complete
                        cell.classList.add('received');
                    } else if (receivedInGroup > 0) {
                        // Partially complete - create a gradient or pattern
                        cell.style.background = `linear-gradient(to right, #4CAF50 ${groupCompletionPct}%, darkred ${groupCompletionPct}%)`;
                    }
                    
                    // Tooltip shows frame range and completion
                    cell.setAttribute('title', `Frames ${i+1}-${endIdx+1}: ${receivedInGroup}/${endIdx-i+1} received (${groupCompletionPct}%)`);
                    
                    fragment.appendChild(cell);
                }
            } else {
                // Standard approach for reasonable numbers of frames
                for (let i = 0; i < totalFramesExpected; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.setAttribute('data-index', i + 1);
                    
                    // For smaller cells, use a color-only approach
                    if (cellSize < 20) {
                        cell.textContent = '';
                    } else {
                        cell.textContent = i + 1;
                    }
                    
                    if (framesReceived[i]) {
                        cell.classList.add('received');
                    }
                    
                    // Add tooltip with frame number
                    cell.setAttribute('title', `Frame ${i + 1}`);
                    
                    // Store cell reference for faster blinking
                    const cellId = `cell-${type}-${i}`;
                    cell.id = cellId;
                    
                    fragment.appendChild(cell);
                }
            }
            
            // Append all cells at once
            grid.appendChild(fragment);
            
            // Add counter for missing frames
            const missingCount = framesReceived.filter(received => !received).length;
            const statsDiv = document.createElement('div');
            statsDiv.className = 'grid-stats';
            
            // Calculate progress percentage
            const progressPct = totalFramesExpected > 0 ? 
                Math.round(((totalFramesExpected - missingCount) / totalFramesExpected) * 100) : 0;
                
            statsDiv.innerHTML = `<span class="grid-stats-received">${totalFramesExpected - missingCount}</span>/<span class="grid-stats-total">${totalFramesExpected}</span> frames received (${progressPct}%)`;
            
            if (missingCount > 0) {
                statsDiv.innerHTML += ` <span class="grid-stats-missing">(${missingCount} missing)</span>`;
            }
            
            grid.appendChild(statsDiv);
        }

        function blinkCell(index, type = 'live') {
            const grid = type === 'live' ? liveGrid : videoGrid;
            
            // Handle grouped cells for large frame counts
            if (totalFramesExpected > 2000) {
                // Need to find which group contains this index
                const groupSize = Math.ceil(totalFramesExpected / 500);
                const groupIndex = Math.floor(index / groupSize);
                const groupStartIndex = groupIndex * groupSize;
                
                // Find cell by data attributes
                const cells = grid.querySelectorAll('.grid-cell');
                let targetCell = null;
                
                for (let i = 0; i < cells.length; i++) {
                    const start = parseInt(cells[i].getAttribute('data-start') || '-1');
                    const end = parseInt(cells[i].getAttribute('data-end') || '-1');
                    
                    if (start <= index + 1 && index + 1 <= end) {
                        targetCell = cells[i];
                        break;
                    }
                }
                
                // If found the group cell, highlight it
                if (targetCell) {
                    targetCell.classList.add('blinking');
                    
                    // Calculate updated completion for the group
                    const start = parseInt(targetCell.getAttribute('data-start')) - 1;
                    const end = parseInt(targetCell.getAttribute('data-end')) - 1;
                    
                    // Count received frames in this group
                    let receivedInGroup = 0;
                    for (let i = start; i <= end; i++) {
                        if (framesReceived[i]) receivedInGroup++;
                    }
                    
                    // Calculate completion percentage
                    const groupCompletionPct = Math.round((receivedInGroup / (end - start + 1)) * 100);
                    
                    // Use requestAnimationFrame for better performance
                    requestAnimationFrame(() => {
                        setTimeout(() => {
                            targetCell.classList.remove('blinking');
                            
                            // Update cell appearance based on completion
                            if (receivedInGroup === end - start + 1) {
                                // Fully complete
                                targetCell.classList.add('received');
                                targetCell.style.background = ''; // Remove gradient if exists
                            } else if (receivedInGroup > 0) {
                                // Partially complete - update gradient
                                targetCell.style.background = `linear-gradient(to right, #4CAF50 ${groupCompletionPct}%, darkred ${groupCompletionPct}%)`;
                            }
                            
                            // Update tooltip
                            targetCell.setAttribute('title', 
                                `Frames ${start+1}-${end+1}: ${receivedInGroup}/${end-start+1} received (${groupCompletionPct}%)`);
                                
                            // Update stats
                            updateGridStats(type);
                        }, 200);
                    });
                }
            } else {
                // Normal individual cell handling
                const cellId = `cell-${type}-${index}`;
                const cell = document.getElementById(cellId);
                
                if (cell) {
                    cell.classList.add('blinking');
                    
                    // Use requestAnimationFrame for better performance
                    requestAnimationFrame(() => {
                        // Add a small delay to make the blink visible
                        setTimeout(() => {
                            cell.classList.remove('blinking');
                            if (framesReceived[index]) {
                                cell.classList.add('received');
                            }
                            
                            // Update stats
                            updateGridStats(type);
                        }, 200);
                    });
                }
            }
        }
        
        // Separate function to update grid stats for better performance
        function updateGridStats(type) {
            const grid = type === 'live' ? liveGrid : videoGrid;
            const statsDiv = grid.querySelector('.grid-stats');
            
            if (statsDiv && totalFramesExpected > 0) {
                const missingCount = framesReceived.filter(received => !received).length;
                const receivedCount = totalFramesExpected - missingCount;
                const progressPct = Math.round((receivedCount / totalFramesExpected) * 100);
                
                // Update stats with new information
                const receivedSpan = statsDiv.querySelector('.grid-stats-received');
                const totalSpan = statsDiv.querySelector('.grid-stats-total');
                const missingSpan = statsDiv.querySelector('.grid-stats-missing');
                
                if (receivedSpan) receivedSpan.textContent = receivedCount;
                if (totalSpan) totalSpan.textContent = totalFramesExpected;
                
                // Update or add progress percentage
                let pctSpan = statsDiv.querySelector('.progress-pct');
                if (!pctSpan) {
                    // First create pct element if it doesn't exist
                    pctSpan = document.createElement('span');
                    pctSpan.className = 'progress-pct';
                    statsDiv.appendChild(pctSpan);
                }
                pctSpan.textContent = ` (${progressPct}%)`;
                
                // Update missing count
                if (missingSpan) {
                    if (missingCount > 0) {
                        missingSpan.textContent = `(${missingCount} missing)`;
                        missingSpan.style.display = 'inline';
                    } else {
                        missingSpan.style.display = 'none';
                    }
                } else if (missingCount > 0) {
                    const newMissingSpan = document.createElement('span');
                    newMissingSpan.className = 'grid-stats-missing';
                    newMissingSpan.textContent = ` (${missingCount} missing)`;
                    statsDiv.appendChild(newMissingSpan);
                }
            }
        }

        function updateProgressBar(current, total) {
            if (total <= 0) return;
            
            const percent = Math.min(100, Math.round((current / total) * 100));
            progressBar.style.width = `${percent}%`;
            progressBar.textContent = `${percent}%`;
        }

        // Live scanning functions
        async function startLiveScanning() {
            try {
                liveStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                });
                
                liveVideo.srcObject = liveStream;
                liveVideo.setAttribute('playsinline', 'true');
                
                try {
                    await liveVideo.play();
                    showLog('Camera started');
                } catch (err) {
                    showLog('Play error: ' + err.message + ' - Try tapping screen');
                    
                    // Add tap-to-play handler
                    liveVideo.addEventListener('click', () => {
                        liveVideo.play().catch(e => showLog('Play failed: ' + e.message));
                    });
                }
                
                liveVideo.style.display = 'block';
                isLiveScanning = true;
                startLiveBtn.disabled = true;
                stopLiveBtn.disabled = false;
                
                showLog('Camera ready, scanning for QR codes...');
                requestAnimationFrame(scanLiveFrame);
            } catch (err) {
                showLog('Error starting camera: ' + err.message);
            }
        }

        function stopLiveScanning() {
            if (liveStream) {
                liveStream.getTracks().forEach(track => track.stop());
                liveStream = null;
            }
            
            isLiveScanning = false;
            showLog('Camera stopped');
            resetState('live');
        }

        function scanLiveFrame() {
            if (!isLiveScanning) return;
            
            if (liveVideo.readyState === liveVideo.HAVE_ENOUGH_DATA) {
                canvas.width = liveVideo.videoWidth;
                canvas.height = liveVideo.videoHeight;
                ctx.drawImage(liveVideo, 0, 0);
                
                capturedFramesCount++;
                liveFramesCounter.textContent = capturedFramesCount;
                
                try {
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const qrCode = jsQR(imageData.data, imageData.width, imageData.height, {
                        inversionAttempts: 'attemptBoth', // Try both non-inverted and inverted for better detection
                        canOverwriteImage: true, // Allow overwriting the image data for performance
                        maxModuleCount: 177  // Support high capacity QR codes (version 40)
                    });
                    
                    if (qrCode) {
                        framesCapturedWithQR++;
                        liveQrCounter.textContent = framesCapturedWithQR;
                        processQrData(qrCode.data, 'live');
                    }
                } catch (err) {
                    // Silent catch - continue scanning
                }
            }
            
            requestAnimationFrame(scanLiveFrame);
        }

        // Video file processing
        function handleFileInput(file) {
            if (!file || !file.type.startsWith('video/')) {
                showLog('Please select a valid video file', 'video');
                return;
            }
            
            const videoUrl = URL.createObjectURL(file);
            processingVideo.src = videoUrl;
            
            processingVideo.onloadedmetadata = () => {
                showLog(`Video loaded: ${file.name} (${Math.round(processingVideo.duration)}s)`, 'video');
                processVideoBtn.disabled = false;
                dropzone.textContent = file.name;
            };
            
            processingVideo.onerror = () => {
                showLog(`Error loading video: ${processingVideo.error.message}`, 'video');
                URL.revokeObjectURL(videoUrl);
            };
        }

        // Smart search strategy for finding QR codes in videos
        let searchPhase = 'initial'; // 'initial', 'binary', 'sequential', 'completion'
        let binarySearchRanges = []; // Tracks ranges for binary search
        let foundQRTimeRanges = []; // Track time ranges where QR codes were found
        let fastForwardMode = false; // Skip ahead when QR codes found
        let initialSampleRate = 4; // Initial sparse sampling rate (1 frame per x seconds)
        
        function startVideoProcessing() {
            if (!processingVideo.src) {
                showLog('No video loaded', 'video');
                return;
            }
            
            resetState('video');
            isProcessingVideo = true;
            processVideoBtn.disabled = true;
            stopProcessingBtn.disabled = false;
            
            const duration = processingVideo.duration;
            
            // Handle invalid duration more gracefully
            const validDuration = isFinite(duration) && duration > 0;
            if (!validDuration) {
                showLog('Warning: Video has invalid duration (Infinity). Will use time-based processing instead.', 'video');
                // Don't stop - continue with a default duration for processing
                const assumedDuration = 3600; // Assume 60 minutes for processing
                
                searchPhase = 'sequential';
                let fps = 15; // Higher frame rate to catch more QR codes
                totalFrames = 5000; // Process much more frames to ensure we catch all QR codes
                showLog(`Using time-based processing with ${totalFrames} frames for high density QR code detection`, 'video');
                currentProcessingFrame = 0;
                
                // Set up our own time tracking
                processingVideo.addEventListener('timeupdate', function() {
                    videoTimeDisplay.textContent = processingVideo.currentTime.toFixed(1) + 's';
                });
                
                processNextFrameBatch();
                return;
            }
            
            // Set up search strategy based on video length
            if (duration > 10 && isFinite(duration)) {
                // For longer videos, use smart search
                showLog(`Using smart search strategy for ${duration.toFixed(1)}s video`, 'video');
                searchPhase = 'initial';
                
                // First, do an intensive scan of the first few seconds
                // This is critical for finding metadata frames which are usually at the start
                showLog("First performing intensive scan of video beginning to find metadata frames...", 'video');
                
                // Create a list of time points focused heavily on the first few seconds
                const earlyTimePoints = [];
                
                // First 10 seconds at very high density (every ~100ms)
                for (let t = 0; t < Math.min(10, duration); t += 0.1) {
                    earlyTimePoints.push(t);
                }
                
                // Process these points first
                processSpecificFrames(earlyTimePoints, () => {
                    // If we found metadata, skip to processing that region
                    if (startReceived) {
                        showLog("Found metadata frame in video beginning! Now searching for all chunks...", 'video');
                        processFocusedAreas();
                        return;
                    }
                    
                    // If we didn't find metadata in the beginning, continue with regular search
                    showLog("No metadata found in video beginning, continuing with full video scan...", 'video');
                    
                    // Adjust initial sample rate based on video length
                    if (duration > 300) { // > 5 minutes
                        initialSampleRate = 5; // Check every 5 seconds initially (doubled density)
                    } else if (duration > 120) { // > 2 minutes
                        initialSampleRate = 3; // Check every 3 seconds initially
                    } else if (duration > 60) { // > 1 minute
                        initialSampleRate = 1; // Check every 1 second initially
                    } else {
                        initialSampleRate = 0.5; // Check every 0.5 seconds for shorter videos
                    }
                    
                    // Safety check - set upper limit on samples
                    const MAX_SAMPLES = 5000; // Increased from 1000
                    const safeInitialSampleRate = Math.max(initialSampleRate, duration / MAX_SAMPLES);
                    
                    // Calculate initial sparse sampling
                    const initialSampleCount = Math.min(MAX_SAMPLES, Math.ceil(duration / safeInitialSampleRate));
                    totalFrames = initialSampleCount;
                    
                    showLog(`Initial scan: ${initialSampleCount} samples at ${safeInitialSampleRate.toFixed(1)}s intervals`, 'video');
                    
                    // Set up frames for the initial sparse sampling
                    currentProcessingFrame = 0;
                    
                    // Start with initial sparse sampling to find QR code clusters
                    processSmartSearch();
                });
            } else {
                // For short videos, use sequential processing
                searchPhase = 'sequential';
                let fps = 10; // Default for short videos
                
                // Safety check for very long videos
                if (duration > 3600) { // > 1 hour
                    fps = 1; // Very sparse sampling for extremely long videos
                } else if (duration > 600) { // > 10 minutes
                    fps = 2;
                }
                
                const maxFrames = 10000; // Safety limit
                totalFrames = Math.min(maxFrames, Math.ceil(duration * fps));
                
                showLog(`Sequential processing: ${totalFrames} frames from ${duration.toFixed(1)}s video`, 'video');
                currentProcessingFrame = 0;
                processNextFrameBatch();
            }
        }
        
        // Smart search with adaptive strategy
        function processSmartSearch() {
            const duration = processingVideo.duration;
            
            // Double-check duration validity
            if (!isFinite(duration) || duration <= 0) {
                showLog('Invalid video duration detected in smart search. Switching to sequential processing.', 'video');
                searchPhase = 'sequential';
                let fps = 2; // Very conservative framerate
                totalFrames = 100; // Just process a small number of frames
                currentProcessingFrame = 0;
                processNextFrameBatch();
                return;
            }
            
            if (searchPhase === 'initial') {
                showLog(`Starting initial sparse sampling phase...`, 'video');
                
                // Create a list of frames at reasonable intervals (with safety check for duration)
                const samples = [];
                const maxSamples = 1000; // Prevent extremely large arrays
                const effectiveRate = Math.max(initialSampleRate, duration / maxSamples);
                
                for (let time = 0; time < duration; time += effectiveRate) {
                    samples.push(time);
                }
                
                // Last frame if not included
                if (samples[samples.length-1] < duration - 1) {
                    samples.push(duration - 1);
                }
                
                // Process these sample frames
                processSpecificFrames(samples, () => {
                    // After initial phase completes
                    if (startReceived) {
                        // We found metadata! Move to sequential processing around found areas
                        searchPhase = 'sequential';
                        showLog(`Found QR metadata! Switching to sequential processing.`, 'video');
                        
                        // If we haven't found all frames yet, determine processing range
                        const missingFrames = framesReceived.filter(received => !received).length;
                        
                        if (missingFrames > 0) {
                            // Focus on processing promising areas
                            let minTime = duration;
                            let maxTime = 0;
                            
                            // Find time range where QR codes were detected
                            foundQRTimeRanges.forEach(range => {
                                minTime = Math.min(minTime, range.start);
                                maxTime = Math.max(maxTime, range.end);
                            });
                            
                            // Add buffer zones (10% of duration on either side)
                            const buffer = Math.min(10, duration * 0.1);
                            minTime = Math.max(0, minTime - buffer);
                            maxTime = Math.min(duration, maxTime + buffer);
                            
                            showLog(`Processing focused time range: ${minTime.toFixed(1)}s to ${maxTime.toFixed(1)}s`, 'video');
                            processTimeRange(minTime, maxTime);
                        }
                    } else {
                        // No metadata found yet, switch to binary search
                        searchPhase = 'binary';
                        showLog(`No QR metadata found in sparse sampling. Switching to binary search.`, 'video');
                        
                        // Set up binary search on the entire video
                        binarySearchRanges = [{start: 0, end: duration, depth: 0}];
                        processBinarySearchRanges();
                    }
                });
            } else if (searchPhase === 'binary') {
                processBinarySearchRanges();
            }
        }
        
        // Process a specific list of timestamps with batch processing for large arrays
        function processSpecificFrames(timePoints, onComplete) {
            // Process in smaller batches to avoid stack overflow
            const BATCH_SIZE = 100;
            let currentBatch = 0;
            const totalBatches = Math.ceil(timePoints.length / BATCH_SIZE);
            
            function processBatch(batchIndex) {
                if (batchIndex >= totalBatches || !isProcessingVideo) {
                    if (onComplete) onComplete();
                    return;
                }
                
                const startIndex = batchIndex * BATCH_SIZE;
                const endIndex = Math.min((batchIndex + 1) * BATCH_SIZE, timePoints.length);
                const currentBatchPoints = timePoints.slice(startIndex, endIndex);
                
                // Process this batch of points
                let pointIndex = 0;
                
                function processNextPoint() {
                    if (pointIndex >= currentBatchPoints.length || !isProcessingVideo) {
                        // This batch is done, move to next batch
                        setTimeout(() => {
                            processBatch(batchIndex + 1);
                        }, 50);
                        return;
                    }
                    
                    const time = currentBatchPoints[pointIndex];
                    processingVideo.currentTime = time;
                    
                    processingVideo.onseeked = () => {
                        try {
                            // Process the current frame
                            captureAndProcessFrame(time);
                            
                            // Update progress based on overall position
                            const overallIndex = startIndex + pointIndex;
                            updateProgressBar(overallIndex + 1, timePoints.length);
                            
                            // Check if we should fast-forward based on QR detection
                            if (startReceived && fastForwardMode) {
                                // Check if we've found all frames
                                const missingFrames = framesReceived.filter(received => !received).length;
                                if (missingFrames === 0) {
                                    showLog(`All frames found! Completing processing.`, 'video');
                                    if (onComplete) onComplete();
                                    return;
                                }
                            }
                            
                            // Move to next point
                            pointIndex++;
                            
                            // Continue to next frame with slight delay
                            setTimeout(processNextPoint, 30);
                        } catch (err) {
                            showLog(`Error processing frame at ${time}s: ${err.message}`, 'video');
                            // Move to next point even if there's an error
                            pointIndex++;
                            setTimeout(processNextPoint, 30);
                        }
                    };
                }
                
                // Start processing this batch
                processNextPoint();
            }
            
            // Start with the first batch
            processBatch(0);
        }
        
        // Process a specific time range with a given frames per second
        function processTimeRange(startTime, endTime, fps = 10) {
            const duration = endTime - startTime;
            const framesToProcess = Math.ceil(duration * fps);
            
            const timePoints = [];
            for (let i = 0; i < framesToProcess; i++) {
                const time = startTime + (i * duration) / framesToProcess;
                timePoints.push(time);
            }
            
            showLog(`Processing ${framesToProcess} frames in time range ${startTime.toFixed(1)}s - ${endTime.toFixed(1)}s`, 'video');
            processSpecificFrames(timePoints, () => {
                // Check if we've found all frames
                if (startReceived) {
                    const missingFrames = framesReceived.filter(received => !received).length;
                    
                    if (missingFrames === 0) {
                        showLog(`All frames found! Processing complete.`, 'video');
                        assembleAndDownloadFile('video');
                    } else {
                        showLog(`Still missing ${missingFrames} frames after focused processing.`, 'video');
                        // Try processing the entire video at a lower frame rate
                        processEntireVideoAtLowerRate();
                    }
                } else {
                    showLog(`No QR metadata found in focused processing.`, 'video');
                    // Try processing the entire video at a lower frame rate
                    processEntireVideoAtLowerRate();
                }
            });
        }
        
        // Process binary search ranges
        function processBinarySearchRanges() {
            if (binarySearchRanges.length === 0 || !isProcessingVideo) {
                // No more ranges to process - move to sequential processing
                searchPhase = 'sequential';
                showLog(`Binary search complete. Processing entire video.`, 'video');
                processEntireVideoAtLowerRate();
                return;
            }
            
            // Sort ranges by depth (process shallow depths first)
            binarySearchRanges.sort((a, b) => a.depth - b.depth);
            
            // Get next range to process
            const range = binarySearchRanges.shift();
            const midPoint = (range.start + range.end) / 2;
            
            // Sample points within this range (start, mid, end)
            const samplePoints = [
                range.start, 
                midPoint - (range.end - range.start) / 4,
                midPoint,
                midPoint + (range.end - range.start) / 4,
                range.end
            ].filter((value, index, self) => {
                // Remove duplicates and ensure all points are within video duration
                return self.indexOf(value) === index && value >= 0 && value <= processingVideo.duration;
            });
            
            showLog(`Binary search at depth ${range.depth}: ${range.start.toFixed(1)}s - ${range.end.toFixed(1)}s`, 'video');
            
            processSpecificFrames(samplePoints, () => {
                if (startReceived) {
                    // We found metadata! Move to sequential processing
                    searchPhase = 'sequential';
                    showLog(`Found QR metadata! Switching to sequential processing.`, 'video');
                    
                    // Focus on found areas
                    processFocusedAreas();
                } else if (range.end - range.start > 10 && range.depth < 3) {
                    // If range is still large and we're not too deep, create sub-ranges
                    const newDepth = range.depth + 1;
                    binarySearchRanges.push(
                        {start: range.start, end: midPoint, depth: newDepth},
                        {start: midPoint, end: range.end, depth: newDepth}
                    );
                    processBinarySearchRanges();
                } else {
                    // Continue with the next range
                    processBinarySearchRanges();
                }
            });
        }
        
        // Process focused areas where QR codes were found
        function processFocusedAreas() {
            if (foundQRTimeRanges.length === 0) {
                // No focused areas found, process the entire video
                processEntireVideoAtLowerRate();
                return;
            }
            
            // Merge overlapping ranges
            foundQRTimeRanges.sort((a, b) => a.start - b.start);
            const mergedRanges = [foundQRTimeRanges[0]];
            
            for (let i = 1; i < foundQRTimeRanges.length; i++) {
                const currentRange = foundQRTimeRanges[i];
                const lastRange = mergedRanges[mergedRanges.length - 1];
                
                // Add buffer for merging (2 second buffer)
                if (currentRange.start <= lastRange.end + 2) {
                    // Merge ranges
                    lastRange.end = Math.max(lastRange.end, currentRange.end);
                } else {
                    // Add as new range
                    mergedRanges.push(currentRange);
                }
            }
            
            // Process each merged range with a higher frame rate
            let rangeIndex = 0;
            
            function processNextRange() {
                if (rangeIndex >= mergedRanges.length || !isProcessingVideo) {
                    // All ranges processed
                    if (startReceived) {
                        const missingFrames = framesReceived.filter(received => !received).length;
                        if (missingFrames === 0) {
                            showLog(`All frames found! Processing complete.`, 'video');
                            assembleAndDownloadFile('video');
                        } else {
                            showLog(`Still missing ${missingFrames} frames after focused processing.`, 'video');
                            processEntireVideoAtLowerRate();
                        }
                    } else {
                        processEntireVideoAtLowerRate();
                    }
                    return;
                }
                
                const range = mergedRanges[rangeIndex];
                showLog(`Processing focused range ${rangeIndex+1}/${mergedRanges.length}: ${range.start.toFixed(1)}s - ${range.end.toFixed(1)}s`, 'video');
                
                // Process this range with a higher frame rate (15fps)
                processTimeRange(range.start, range.end, 15);
                rangeIndex++;
                processNextRange();
            }
            
            processNextRange();
        }
        
        // Process the entire video at an appropriate frame rate
        function processEntireVideoAtLowerRate() {
            const duration = processingVideo.duration;
            
            // Use higher frame rates for dense QR code videos
            // Dynamically adjust based on what we already found
            let fps;
            
            if (framesCapturedWithQR > 0 && capturedFramesCount > 0) {
                // Calculate QR density from what we've seen so far
                const qrDensity = framesCapturedWithQR / capturedFramesCount;
                
                if (qrDensity > 0.3) {
                    // Many QR codes found - high density video (likely 30fps QR transmission)
                    fps = Math.min(25, Math.max(20, Math.floor(qrDensity * 50)));
                    showLog(`High QR density detected (${Math.round(qrDensity*100)}%), using ${fps} fps processing rate`, 'video');
                } else if (qrDensity > 0.1) {
                    // Medium density
                    fps = 15;
                } else {
                    // Low density, but still found some QR codes
                    fps = 8;
                }
            } else {
                // Default if we don't have data yet
                fps = duration > 300 ? 5 : duration > 60 ? 10 : 15;
            }
            
            // Calculate frames but avoid extreme values
            const maxFrames = 50000; // Allow up to 50,000 frames for very dense videos
            totalFrames = Math.min(maxFrames, Math.ceil(duration * fps));
            currentProcessingFrame = 0;
            
            showLog(`Processing entire video at ${fps} fps (${totalFrames} total frames) to find all QR codes`, 'video');
            processNextFrameBatch();
        }
        
        // Capture and process a single frame at the current time position
        function captureAndProcessFrame(timePosition) {
            canvas.width = processingVideo.videoWidth;
            canvas.height = processingVideo.videoHeight;
            ctx.drawImage(processingVideo, 0, 0);
            
            capturedFramesCount++;
            videoFramesCounter.textContent = capturedFramesCount;
            
            try {
                // Fix for "Canvas2D: Multiple readback operations using getImageData are faster with the willReadFrequently attribute set to true"
                if (!canvas.willReadFrequently) {
                    canvas.willReadFrequently = true;
                    // Re-create the context with the new attribute
                    ctx = canvas.getContext('2d', { willReadFrequently: true });
                    // Redraw the current frame after updating context
                    ctx.drawImage(processingVideo, 0, 0);
                }
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Use optimized parameters for QR detection based on size
                // For larger QRs coming from the encoder at maximum size (500px)
                const qrCode = jsQR(imageData.data, imageData.width, imageData.height, {
                    inversionAttempts: 'attemptBoth', // Try both non-inverted and inverted for better detection
                    canOverwriteImage: true, // Allow overwriting the image data for performance
                    maxModuleCount: 177  // Support high capacity QR codes (version 40)
                });
                
                if (qrCode) {
                    // Mark this frame on the video preview
                    ctx.strokeStyle = 'lime';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                    ctx.lineTo(qrCode.location.topRightCorner.x, qrCode.location.topRightCorner.y);
                    ctx.lineTo(qrCode.location.bottomRightCorner.x, qrCode.location.bottomRightCorner.y);
                    ctx.lineTo(qrCode.location.bottomLeftCorner.x, qrCode.location.bottomLeftCorner.y);
                    ctx.lineTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                    ctx.stroke();
                    
                    // Process the QR data
                    framesCapturedWithQR++;
                    videoQrCounter.textContent = framesCapturedWithQR;
                    
                    // Store time position where QR was found (with safe handling)
                    try {
                        foundQRTimeRanges.push({
                            start: Math.max(0, timePosition - 2), // 2 sec buffer before
                            end: Math.min(processingVideo.duration, timePosition + 2) // 2 sec buffer after
                        });
                    } catch (e) {
                        showLog(`Warning: Could not store QR time range: ${e.message}`, 'video');
                        // If array is getting too large, consolidate ranges to avoid errors
                        if (foundQRTimeRanges.length > 500) {
                            const mergedRanges = [];
                            let lastRange = null;
                            
                            // Simple consolidation by merging adjacent ranges
                            foundQRTimeRanges.sort((a, b) => a.start - b.start).forEach(range => {
                                if (!lastRange) {
                                    lastRange = {...range};
                                    mergedRanges.push(lastRange);
                                } else if (range.start <= lastRange.end + 4) {
                                    // Merge with previous range
                                    lastRange.end = Math.max(lastRange.end, range.end);
                                } else {
                                    // New separate range
                                    lastRange = {...range};
                                    mergedRanges.push(lastRange);
                                }
                            });
                            
                            foundQRTimeRanges = mergedRanges;
                            showLog(`Consolidated ${foundQRTimeRanges.length} time ranges to avoid memory issues`, 'video');
                        }
                    }
                    
                    processQrData(qrCode.data, 'video');
                }
            } catch (err) {
                // Silent catch - continue processing
            }
        }

        function stopVideoProcessing() {
            isProcessingVideo = false;
            processVideoBtn.disabled = false;
            stopProcessingBtn.disabled = true;
            showLog('Processing stopped', 'video');
        }

        function processNextFrameBatch() {
            if (!isProcessingVideo) return;
            
            // Calculate dynamic batch size based on performance and video characteristics
            // Use larger batches for videos with fewer found QRs to speed up processing
            let batchSize;
            if (capturedFramesCount > 0) {
                const qrRatio = framesCapturedWithQR / capturedFramesCount;
                if (qrRatio > 0.5) {
                    // High QR density - use smaller batches to process more carefully
                    batchSize = 10;
                } else if (qrRatio > 0.1) {
                    // Medium QR density - moderate batch size
                    batchSize = 20;
                } else {
                    // Low QR density - process more frames at once
                    batchSize = 50;
                }
            } else {
                // No data yet - start with moderate batch size
                batchSize = 25;
            }
            
            // Handle very large videos by ensuring reasonable progress
            if (totalFrames > 10000) {
                batchSize = Math.max(batchSize, Math.floor(totalFrames / 500)); // At least 500 batches
            }
            
            const startFrame = currentProcessingFrame;
            const endFrame = Math.min(startFrame + batchSize, totalFrames);
            
            if (startFrame % 20 === 0 || startFrame === 0) {
                showLog(`Processing frames ${startFrame+1} to ${endFrame} of ${totalFrames}`, 'video');
            }
            
            // For videos with Infinity duration, use time-based increments
            if (!isFinite(processingVideo.duration) || processingVideo.duration <= 0) {
                // Update time display
                videoTimeDisplay.textContent = processingVideo.currentTime.toFixed(1) + 's';
                
                // For Infinity duration, use time increments instead of duration-based calculations
                processingVideo.currentTime += 1; // Move forward 1 second
                
                // Use requestAnimationFrame instead of nested setTimeout
                requestAnimationFrame(() => {
                    captureAndProcessFrame(processingVideo.currentTime);
                    currentProcessingFrame++;
                    updateProgressBar(currentProcessingFrame, totalFrames);
                    requestAnimationFrame(processNextFrameBatch);
                });
                return;
            }
            
            processingVideo.onseeked = () => {
                isWaitingForSeek = false; // Clear the seek waiting flag
                
                // Create and initialize context with willReadFrequently only once
                if (!canvas.willReadFrequently) {
                    // Set canvas size
                    canvas.width = processingVideo.videoWidth;
                    canvas.height = processingVideo.videoHeight;
                    // Create optimized context for frequent pixel reading
                    ctx = canvas.getContext('2d', { willReadFrequently: true });
                    canvas.willReadFrequently = true;
                }
                
                // Process the current frame
                ctx.drawImage(processingVideo, 0, 0);
                
                capturedFramesCount++;
                videoFramesCounter.textContent = capturedFramesCount;
                
                try {
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    // Use a Web Worker for QR detection if supported
                    // This is a fallback using direct detection when workers aren't available
                    const qrCode = jsQR(imageData.data, imageData.width, imageData.height, {
                        inversionAttempts: 'dontInvert'
                    });
                    
                    if (qrCode) {
                        // Mark this frame on the video preview
                        ctx.strokeStyle = 'lime';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                        ctx.lineTo(qrCode.location.topRightCorner.x, qrCode.location.topRightCorner.y);
                        ctx.lineTo(qrCode.location.bottomRightCorner.x, qrCode.location.bottomRightCorner.y);
                        ctx.lineTo(qrCode.location.bottomLeftCorner.x, qrCode.location.bottomLeftCorner.y);
                        ctx.lineTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                        ctx.stroke();
                        
                        // Process the QR data
                        framesCapturedWithQR++;
                        videoQrCounter.textContent = framesCapturedWithQR;
                        processQrData(qrCode.data, 'video');
                        
                        // Store time range where QR was found for better future processing
                        try {
                            foundQRTimeRanges.push({
                                start: Math.max(0, processingVideo.currentTime - 0.5),
                                end: Math.min(processingVideo.duration, processingVideo.currentTime + 0.5)
                            });
                        } catch(e) {
                            console.error("Error storing QR time range:", e);
                        }
                    }
                } catch (err) {
                    // Log error but continue processing
                    console.error("Error processing frame:", err);
                }
                
                // Move to next frame
                currentProcessingFrame++;
                updateProgressBar(currentProcessingFrame, totalFrames);
                
                // Use requestAnimationFrame for better performance and to avoid setTimeout violations
                if (currentProcessingFrame < endFrame && isProcessingVideo) {
                    // Process next frame in the current batch using requestAnimationFrame
                    requestAnimationFrame(() => seekToFrame(currentProcessingFrame));
                } else if (currentProcessingFrame < totalFrames && isProcessingVideo) {
                    // Process next batch
                    requestAnimationFrame(processNextFrameBatch);
                } else {
                    // Done processing
                    if (isProcessingVideo) {
                        showLog('Video processing complete', 'video');
                        stopVideoProcessing();
                        
                        // Update completion stats
                        showLog(`Processed ${capturedFramesCount} frames, found QR codes in ${framesCapturedWithQR} frames`, 'video');
                        
                        // Check if we found all frames
                        if (startReceived && framesReceived.every(Boolean)) {
                            assembleAndDownloadFile('video');
                        } else if (startReceived) {
                            const missingFrames = framesReceived
                                .map((received, i) => received ? null : i + 1)
                                .filter(Boolean);
                            
                            if (missingFrames.length > 20) {
                                showLog(`Missing ${missingFrames.length} frames`, 'video');
                            } else {
                                showLog(`Missing frames: ${missingFrames.join(', ')}`, 'video');
                            }
                            
                            // Offer to continue processing if we haven't processed the whole video
                            if (currentProcessingFrame < totalFrames - 1) {
                                showLog('Continuing to process more frames to find missing QR codes...', 'video');
                                requestAnimationFrame(() => {
                                    if (isProcessingVideo) return; // Already restarted
                                    startVideoProcessing();
                                });
                            } else {
                                showLog('Processed all frames but still missing some QR codes.', 'video');
                                showLog('Try playing the video manually to catch missing frames.', 'video');
                            }
                        }
                    }
                }
            };
            
            // Start processing by seeking to the first frame in the batch
            isWaitingForSeek = true;
            lastSeekTime = Date.now();
            seekToFrame(startFrame);
            
            // Safety check to prevent getting stuck
            // If seek operation doesn't complete within 2 seconds, force continue
            setTimeout(() => {
                if (isWaitingForSeek && Date.now() - lastSeekTime > 2000) {
                    showLog(`Seek timeout at frame ${currentProcessingFrame}, forcing continue`, 'video');
                    isWaitingForSeek = false;
                    currentProcessingFrame++;
                    
                    if (currentProcessingFrame < totalFrames && isProcessingVideo) {
                        setTimeout(processNextFrameBatch, 10);
                    } else {
                        showLog('Video processing complete (with timeouts)', 'video');
                        stopVideoProcessing();
                    }
                }
            }, 2000);
        }

        function seekToFrame(frameIndex) {
            // Check if we need to prioritize areas where QR codes were already found
            if (foundQRTimeRanges.length > 0 && frameIndex > totalFrames * 0.3) {
                // After processing 30% of the video normally, start focusing on promising areas
                
                // Check if we're in a batch that should prioritize QR areas
                if (frameIndex % 20 === 0) { // Every 20 frames
                    // Find closest QR range to current position
                    const currentTime = (frameIndex * processingVideo.duration) / totalFrames;
                    let bestRange = null;
                    let bestDistance = Infinity;
                    
                    for (const range of foundQRTimeRanges) {
                        const midpoint = (range.start + range.end) / 2;
                        const distance = Math.abs(midpoint - currentTime);
                        
                        if (distance < bestDistance) {
                            bestDistance = distance;
                            bestRange = range;
                        }
                    }
                    
                    // If we found a close range, bias our next several frames toward it
                    if (bestRange && bestDistance < processingVideo.duration / 4) {
                        // Calculate a time within this range
                        const rangeWidth = bestRange.end - bestRange.start;
                        const positionInRange = (frameIndex % 10) / 10; // Position 0-1 within range
                        const targetTime = bestRange.start + (rangeWidth * positionInRange);
                        
                        // Use this target time with small jitter
                        const jitter = Math.random() * 0.03;
                        processingVideo.currentTime = Math.min(
                            targetTime + jitter, 
                            processingVideo.duration - 0.1
                        );
                        
                        if (frameIndex % 10 === 0) {
                            showLog(`Focusing on QR region at ${processingVideo.currentTime.toFixed(2)}s`, 'video');
                        }
                        return;
                    }
                }
            }
            
            // Normal timestamp calculation with adaptive frame rate
            let time;
            
            // Use smart distribution of frames - more at the beginning, fewer later
            if (frameIndex < totalFrames * 0.5) {
                // First half of frames: normal distribution
                time = (frameIndex * processingVideo.duration) / totalFrames;
            } else {
                // Second half: exponential distribution to focus more on beginning
                const factor = 1 + (frameIndex / totalFrames) * 2;
                time = (frameIndex * processingVideo.duration) / (totalFrames * factor);
            }
            
            // Add a small random offset to avoid getting stuck on the same frame
            const randomOffset = Math.random() * 0.05; // Up to 50ms jitter
            
            // Validate the time to prevent non-finite error
            if (isFinite(time) && time >= 0 && time <= processingVideo.duration) {
                // Ensure we don't exceed video duration
                const safeTime = Math.min(time + randomOffset, processingVideo.duration - 0.1);
                processingVideo.currentTime = safeTime;
                
                // Log frame position for debugging
                if (frameIndex % 50 === 0) {
                    showLog(`Seeking to frame ${frameIndex}: ${safeTime.toFixed(2)}s`, 'video');
                }
            } else {
                console.warn(`Invalid time value: ${time}, using 0 instead`);
                processingVideo.currentTime = 0;
            }
        }

        // QR code data processing
        function processQrData(data, type = 'live') {
            const now = Date.now();
            
            // More intelligent debounce for QR processing
            // Allow re-processing of the same code after a longer time
            // but immediately accept new codes
            let isRepeat = false;
            if (data === lastQrData) {
                // For very short intervals, always debounce
                if (now - lastQrTime < 300) {
                    return;
                }
                // For medium intervals, only accept critical frames (metadata/set headers) 
                if (now - lastQrTime < 2000) {
                    try {
                        const temp = JSON.parse(data);
                        if (temp.type !== "metadata" && temp.type !== "set_header") {
                            isRepeat = true;
                        }
                    } catch(e) {
                        // If we can't parse, treat as duplicate
                        isRepeat = true;
                    }
                    
                    if (isRepeat) {
                        return;
                    }
                }
                // After 2 seconds, always process even if repeated
            }
            
            lastQrData = data;
            lastQrTime = now;
            
            try {
                let jsonData;
                try {
                    jsonData = JSON.parse(data);
                } catch (err) {
                    // Attempt to extract JSON from any wrapping text
                    const jsonMatch = data.match(/\{.*\}/);
                    if (jsonMatch) {
                        try {
                            jsonData = JSON.parse(jsonMatch[0]);
                        } catch (e) {
                            return; // Still not valid JSON, ignore
                        }
                    } else {
                        return; // Not valid JSON, ignore
                    }
                }
                
                // Process different QR data formats
                
                // Modern format (metadata, set_header, chunk, end)
                if (jsonData.type) {
                    if (jsonData.type === "metadata") {
                        // Log this important event prominently
                        showLog(`🎯 METADATA FRAME DETECTED! File: ${jsonData.file_name || "unknown"}`, type);
                        
                        startReceived = true;
                        
                        // Calculate total chunks from various possible formats
                        let totalChunks = 0;
                        
                        if (jsonData.total_chunks) {
                            // Direct total chunks field
                            totalChunks = jsonData.total_chunks;
                        } else if (jsonData.total_sets && jsonData.chunks_per_set) {
                            // Calculate from sets and chunks per set
                            totalChunks = jsonData.total_sets * jsonData.chunks_per_set;
                        } else if (jsonData.file_size && (jsonData.chunk_size || jsonData.bytes_per_chunk)) {
                            // Calculate from file size and chunk size
                            const chunkSize = jsonData.chunk_size || jsonData.bytes_per_chunk || 500;
                            totalChunks = Math.ceil(jsonData.file_size / (chunkSize * 0.75)); // Approximate for base64 expansion
                        }
                        
                        totalFramesExpected = totalChunks || 0;
                        fileName = jsonData.file_name || "file.dat";
                        fileSize = jsonData.file_size || 0;
                        
                        // Initialize data structures with the correct size
                        framesData = Array(totalFramesExpected).fill('');
                        framesReceived = Array(totalFramesExpected).fill(false);
                        
                        // Detailed log with all available information
                        showLog(`Metadata details: ${fileName}, ${totalFramesExpected} chunks, size: ${formatFileSize(fileSize)}`, type);
                        if (jsonData.total_sets) {
                            showLog(`Organization: ${jsonData.total_sets} sets with ${jsonData.chunks_per_set} chunks per set`, type);
                        }
                        
                        // Update visual display
                        updateGrid(type);
                    }
                    else if (jsonData.type === "chunk" && startReceived) {
                        // Calculate global chunk index
                        let chunkIndex = -1;
                        
                        if (jsonData.chunk_index && jsonData.set_index) {
                            // Format with set_index and chunk_index
                            const setIndex = jsonData.set_index - 1; // 1-indexed to 0-indexed
                            const localChunkIndex = jsonData.chunk_index - 1; // 1-indexed to 0-indexed
                            const chunksPerSet = jsonData.chunks_in_set || 50; // Default from encoder
                            
                            chunkIndex = (setIndex * chunksPerSet) + localChunkIndex;
                        } else if (jsonData.chunk_index) {
                            // Simple format with just chunk_index
                            chunkIndex = jsonData.chunk_index - 1; // 1-indexed to 0-indexed
                        }
                        
                        // Process the chunk if valid index
                        if (chunkIndex >= 0 && chunkIndex < totalFramesExpected) {
                            blinkCell(chunkIndex, type);
                            
                            if (!framesReceived[chunkIndex]) {
                                framesData[chunkIndex] = jsonData.data || '';
                                framesReceived[chunkIndex] = true;
                                
                                const chunkSize = jsonData.data ? jsonData.data.length : 0;
                                showLog(`Chunk ${chunkIndex + 1}/${totalFramesExpected} received (${chunkSize} chars)`, type);
                                
                                // Only update grid occasionally for performance
                                if (chunkIndex % 5 === 0) {
                                    updateGrid(type);
                                }
                                
                                // Check if all frames received
                                const missingCount = framesReceived.filter(received => !received).length;
                                const receivedCount = totalFramesExpected - missingCount;
                                
                                if (receivedCount === totalFramesExpected) {
                                    showLog('💯 All chunks received!', type);
                                    updateGrid(type); // Final update
                                    
                                    if (type === 'live') {
                                        assembleAndDownloadFile(type);
                                    }
                                } else if (receivedCount % 10 === 0) {
                                    // Log progress at regular intervals
                                    showLog(`Progress: ${receivedCount}/${totalFramesExpected} chunks (${Math.round(receivedCount/totalFramesExpected*100)}%)`, type);
                                }
                            }
                        }
                    }
                }
                // Legacy/old format (marker-based)
                else if (jsonData.marker) {
                    // Process start marker
                    if (jsonData.marker === "###QRSTART###" && !startReceived) {
                        startReceived = true;
                        totalFramesExpected = jsonData.frames;
                        fileName = jsonData.file;
                        fileSize = jsonData.size || 0;
                        
                        framesData = Array(totalFramesExpected).fill('');
                        framesReceived = Array(totalFramesExpected).fill(false);
                        
                        showLog(`Start marker: ${fileName}, ${totalFramesExpected} frames, size: ${fileSize}`, type);
                        updateGrid(type);
                    }
                    // Process data marker
                    else if (jsonData.marker === "#DATA#" && startReceived) {
                        const frameIndex = jsonData.current - 1;
                        
                        blinkCell(frameIndex, type);
                        
                        if (frameIndex < framesData.length && !framesReceived[frameIndex]) {
                            framesData[frameIndex] = jsonData.contents;
                            framesReceived[frameIndex] = true;
                            
                            showLog(`Frame ${frameIndex + 1}/${totalFramesExpected} received (${jsonData.contents.length} chars)`, type);
                            updateGrid(type);
                            
                            // Check if all frames received
                            if (framesReceived.every(Boolean)) {
                                showLog('All frames received!', type);
                                if (type === 'live') {
                                    assembleAndDownloadFile(type);
                                }
                            }
                        }
                    }
                }
            } catch (err) {
                console.error("Error processing QR data:", err);
                if (err.message !== lastQrError) {
                    // Only log new errors to avoid spam
                    showLog(`Error processing QR data: ${err.message}`, type);
                    lastQrError = err.message;
                }
            }
        }
        
        // Variable to track last error message
        let lastQrError = '';
        
        // Format file size for display
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' bytes';
            else if (bytes < 1048576) return (bytes / 1024).toFixed(2) + ' KB';
            else if (bytes < 1073741824) return (bytes / 1048576).toFixed(2) + ' MB';
            else return (bytes / 1073741824).toFixed(2) + ' GB';
        }

        function assembleAndDownloadFile(type) {
            try {
                // Combine all data chunks
                const base64Data = framesData.join('');
                showLog(`Combined base64 data: ${base64Data.length} chars`, type);
                
                // Convert base64 to binary
                const rawData = atob(base64Data);
                showLog(`Decoded data length: ${rawData.length} bytes`, type);
                
                // Create typed array
                const bytes = new Uint8Array(rawData.length);
                for (let i = 0; i < rawData.length; i++) {
                    bytes[i] = rawData.charCodeAt(i);
                }
                
                // Verify size if provided
                if (fileSize > 0 && bytes.length !== fileSize) {
                    showLog(`Size mismatch: got ${bytes.length}, expected ${fileSize}`, type);
                }
                
                // Create blob and download
                const blob = new Blob([bytes], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName.replace(/\.b64$/, '');
                a.click();
                
                URL.revokeObjectURL(url);
                showLog(`File downloaded: ${fileName}`, type);
                
                if (type === 'live') {
                    stopLiveScanning();
                }
            } catch (err) {
                showLog(`Error assembling file: ${err.message}`, type);
            }
        }

        // Event listeners
        startLiveBtn.addEventListener('click', startLiveScanning);
        stopLiveBtn.addEventListener('click', stopLiveScanning);
        
        openVideoBtn.addEventListener('click', () => fileInput.click());
        processVideoBtn.addEventListener('click', startVideoProcessing);
        stopProcessingBtn.addEventListener('click', stopVideoProcessing);
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFileInput(e.target.files[0]);
            }
        });

        // Drag and drop support
        dropzone.addEventListener('click', () => fileInput.click());
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropzone.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
        });
        
        dropzone.addEventListener('dragover', () => {
            dropzone.style.backgroundColor = '#e6e6e6';
        });
        
        dropzone.addEventListener('dragleave', () => {
            dropzone.style.backgroundColor = '#f9f9f9';
        });
        
        dropzone.addEventListener('drop', (e) => {
            dropzone.style.backgroundColor = '#f9f9f9';
            
            if (e.dataTransfer.files.length > 0) {
                handleFileInput(e.dataTransfer.files[0]);
            }
        });

        // Add manual frame capture from video playback
        processingVideo.addEventListener('play', () => {
            // Only activate when not actively processing
            if (!isProcessingVideo && processingVideo.src) {
                const captureInterval = setInterval(() => {
                    if (processingVideo.paused || processingVideo.ended || isProcessingVideo) {
                        clearInterval(captureInterval);
                        return;
                    }
                    
                    // Capture the current frame during normal playback
                    canvas.width = processingVideo.videoWidth;
                    canvas.height = processingVideo.videoHeight;
                    ctx.drawImage(processingVideo, 0, 0);
                    
                    capturedFramesCount++;
                    videoFramesCounter.textContent = capturedFramesCount;
                    
                    try {
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const qrCode = jsQR(imageData.data, imageData.width, imageData.height, {
                            inversionAttempts: 'dontInvert'
                        });
                        
                        if (qrCode) {
                            framesCapturedWithQR++;
                            videoQrCounter.textContent = framesCapturedWithQR;
                            processQrData(qrCode.data, 'video');
                            
                            // Visual feedback
                            ctx.strokeStyle = 'lime';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                            ctx.lineTo(qrCode.location.topRightCorner.x, qrCode.location.topRightCorner.y);
                            ctx.lineTo(qrCode.location.bottomRightCorner.x, qrCode.location.bottomRightCorner.y);
                            ctx.lineTo(qrCode.location.bottomLeftCorner.x, qrCode.location.bottomLeftCorner.y);
                            ctx.lineTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                            ctx.stroke();
                        }
                    } catch (err) {
                        // Silent catch
                    }
                }, 200); // Capture 5 frames per second during normal playback
            }
        });
        
        // Initialize
        showLog('Ready to scan. Click "Start Camera" to begin.', 'live');
        showLog('Ready to process. Select a video file to begin.', 'video');
    </script>
</body>

</html>