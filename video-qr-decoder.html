// 1. Enhanced QR Data Processing for Set-by-Set Metadata

// Define data structures for set-based decoding
let setsData = []; // Will store data about individual sets
let setsReceived = []; // Will track which sets are fully received

// Global variable for tracking chunk counts per set (moved to global scope)
let chunksPerSelectedSet = [];

// Initialize support for enhanced processing on page load
document.addEventListener('DOMContentLoaded', function() {
    window.setsData = [];
    window.setsReceived = [];
    window.chunksPerSelectedSet = [];
    window.setMetadataReceived = [];
});

function processQrData(data, type = 'live') {
    const now = Date.now();
    
    // More intelligent debounce for QR processing with special handling for metadata
    let isRepeat = false;
    if (data === lastQrData) {
        // For very short intervals, always debounce
        if (now - lastQrTime < 300) {
            return;
        }
        // For medium intervals, only accept critical frames (metadata) 
        if (now - lastQrTime < 2000) {
            try {
                const temp = JSON.parse(data);
                if (!temp.type || (temp.type !== "global_metadata" && temp.type !== "set_metadata")) {
                    isRepeat = true;
                }
            } catch(e) {
                // If we can't parse, treat as duplicate
                isRepeat = true;
            }
            
            if (isRepeat) {
                return;
            }
        }
        // After 2 seconds, always process even if repeated
    }
    
    lastQrData = data;
    lastQrTime = now;
    
    try {
        let jsonData;
        try {
            jsonData = JSON.parse(data);
        } catch (err) {
            // Attempt to extract JSON from any wrapping text
            const jsonMatch = data.match(/\{.*\}/);
            if (jsonMatch) {
                try {
                    jsonData = JSON.parse(jsonMatch[0]);
                } catch (e) {
                    return; // Still not valid JSON, ignore
                }
            } else {
                return; // Not valid JSON, ignore
            }
        }
        
        // Check for protocol version
        const protocolVersion = jsonData.version || "1.0";
        
        // Process different QR data formats
        
        // Modern format (metadata, set_metadata, chunk, end) - Version 2.0
        if (jsonData.type) {
            // Process global metadata
            if (jsonData.type === "global_metadata" || 
                (jsonData.type === "metadata" && protocolVersion === "2.0")) {
                
                // Log this important event prominently
                showLog(`üéØ GLOBAL METADATA DETECTED! File: ${jsonData.file_name || "unknown"}`, type);
                
                // Create a file identifier using name, size and timestamp
                const newFileName = jsonData.file_name || "file.dat";
                const newFileSize = jsonData.file_size || 0;
                const fileId = `${newFileName}_${newFileSize}`;
                
                // Check if we've seen this file before
                const isKnownFile = fileId === currentFileId && fileHistory[fileId];
                
                if (isKnownFile) {
                    // We're seeing the same file again
                    showLog(`üîÑ Detecting SAME FILE again: ${newFileName}`, type);
                    showLog(`Continuing where we left off - focusing on missing frames`, type);
                    
                    // Restore file data from history
                    startReceived = true;
                    totalFramesExpected = fileHistory[fileId].totalFrames;
                    fileName = newFileName;
                    fileSize = newFileSize;
                    framesData = [...fileHistory[fileId].framesData];
                    framesReceived = [...fileHistory[fileId].framesReceived];
                    qrGridSize = fileHistory[fileId].qrGridSize || 1;
                    chunksPerSelectedSet = fileHistory[fileId].chunksPerSelectedSet || [];
                    setsData = fileHistory[fileId].setsData || [];
                    setsReceived = fileHistory[fileId].setsReceived || [];
                    
                    // Count how many frames we're missing
                    const missingCount = framesReceived.filter(received => !received).length;
                    showLog(`Already have ${totalFramesExpected - missingCount}/${totalFramesExpected} chunks (${missingCount} missing)`, type);
                    
                    // Check for incomplete sets
                    if (setsReceived.length > 0) {
                        const incompleteSets = setsReceived
                            .map((complete, idx) => complete ? null : idx)
                            .filter(idx => idx !== null);
                        
                        if (incompleteSets.length > 0) {
                            showLog(`Missing complete sets: ${incompleteSets.map(i => i+1).join(', ')}`, type);
                        }
                    }
                    
                    // If file is already complete, just download it
                    if (missingCount === 0) {
                        showLog(`‚úÖ All chunks already received for this file!`, type);
                        isFileComplete = true;
                        if (type === 'video') {
                            assembleAndDownloadFile(type);
                        }
                    } else {
                        isFileComplete = false;
                        showLog(`üîç Looking for the ${missingCount} missing chunks...`, type);
                    }
                } else {
                    // New file - start fresh
                    startReceived = true;
                    currentFileId = fileId;
                    isFileComplete = false;
                    
                    // Store grid size information
                    if (jsonData.qr_grid_size) {
                        qrGridSize = parseInt(jsonData.qr_grid_size) || 1;
                        if (qrGridSize > 1) {
                            showLog(`QR Grid Layout: ${qrGridSize} QRs per frame detected from metadata`, type);
                        }
                    }
                    
                    // Initialize set data arrays
                    if (jsonData.total_selected_sets) {
                        const setCount = jsonData.total_selected_sets;
                        setsData = Array(setCount).fill(null);
                        setsReceived = Array(setCount).fill(false);
                        
                        showLog(`File organized in ${setCount} sets`, type);
                        
                        // Track which sets need metadata
                        window.setMetadataReceived = Array(setCount).fill(false);
                    }
                    
                    // Store chunks per set information
                    if (jsonData.chunks_per_selected_set) {
                        chunksPerSelectedSet = [...jsonData.chunks_per_selected_set];
                        showLog(`Set sizes: ${chunksPerSelectedSet.join(', ')} chunks`, type);
                    }
                    
                    // Calculate total chunks
                    let totalChunks = 0;
                    
                    if (jsonData.actual_chunks_count) {
                        totalChunks = jsonData.actual_chunks_count;
                    } else if (jsonData.total_chunks) {
                        totalChunks = jsonData.total_chunks;
                    } else if (chunksPerSelectedSet.length > 0) {
                        // Calculate from set information
                        totalChunks = chunksPerSelectedSet.reduce((sum, count) => sum + count, 0);
                    } else if (jsonData.total_sets && jsonData.chunks_per_set) {
                        // Legacy calculation
                        totalChunks = jsonData.total_selected_sets * jsonData.chunks_per_set;
                    }
                    
                    totalFramesExpected = totalChunks;
                    fileName = newFileName;
                    fileSize = newFileSize;
                    
                    // Initialize data structures
                    framesData = Array(totalFramesExpected).fill('');
                    framesReceived = Array(totalFramesExpected).fill(false);
                    
                    // Display metadata information
                    showLog(`Metadata details: ${fileName}, ${totalFramesExpected} chunks, size: ${formatFileSize(fileSize)}`, type);
                    
                    // Additional organization details
                    if (jsonData.total_selected_sets) {
                        showLog(`File organized in ${jsonData.total_selected_sets} sets`, type);
                    }
                    
                    // Show file queue information if available
                    if (jsonData.file_index && jsonData.total_files) {
                        showLog(`File ${jsonData.file_index} of ${jsonData.total_files} in sender's queue`, type);
                    }
                }
                
                // Save file data to history
                fileHistory[fileId] = {
                    fileName: fileName,
                    fileSize: fileSize,
                    totalFrames: totalFramesExpected,
                    framesData: [...framesData],
                    framesReceived: [...framesReceived],
                    qrGridSize: qrGridSize,
                    chunksPerSelectedSet: [...chunksPerSelectedSet],
                    setsData: [...setsData],
                    setsReceived: [...setsReceived],
                    firstSeen: Date.now(),
                    receivedCount: framesReceived.filter(Boolean).length
                };
                
                // Update visual display
                updateGrid(type);
                
                // Estimate transfer time
                if (detectedFrameRates.length > 0) {
                    const avgFrameRate = detectedFrameRates.reduce((sum, rate) => sum + rate, 0) / detectedFrameRates.length;
                    const estimatedSeconds = totalFramesExpected / avgFrameRate;
                    showLog(`Estimated time to receive all chunks: ${(estimatedSeconds / 60).toFixed(1)} minutes at ${avgFrameRate.toFixed(1)} fps`, type);
                }
            }
            // Process set-specific metadata
            else if (jsonData.type === "set_metadata") {
                const setIndex = jsonData.set_index - 1; // Convert to 0-based
                
                showLog(`üì¶ SET METADATA received for Set ${jsonData.set_index}`, type);
                
                if (setIndex >= 0 && setIndex < setsData.length) {
                    // Store metadata for this set
                    setsData[setIndex] = {
                        index: setIndex,
                        chunksCount: jsonData.chunks_in_set,
                        globalOffset: jsonData.global_chunk_offset || 0,
                        fileName: jsonData.file_name,
                        timestamp: jsonData.timestamp
                    };
                    
                    // Mark that we've received this set's metadata
                    if (window.setMetadataReceived && setIndex < window.setMetadataReceived.length) {
                        window.setMetadataReceived[setIndex] = true;
                    }
                    
                    // Update chunksPerSelectedSet if not already set
                    if (!chunksPerSelectedSet[setIndex]) {
                        chunksPerSelectedSet[setIndex] = jsonData.chunks_in_set;
                        
                        // Update file history
                        if (currentFileId && fileHistory[currentFileId]) {
                            fileHistory[currentFileId].chunksPerSelectedSet = [...chunksPerSelectedSet];
                        }
                    }
                    
                    showLog(`Set ${jsonData.set_index} has ${jsonData.chunks_in_set} chunks, offset: ${jsonData.global_chunk_offset || 0}`, type);
                    
                    // Update file history with set data
                    if (currentFileId && fileHistory[currentFileId]) {
                        fileHistory[currentFileId].setsData = [...setsData];
                    }
                } else {
                    showLog(`‚ö†Ô∏è Invalid set index: ${setIndex}`, type, true);
                }
            }
            // Process chunk data
            else if (jsonData.type === "chunk" && startReceived) {
                // Calculate global chunk index
                let chunkIndex = -1;
                
                // Prioritize global_chunk_index if provided
                if (jsonData.global_chunk_index !== undefined) {
                    chunkIndex = jsonData.global_chunk_index;
                }
                // Next try with set_index and chunk_index
                else if (jsonData.set_index && jsonData.chunk_index) {
                    const setIndex = jsonData.set_index - 1; // 1-indexed to 0-indexed
                    const localChunkIndex = jsonData.chunk_index - 1; // 1-indexed to 0-indexed
                    
                    // Use set metadata if available
                    if (setsData[setIndex] && setsData[setIndex].globalOffset !== undefined) {
                        chunkIndex = setsData[setIndex].globalOffset + localChunkIndex;
                    }
                    // Fall back to chunksPerSelectedSet
                    else if (chunksPerSelectedSet && chunksPerSelectedSet.length > 0) {
                        let offset = 0;
                        for (let i = 0; i < setIndex; i++) {
                            offset += (i < chunksPerSelectedSet.length) ? chunksPerSelectedSet[i] : 0;
                        }
                        chunkIndex = offset + localChunkIndex;
                    }
                    // Last resort: use chunks_in_set from the current chunk
                    else {
                        const chunksPerSet = jsonData.chunks_in_set || 50;
                        chunkIndex = (setIndex * chunksPerSet) + localChunkIndex;
                    }
                }
                
                // Process the chunk if valid index
                if (chunkIndex >= 0 && chunkIndex < totalFramesExpected) {
                    blinkCell(chunkIndex, type);
                    
                    if (!framesReceived[chunkIndex]) {
                        framesData[chunkIndex] = jsonData.data || '';
                        framesReceived[chunkIndex] = true;
                        
                        // Update chunk count and UI
                        const chunkSize = jsonData.data ? jsonData.data.length : 0;
                        showLog(`Chunk ${chunkIndex + 1}/${totalFramesExpected} received (${chunkSize} chars)`, type);
                        
                        // Update the file history for this chunk
                        if (currentFileId && fileHistory[currentFileId]) {
                            fileHistory[currentFileId].framesData[chunkIndex] = jsonData.data || '';
                            fileHistory[currentFileId].framesReceived[chunkIndex] = true;
                            fileHistory[currentFileId].receivedCount = fileHistory[currentFileId].framesReceived.filter(Boolean).length;
                            fileHistory[currentFileId].lastUpdated = Date.now();
                        }
                        
                        // Check if this set is now complete
                        if (jsonData.set_index) {
                            const setIndex = jsonData.set_index - 1;
                            const setComplete = checkSetCompletion(setIndex, type);
                            
                            if (setComplete) {
                                showLog(`‚úÖ Set ${jsonData.set_index} is now complete!`, type);
                                setsReceived[setIndex] = true;
                                
                                // Update file history
                                if (currentFileId && fileHistory[currentFileId]) {
                                    fileHistory[currentFileId].setsReceived = [...setsReceived];
                                }
                            }
                        }
                        
                        // Update grid every few chunks for performance
                        if (chunkIndex % 5 === 0) {
                            updateGrid(type);
                        }
                        
                        // Check if all frames received
                        const missingCount = framesReceived.filter(received => !received).length;
                        const receivedCount = totalFramesExpected - missingCount;
                        
                        if (receivedCount === totalFramesExpected) {
                            showLog('üíØ All chunks received!', type);
                            updateGrid(type); // Final update
                            
                            // Mark file as complete
                            isFileComplete = true;
                            if (currentFileId && fileHistory[currentFileId]) {
                                fileHistory[currentFileId].isComplete = true;
                            }
                            
                            if (type === 'live') {
                                assembleAndDownloadFile(type);
                            }
                        } else if (receivedCount % 10 === 0) {
                            // Log progress periodically
                            showLog(`Progress: ${receivedCount}/${totalFramesExpected} chunks (${Math.round(receivedCount/totalFramesExpected*100)}%)`, type);
                        }
                    } else {
                        // Already have this chunk - skip verbose logging
                        if (chunkIndex % 20 === 0) {
                            showLog(`Skipping already received chunk ${chunkIndex + 1}/${totalFramesExpected}`, type);
                        }
                    }
                } else {
                    // Invalid chunk index - log warning
                    showLog(`‚ö†Ô∏è Invalid chunk index ${chunkIndex} (max: ${totalFramesExpected-1})`, type, true);
                }
            }
            // Process end frame
            else if (jsonData.type === "end" && startReceived) {
                showLog(`üìã End frame received - verifying completeness`, type);
                
                // Check for verification data
                if (jsonData.total_chunks_sent !== undefined) {
                    const reportedChunks = jsonData.total_chunks_sent;
                    const receivedChunks = framesReceived.filter(Boolean).length;
                    
                    showLog(`Chunks reported in end frame: ${reportedChunks}`, type);
                    showLog(`Chunks actually received: ${receivedChunks}`, type);
                    
                    // Check for incompletely received sets
                    if (setsReceived.length > 0) {
                        const incompleteSets = setsReceived
                            .map((received, idx) => received ? null : idx + 1)
                            .filter(idx => idx !== null);
                        
                        if (incompleteSets.length > 0) {
                            showLog(`‚ö†Ô∏è Missing sets: ${incompleteSets.join(', ')}`, type, true);
                            showLog(`Please ask sender to resend sets: ${incompleteSets.join(', ')}`, type);
                        }
                    }
                    
                    // Check if all frames are received
                    const missingCount = framesReceived.filter(received => !received).length;
                    
                    if (missingCount === 0) {
                        showLog(`‚úÖ ALL CHUNKS VERIFIED - Transfer complete!`, type);
                        isFileComplete = true;
                        
                        // Mark as complete in history
                        if (currentFileId && fileHistory[currentFileId]) {
                            fileHistory[currentFileId].isComplete = true;
                        }
                        
                        // Assemble and download
                        assembleAndDownloadFile(type);
                    } else {
                        // Some chunks still missing
                        showLog(`‚ö†Ô∏è Transfer not complete - still missing ${missingCount} chunks`, type);
                        
                        // Generate missing chunks report
                        const missingChunks = createMissingChunksReport();
                        showLog(missingChunks, type);
                    }
                }
            }
            else if (jsonData.type === "metadata" && protocolVersion !== "2.0") {
                // Legacy metadata frame handling (version 1.0)
                // Process similar to global_metadata but with slightly different structure
                
                // Log this important event prominently
                showLog(`üéØ METADATA FRAME DETECTED! File: ${jsonData.file_name || "unknown"}`, type);
                
                // Create a file identifier using name, size and timestamp if available
                const newFileName = jsonData.file_name || "file.dat";
                const newFileSize = jsonData.file_size || 0;
                
                // Generate a unique ID for this file based on name and size
                const fileId = `${newFileName}_${newFileSize}`;
                
                // Check if we've seen this file before and continue with regular processing
                // ...rest of legacy metadata processing
                // (Same code as before, not duplicating it here)
            }
        }
        // Legacy/old format (marker-based)
        else if (jsonData.marker) {
            // Legacy format handling (keep as is)
            // ...
        }
    } catch (err) {
        console.error("Error processing QR data:", err);
        if (err.message !== lastQrError) {
            // Only log new errors to avoid spam
            showLog(`Error processing QR data: ${err.message}`, type);
            lastQrError = err.message;
        }
    }
}

// Helper function to check if a set is complete
function checkSetCompletion(setIndex, type = 'live') {
    if (!setsData[setIndex]) {
        return false;
    }
    
    const setInfo = setsData[setIndex];
    const globalOffset = setInfo.globalOffset || 0;
    const chunksCount = setInfo.chunksCount || chunksPerSelectedSet[setIndex] || 0;
    
    if (chunksCount === 0) {
        return false;
    }
    
    // Check if all chunks in this set are received
    for (let i = 0; i < chunksCount; i++) {
        const globalIndex = globalOffset + i;
        if (!framesReceived[globalIndex]) {
            return false;
        }
    }
    
    return true;
}

// Helper function to create a formatted report of missing chunks
function createMissingChunksReport() {
    const missing = framesReceived
        .map((received, idx) => received ? null : idx)
        .filter(idx => idx !== null);
    
    if (missing.length === 0) {
        return "No missing chunks!";
    }
    
    // Group missing chunks by set if set information is available
    if (setsData.length > 0 && chunksPerSelectedSet.length > 0) {
        const missingBySet = {};
        
        missing.forEach(chunkIdx => {
            // Find which set this chunk belongs to
            let targetSet = -1;
            let localIdx = -1;
            let runningOffset = 0;
            
            for (let setIdx = 0; setIdx < chunksPerSelectedSet.length; setIdx++) {
                const setSize = chunksPerSelectedSet[setIdx] || 0;
                if (chunkIdx >= runningOffset && chunkIdx < runningOffset + setSize) {
                    targetSet = setIdx;
                    localIdx = chunkIdx - runningOffset;
                    break;
                }
                runningOffset += setSize;
            }
            
            if (targetSet !== -1) {
                if (!missingBySet[targetSet]) {
                    missingBySet[targetSet] = [];
                }
                missingBySet[targetSet].push(localIdx);
            }
        });
        
        // Create a formatted report
        let report = "Missing chunks by set:\n";
        Object.keys(missingBySet).forEach(setIdx => {
            const setNum = parseInt(setIdx) + 1;
            const count = missingBySet[setIdx].length;
            const totalInSet = chunksPerSelectedSet[setIdx] || 0;
            const pct = Math.round((count / totalInSet) * 100);
            
            report += `Set ${setNum}: ${count}/${totalInSet} chunks missing (${pct}%)\n`;
            
            // If few chunks missing, list them specifically
            if (count <= 10) {
                report += `  Missing indices: ${missingBySet[setIdx].map(i => i+1).join(', ')}\n`;
            }
        });
        
        return report;
    } else {
        // Simple report of missing chunks
        if (missing.length <= 20) {
            return `Missing chunks: ${missing.map(i => i+1).join(', ')}`;
        } else {
            return `Missing ${missing.length} chunks (first 10: ${missing.slice(0, 10).map(i => i+1).join(', ')}...)`;
        }
    }
}

// 2. Full-Screen Camera Initialization for Decoder

function initializeFullScreenCamera() {
    // Make the scan region fill most of the screen initially
    const scanRegion = document.querySelector('.scan-region');
    const videoContainer = document.querySelector('.video-container');
    
    if (!scanRegion || !videoContainer) return;
    
    // Set initial size to be large (80% of container)
    const initialSetup = function() {
        try {
            const containerRect = videoContainer.getBoundingClientRect();
            const width = Math.min(containerRect.width * 0.8, 600);
            const height = Math.min(containerRect.height * 0.8, 600);
            
            // Center the scan region
            scanRegion.style.width = `${width}px`;
            scanRegion.style.height = `${height}px`;
            scanRegion.style.left = '50%';
            scanRegion.style.top = '50%';
            scanRegion.style.transform = 'translate(-50%, -50%)';
            
            // Style the scan region for better visibility
            scanRegion.style.border = '3px solid rgba(255, 0, 0, 0.7)';
            scanRegion.style.boxShadow = '0 0 0 2000px rgba(0, 0, 0, 0.3)';
            scanRegion.style.transition = 'all 0.3s ease';
            
            // Update info display
            const infoDisplay = scanRegion.querySelector('.scan-region-info');
            if (infoDisplay) {
                infoDisplay.style.background = 'rgba(0, 0, 0, 0.7)';
                infoDisplay.style.color = 'white';
                infoDisplay.style.padding = '5px';
                infoDisplay.style.borderRadius = '3px';
                infoDisplay.style.opacity = '1';
                infoDisplay.textContent = `Scan area: ${Math.round(width)}√ó${Math.round(height)}px`;
            }
            
            // Log setup
            showLog(`Scan region initialized to ${Math.round(width)}√ó${Math.round(height)}px`, 'live');
        } catch (err) {
            console.error('Error setting up scan region:', err);
        }
    };
    
    // Add preset size buttons
    function addSizePresets() {
        const presetsContainer = document.createElement('div');
        presetsContainer.style.display = 'flex';
        presetsContainer.style.gap = '10px';
        presetsContainer.style.marginTop = '10px';
        presetsContainer.style.justifyContent = 'center';
        
        // Add preset buttons
        const presets = [
            { name: 'Small', size: 0.5 },
            { name: 'Medium', size: 0.7 },
            { name: 'Large', size: 0.9 }
        ];
        
        presets.forEach(preset => {
            const button = document.createElement('button');
            button.textContent = preset.name;
            button.style.padding = '5px 10px';
            button.style.backgroundColor = '#333';
            button.style.color = 'white';
            button.style.border = 'none';
            button.style.borderRadius = '3px';
            button.style.cursor = 'pointer';
            
            button.addEventListener('click', function() {
                const containerRect = videoContainer.getBoundingClientRect();
                const width = containerRect.width * preset.size;
                const height = containerRect.height * preset.size;
                
                scanRegion.style.width = `${width}px`;
                scanRegion.style.height = `${height}px`;
                scanRegion.style.left = '50%';
                scanRegion.style.top = '50%';
                scanRegion.style.transform = 'translate(-50%, -50%)';
                
                // Update info display
                const infoDisplay = scanRegion.querySelector('.scan-region-info');
                if (infoDisplay) {
                    infoDisplay.textContent = `Scan area: ${Math.round(width)}√ó${Math.round(height)}px`;
                }
                
                showLog(`Scan region resized to ${preset.name} (${Math.round(width)}√ó${Math.round(height)}px)`, 'live');
            });
            
            presetsContainer.appendChild(button);
        });
        
        // Add the presets container before the video container
        const controls = document.querySelector('#live-tab .controls');
        if (controls) {
            controls.appendChild(presetsContainer);
        }
    }
    
    // Call setup after a short delay to ensure elements are rendered
    setTimeout(initialSetup, 500);
    
    // Add size presets
    setTimeout(addSizePresets, 600);
    
    // Add a resize observer to adjust scan region when window size changes
    const resizeObserver = new ResizeObserver(entries => {
        // Only update if the transform is still centered (user hasn't moved it)
        if (scanRegion.style.transform.includes('translate(-50%, -50%)')) {
            initialSetup();
        }
    });
    
    resizeObserver.observe(videoContainer);
}

// 3. Enhanced Visual UI with Set-Based Visualization

// Update the grid to show set-based information
function updateGrid(type = 'live') {
    const grid = type === 'live' ? liveGrid : videoGrid;
    grid.innerHTML = '';
    
    if (totalFramesExpected <= 0) return;
    
    // Add class for very large frame counts
    if (totalFramesExpected > 1000) {
        grid.classList.add('large-count');
    } else {
        grid.classList.remove('large-count');
    }
    
    // Ensure grid can grow in height with auto-scroll
    grid.style.maxHeight = '40vh';
    grid.style.overflowY = 'auto';
    
    // Calculate cell size based on frame count
    let cellSize;
    if (totalFramesExpected > 10000) {
        cellSize = 6;
    } else if (totalFramesExpected > 5000) {
        cellSize = 8;
    } else if (totalFramesExpected > 1000) {
        cellSize = 10;
    } else if (totalFramesExpected > 500) {
        cellSize = 12;
    } else {
        cellSize = Math.min(25, Math.max(15, Math.floor(grid.clientWidth / Math.min(totalFramesExpected, 20))));
    }
    
    const columns = Math.floor(grid.clientWidth / cellSize);
    grid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
    grid.style.setProperty('--cell-size', `${cellSize}px`);
    
    // Create a document fragment for better performance
    const fragment = document.createDocumentFragment();
    
    // Check if we have set data to show hierarchical view
    const hasSetInfo = setsData.length > 0 && chunksPerSelectedSet.length > 0;
    
    if (hasSetInfo) {
        // Add a container for sets
        const setsContainer = document.createElement('div');
        setsContainer.className = 'sets-container';
        setsContainer.style.display = 'flex';
        setsContainer.style.flexDirection = 'column';
        setsContainer.style.gap = '15px';
        setsContainer.style.width = '100%';
        setsContainer.style.padding = '10px 0';
        
        // Add a title for the sets view
        const setsTitle = document.createElement('div');
        setsTitle.style.fontSize = '14px';
        setsTitle.style.fontWeight = 'bold';
        setsTitle.style.color = '#fff';
        setsTitle.style.marginBottom = '5px';
        setsTitle.textContent = 'File Sets Progress';
        setsContainer.appendChild(setsTitle);
        
        // Create a set card for each set
        let setIndex = 0;
        let globalChunkOffset = 0;
        
        for (const setSize of chunksPerSelectedSet) {
            if (!setSize) continue; // Skip empty sets
            
            // Create a set card
            const setCard = document.createElement('div');
            setCard.className = 'set-card';
            setCard.style.backgroundColor = '#1a1a1a';
            setCard.style.borderRadius = '5px';
            setCard.style.padding = '10px';
            setCard.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
            
            // Set header with information
            const setHeader = document.createElement('div');
            setHeader.style.display = 'flex';
            setHeader.style.justifyContent = 'space-between';
            setHeader.style.alignItems = 'center';
            setHeader.style.marginBottom = '10px';
            
            // Set title with info
            const setTitle = document.createElement('div');
            
            // Check if set metadata received
            const metadataReceived = window.setMetadataReceived ? 
                                     window.setMetadataReceived[setIndex] : false;
            
            // Count received chunks for this set
            let receivedInSet = 0;
            for (let i = 0; i < setSize; i++) {
                if (framesReceived[globalChunkOffset + i]) {
                    receivedInSet++;
                }
            }
            
            // Calculate completion percentage
            const completionPct = Math.round((receivedInSet / setSize) * 100);
            
            // Title with completion info
            setTitle.innerHTML = `<strong>Set ${setIndex + 1}</strong> 
                                  <span style="color: ${metadataReceived ? '#4CAF50' : '#ff9800'}">
                                      ${metadataReceived ? '‚úì' : '‚ö†Ô∏è'} Metadata
                                  </span> - 
                                  <span style="color: ${receivedInSet === setSize ? '#4CAF50' : '#ff9800'}">
                                      ${receivedInSet}/${setSize} chunks (${completionPct}%)
                                  </span>`;
            setTitle.style.color = '#fff';
            setTitle.style.fontSize = '13px';
            
            setHeader.appendChild(setTitle);
            
            // Add progress bar
            const progressContainer = document.createElement('div');
            progressContainer.style.width = '100%';
            progressContainer.style.height = '10px';
            progressContainer.style.backgroundColor = '#333';
            progressContainer.style.borderRadius = '5px';
            progressContainer.style.overflow = 'hidden';
            
            const progressBar = document.createElement('div');
            progressBar.style.height = '100%';
            progressBar.style.width = `${completionPct}%`;
            progressBar.style.backgroundColor = receivedInSet === setSize ? '#4CAF50' : '#ff9800';
            
            progressContainer.appendChild(progressBar);
            
            // Add set components to the card
            setCard.appendChild(setHeader);
            setCard.appendChild(progressContainer);
            
            // Add to the container
            setsContainer.appendChild(setCard);
            
            // Move to next set
            setIndex++;
            globalChunkOffset += setSize;
        }
        
        // Add the sets container to the fragment
        fragment.appendChild(setsContainer);
        
        // Add horizontal divider
        const divider = document.createElement('div');
        divider.style.width = '100%';
        divider.style.height = '1px';
        divider.style.backgroundColor = '#333';
        divider.style.margin = '15px 0';
        fragment.appendChild(divider);
    }
    
    // Add cells for individual chunks
    // For very large numbers, group them
    if (totalFramesExpected > 2000) {
        // Use a grouped approach for better performance
        const groupSize = Math.ceil(totalFramesExpected / 500);
        
        for (let i = 0; i < totalFramesExpected; i += groupSize) {
            const endIdx = Math.min(i + groupSize - 1, totalFramesExpected - 1);
            
            // Calculate received count
            let receivedInGroup = 0;
            for (let j = i; j <= endIdx; j++) {
                if (framesReceived[j]) receivedInGroup++;
            }
            
            // Create a group cell
            const cell = document.createElement('div');
            cell.className = 'grid-cell';
            cell.setAttribute('data-start', i + 1);
            cell.setAttribute('data-end', endIdx + 1);
            
            // Calculate completion percentage
            const groupCompletionPct = Math.round((receivedInGroup / (endIdx - i + 1)) * 100);
            
            // Visual styling based on completion
            if (receivedInGroup === endIdx - i + 1) {
                // Fully complete
                cell.classList.add('received');
            } else if (receivedInGroup > 0) {
                // Partially complete - create a gradient
                cell.style.background = `linear-gradient(to right, #4CAF50 ${groupCompletionPct}%, darkred ${groupCompletionPct}%)`;
            }
            
            // Tooltip
            cell.setAttribute('title', `Chunks ${i+1}-${endIdx+1}: ${receivedInGroup}/${endIdx-i+1} received (${groupCompletionPct}%)`);
            
            fragment.appendChild(cell);
        }
    } else {
        // Standard approach for reasonable numbers of frames
        for (let i = 0; i < totalFramesExpected; i++) {
            const cell = document.createElement('div');
            cell.className = 'grid-cell';
            cell.setAttribute('data-index', i + 1);
            
            // For smaller cells, use color-only approach
            if (cellSize < 16) {
                cell.textContent = '';
            } else {
                cell.textContent = i + 1;
            }
            
            if (framesReceived[i]) {
                cell.classList.add('received');
            } else if (startReceived && totalFramesExpected > 0 && currentFileId) {
                // Highlight missing frames
                cell.classList.add('missing');
            }
            
            // Tooltip with frame number
            cell.setAttribute('title', `Chunk ${i + 1}`);
            
            // Store cell reference for faster blinking
            const cellId = `cell-${type}-${i}`;
            cell.id = cellId;
            
            fragment.appendChild(cell);
        }
    }
    
    // Add all cells
    grid.appendChild(fragment);
    
    // Add counter for missing frames
    const missingCount = framesReceived.filter(received => !received).length;
    const statsDiv = document.createElement('div');
    statsDiv.className = 'grid-stats';
    
    // Calculate progress percentage
    const progressPct = totalFramesExpected > 0 ? 
        Math.round(((totalFramesExpected - missingCount) / totalFramesExpected) * 100) : 0;
        
    statsDiv.innerHTML = `<span class="grid-stats-received">${totalFramesExpected - missingCount}</span>/<span class="grid-stats-total">${totalFramesExpected}</span> chunks received (${progressPct}%)`;
    
    if (missingCount > 0) {
        statsDiv.innerHTML += ` <span class="grid-stats-missing">(${missingCount} missing)</span>`;
    }
    
    grid.appendChild(statsDiv);
    
    // Auto-scroll to show missing frames if less than half are missing
    if (missingCount > 0 && missingCount < totalFramesExpected * 0.5) {
        setTimeout(() => {
            try {
                const missingCells = grid.querySelectorAll('.grid-cell.missing');
                if (missingCells.length > 0) {
                    missingCells[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            } catch (e) {
                console.error("Auto-scroll error:", e);
            }
        }, 100);
    }
}

// 4. Better UI for Multiple File Support

function enhanceMultipleFileSupport() {
    // Create a received files panel
    const createReceivedFilesPanel = function() {
        // Check if panel already exists
        let filesPanel = document.getElementById('receivedFilesPanel');
        if (filesPanel) return filesPanel;
        
        // Create the panel
        filesPanel = document.createElement('div');
        filesPanel.id = 'receivedFilesPanel';
        filesPanel.className = 'received-files-panel';
        filesPanel.style.backgroundColor = '#1a1a1a';
        filesPanel.style.border = '1px solid #333';
        filesPanel.style.borderRadius = '5px';
        filesPanel.style.padding = '15px';
        filesPanel.style.margin = '15px';
        filesPanel.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
        
        // Add title
        const title = document.createElement('h3');
        title.textContent = 'Received Files';
        title.style.margin = '0 0 10px 0';
        title.style.color = '#fff';
        filesPanel.appendChild(title);
        
        // Add files list container
        const filesList = document.createElement('div');
        filesList.id = 'receivedFilesList';
        filesList.style.maxHeight = '200px';
        filesList.style.overflowY = 'auto';
        filesPanel.appendChild(filesList);
        
        // Add to right panel
        const rightPanels = document.querySelectorAll('.right-panel');
        rightPanels.forEach(panel => {
            // Insert at the top
            if (panel.firstChild) {
                panel.insertBefore(filesPanel, panel.firstChild);
            } else {
                panel.appendChild(filesPanel);
            }
        });
        
        return filesPanel;
    };
    
    // Update the received files list
    window.updateReceivedFilesList = function() {
        const panel = createReceivedFilesPanel();
        const filesList = document.getElementById('receivedFilesList');
        
        if (!filesList) return;
        
        // Clear list
        filesList.innerHTML = '';
        
        // Add files from history
        let hasCompleteFiles = false;
        
        Object.keys(fileHistory).forEach(fileId => {
            const file = fileHistory[fileId];
            
            // Skip incomplete files
            if (!file.isComplete) return;
            
            hasCompleteFiles = true;
            
            // Create file item
            const fileItem = document.createElement('div');
            fileItem.className = 'received-file-item';
            fileItem.style.padding = '10px';
            fileItem.style.marginBottom = '5px';
            fileItem.style.backgroundColor = '#333';
            fileItem.style.borderRadius = '3px';
            fileItem.style.display = 'flex';
            fileItem.style.justifyContent = 'space-between';
            fileItem.style.alignItems = 'center';
            
            // File info
            const fileInfo = document.createElement('div');
            fileInfo.innerHTML = `
                <div style="font-weight:bold;color:#fff;">${file.fileName}</div>
                <div style="font-size:11px;color:#aaa;">${formatFileSize(file.fileSize)}</div>
                <div style="font-size:10px;color:#888;">Received: ${new Date(file.lastUpdated || file.firstSeen).toLocaleString()}</div>
            `;
            
            // Download button
            const downloadBtn = document.createElement('button');
            downloadBtn.textContent = 'Download';
            downloadBtn.style.padding = '5px 10px';
            downloadBtn.style.backgroundColor = '#4CAF50';
            downloadBtn.style.border = 'none';
            downloadBtn.style.borderRadius = '3px';
            downloadBtn.style.color = 'white';
            downloadBtn.style.cursor = 'pointer';
            
            // Add download functionality
            downloadBtn.addEventListener('click', function() {
                // Set up for download
                currentFileId = fileId;
                fileName = file.fileName;
                fileSize = file.fileSize;
                framesData = [...file.framesData];
                framesReceived = [...file.framesReceived];
                
                // Download the file
                assembleAndDownloadFile('manual');
            });
            
            fileItem.appendChild(fileInfo);
            fileItem.appendChild(downloadBtn);
            filesList.appendChild(fileItem);
        });
        
        // Show message if no files
        if (!hasCompleteFiles) {
            const noFiles = document.createElement('div');
            noFiles.textContent = 'No completed files yet.';
            noFiles.style.color = '#aaa';
            noFiles.style.padding = '10px';
            noFiles.style.fontStyle = 'italic';
            filesList.appendChild(noFiles);
        }
        
        // Show/hide the panel based on content
        panel.style.display = hasCompleteFiles ? 'block' : 'none';
    };
    
    // Update received files list when a file is completed
    const originalAssembleAndDownloadFile = window.assembleAndDownloadFile;
    
    window.assembleAndDownloadFile = function(type) {
        // Call original function
        originalAssembleAndDownloadFile(type);
        
        // Update the files list
        setTimeout(window.updateReceivedFilesList, 500);
    };
    
    // Initialize the files panel
    createReceivedFilesPanel();
    window.updateReceivedFilesList();
}

// Start initializing these features when the DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    // Initialize the full screen camera
    setTimeout(initializeFullScreenCamera, 500);
    
    // Initialize the multiple file support
    setTimeout(enhanceMultipleFileSupport, 700);
    
    // Add keyboard shortcuts for QR code scanning
    document.addEventListener('keydown', function(e) {
        // Space bar to start/stop camera
        if (e.key === ' ' || e.code === 'Space') {
            e.preventDefault();
            
            // Check which tab is active
            const liveTabActive = document.getElementById('live-tab').classList.contains('active');
            
            if (liveTabActive) {
                if (isLiveScanning) {
                    // Stop camera
                    const stopBtn = document.getElementById('stopLiveBtn');
                    if (stopBtn && !stopBtn.disabled) {
                        stopBtn.click();
                    }
                } else {
                    // Start camera
                    const startBtn = document.getElementById('startLiveBtn');
                    if (startBtn && !startBtn.disabled) {
                        startBtn.click();
                    }
                }
            }
        }
    });
    
    // Show keyboard shortcut info
    const addShortcutInfo = function() {
        const livePanel = document.querySelector('#live-tab .right-panel');
        if (livePanel) {
            const shortcutInfo = document.createElement('div');
            shortcutInfo.style.background = '#333';
            shortcutInfo.style.color = '#fff';
            shortcutInfo.style.padding = '8px';
            shortcutInfo.style.borderRadius = '4px';
            shortcutInfo.style.marginTop = '10px';
            shortcutInfo.style.fontSize = '12px';
            shortcutInfo.style.fontFamily = 'monospace';
            shortcutInfo.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 5px;">Keyboard Shortcuts:</div>
                <div>Space: Start/Stop Camera</div>
            `;
            livePanel.appendChild(shortcutInfo);
        }
    };
    
    // Add shortcut info after a short delay
    setTimeout(addShortcutInfo, 1000);
});
