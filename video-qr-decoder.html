<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Video QR Code Decoder</title>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: sans-serif;
        }

        .container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }

        .tabs {
            display: flex;
            background: #f0f0f0;
            border-bottom: 1px solid #ddd;
        }

        .tab {
            padding: 12px 20px;
            cursor: pointer;
            border-right: 1px solid #ddd;
        }

        .tab.active {
            background: #fff;
            font-weight: bold;
        }

        .tab-content {
            display: none;
            flex: 1;
            overflow: hidden;
        }

        .tab-content.active {
            display: flex;
        }

        .panel {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .left-panel {
            width: 60%;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #222;
            position: relative;
            padding: 10px;
        }

        .controls {
            margin-bottom: 10px;
            z-index: 10;
        }

        button {
            margin: 5px;
            padding: 8px 15px;
            font-size: 14px;
            cursor: pointer;
        }

        .video-container {
            position: relative;
            width: 100%;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #liveVideo,
        #processingVideo {
            max-width: 100%;
            max-height: 100%;
            background: black;
            z-index: 5;
        }

        .scan-region {
            position: absolute;
            border: 2px solid red;
            width: 200px;
            height: 200px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 6;
            cursor: move;
            transition: border-color 0.2s;
        }

        .scan-region:hover {
            border-color: lime;
            border-width: 3px;
        }

        .scan-region-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border: 2px solid red;
            border-radius: 50%;
            bottom: -8px;
            right: -8px;
            cursor: se-resize;
            z-index: 7;
        }

        .scan-region-info {
            position: absolute;
            bottom: -30px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 12px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 4px;
            border-radius: 4px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .scan-region:hover .scan-region-info {
            opacity: 1;
        }

        .right-panel {
            width: 40%;
            display: flex;
            flex-direction: column;
            padding: 10px;
            background: #f0f0f0;
        }

        .grid {
            --cell-size: 20px;
            display: grid;
            gap: 1px;
            height: auto;
            max-height: 30%;
            width: 100%;
            place-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background: #1a1a1a;
            border-radius: 4px;
            overflow-y: auto;
            position: relative;
        }

        /* Improve performance for large grids */
        @media (min-width: 768px) {
            .grid {
                grid-template-columns: repeat(auto-fill, minmax(12px, 1fr)) !important;
            }
        }

        /* For very large frame counts */
        .grid.large-count {
            --cell-size: 10px;
            gap: 1px;
            grid-template-columns: repeat(auto-fill, minmax(8px, 1fr)) !important;
        }

        .status-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-family: monospace;
            background: #333;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
        }

        .counter-box {
            display: inline-block;
            padding: 3px 8px;
            margin-right: 5px;
            background: #222;
            border-radius: 3px;
            color: lime;
        }

        .progress-container {
            height: 20px;
            background: #2a2a2a;
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
            border: 1px solid #333;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            width: 0%;
            text-align: center;
            color: white;
            font-size: 12px;
            line-height: 20px;
            transition: width 0.3s;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .grid-cell {
            background: darkred;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            text-align: center;
            transition: background 0.2s, transform 0.1s;
            width: var(--cell-size);
            height: var(--cell-size);
            position: relative;
            cursor: pointer;
            user-select: none;
        }

        .grid-cell:hover {
            transform: scale(1.1);
            z-index: 2;
        }

        .grid-cell.received {
            background: #4CAF50;
            box-shadow: 0 0 2px rgba(76, 175, 80, 0.8);
        }

        .grid-cell.missing {
            background: #ff6b6b;
            box-shadow: 0 0 3px rgba(255, 0, 0, 0.8);
            animation: pulseMissing 2s infinite;
        }

        @keyframes pulseMissing {
            0% {
                opacity: 0.8;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.8;
            }
        }

        .grid-cell.blinking {
            background: yellow !important;
            color: black;
            animation: pulse 0.4s;
            transform: scale(1.2);
            z-index: 10;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.3);
            }

            100% {
                transform: scale(1.2);
            }
        }

        .grid-stats {
            grid-column: 1 / -1;
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            background: #333;
            border-radius: 4px;
            text-align: center;
            font-family: monospace;
            color: white;
        }

        .grid-stats-received {
            color: #4CAF50;
            font-weight: bold;
        }

        .grid-stats-missing {
            color: #f44336;
            font-weight: bold;
        }

        .log {
            flex: 1;
            background: black;
            color: lime;
            padding: 10px;
            overflow-y: auto;
            white-space: pre;
            font-family: monospace;
            margin-top: 10px;
        }

        .hidden {
            display: none;
        }

        #canvas {
            display: none;
        }

        #fileInput {
            display: none;
        }

        .dropzone {
            border: 2px dashed #ccc;
            border-radius: 5px;
            padding: 25px;
            text-align: center;
            margin: 15px 0;
            background: #f9f9f9;
            cursor: pointer;
        }

        .dropzone:hover {
            background: #f0f0f0;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="tabs">
            <div class="tab active" data-tab="live">Live Camera</div>
            <div class="tab" data-tab="video">Video File</div>
        </div>

        <!-- Live Camera Tab -->
        <div class="tab-content active" id="live-tab">
            <div class="panel">
                <div class="left-panel">
                    <div class="controls">
                        <button id="startLiveBtn">Start Camera</button>
                        <button id="stopLiveBtn" disabled>Stop Camera</button>
                        <button id="resetScanRegionBtn" title="Reset scan region to center">Reset Region</button>
                    </div>
                    <div class="video-container">
                        <video id="liveVideo" playsinline></video>
                        <div class="scan-region">
                            <div class="scan-region-handle"></div>
                            <div class="scan-region-info">Drag to move, resize handle to adjust</div>
                        </div>
                    </div>
                </div>
                <div class="right-panel">
                    <div class="status-container">
                        <div>Frames: <span class="counter-box" id="liveFramesCounter">0</span></div>
                        <div>QR detected: <span class="counter-box" id="liveQrCounter">0</span></div>
                    </div>
                    <div class="grid" id="liveGrid"></div>
                    <div class="log" id="liveLog"></div>
                </div>
            </div>
        </div>

        <!-- Video File Tab -->
        <div class="tab-content" id="video-tab">
            <div class="panel">
                <div class="left-panel">
                    <div class="controls">
                        <button id="openVideoBtn">Open Video</button>
                        <button id="quickAnalysisBtn" disabled>Quick Analysis</button>
                        <button id="processVideoBtn" disabled>Process Video</button>
                        <button id="stopProcessingBtn" disabled>Stop Processing</button>
                    </div>
                    <div class="video-container">
                        <video id="processingVideo" controls></video>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar" id="progressBar"></div>
                    </div>
                    <input type="file" id="fileInput" accept="video/*" />
                    <div class="dropzone">
                        <p>Drop video file here or click to select</p>
                    </div>
                </div>
                <div class="right-panel">
                    <div class="status-container">
                        <div>Frames: <span class="counter-box" id="videoFramesCounter">0</span></div>
                        <div>QR detected: <span class="counter-box" id="videoQrCounter">0</span></div>
                        <div>Time: <span class="counter-box" id="videoTimeDisplay">0.0s</span></div>
                    </div>
                    <div class="grid" id="videoGrid"></div>
                    <div class="log" id="videoLog"></div>
                </div>
            </div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // DOM Elements
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        const canvas = document.getElementById('canvas');
        // Initialize canvas with willReadFrequently to avoid warnings
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        canvas.willReadFrequently = true;

        // Live tab elements
        const liveVideo = document.getElementById('liveVideo');
        const startLiveBtn = document.getElementById('startLiveBtn');
        const stopLiveBtn = document.getElementById('stopLiveBtn');
        const liveGrid = document.getElementById('liveGrid');
        const liveLog = document.getElementById('liveLog');
        const liveFramesCounter = document.getElementById('liveFramesCounter');
        const liveQrCounter = document.getElementById('liveQrCounter');

        // Video tab elements
        const processingVideo = document.getElementById('processingVideo');
        const openVideoBtn = document.getElementById('openVideoBtn');
        const quickAnalysisBtn = document.getElementById('quickAnalysisBtn');
        const processVideoBtn = document.getElementById('processVideoBtn');
        const stopProcessingBtn = document.getElementById('stopProcessingBtn');
        const fileInput = document.getElementById('fileInput');
        const dropzone = document.querySelector('.dropzone');
        const videoGrid = document.getElementById('videoGrid');
        const videoLog = document.getElementById('videoLog');
        const progressBar = document.getElementById('progressBar');
        const videoFramesCounter = document.getElementById('videoFramesCounter');
        const videoQrCounter = document.getElementById('videoQrCounter');
        const videoTimeDisplay = document.getElementById('videoTimeDisplay');

        // State variables
        let liveStream = null;
        let isLiveScanning = false;
        let isProcessingVideo = false;
        let currentProcessingFrame = 0;
        let totalFrames = 0;
        let capturedFramesCount = 0;
        let framesCapturedWithQR = 0;
        let isWaitingForSeek = false;
        let lastSeekTime = 0;

        // Data storage
        let startReceived = false;
        let totalFramesExpected = 0;
        let fileName = '';
        let fileSize = 0;
        let framesData = [];
        let framesReceived = [];
        let lastQrData = null;
        let lastQrTime = 0;

        // Persistent data storage for handling repeated videos
        let fileHistory = {};  // Object to store file metadata and frame status
        let currentFileId = ''; // Current file identifier
        let isFileComplete = false; // Flag to track if current file is complete

        // Enhanced debugging and analysis
        let diagnosticsEnabled = true;  // Set to true to enable diagnostic captures
        let savedFrameCounter = 0;      // Counter for saved diagnostic frames
        let qrGridSize = 1;             // Default to single QR code
        let qrPositions = {};           // Track where QR codes are found on frames
        let detectedFrameRates = [];    // Store time differences to estimate fps
        let lastQrDetectionTime = 0;    // Track time of last QR detection
        let qrSizeStats = {             // Track QR code size statistics
            count: 0,
            totalWidth: 0,
            totalHeight: 0,
            minWidth: Infinity,
            maxWidth: 0,
            minHeight: Infinity,
            maxHeight: 0
        };
        let logMessages = {
            live: [],
            video: []
        };

        // Tab switching
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;

                // Update active tab
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                // Update active content
                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(`${tabName}-tab`).classList.add('active');

                // Stop any active processes when switching tabs
                if (tabName === 'live' && isProcessingVideo) {
                    stopVideoProcessing();
                } else if (tabName === 'video' && isLiveScanning) {
                    stopLiveScanning();
                }
            });
        });

        // Logging functions
        function showLog(message, type = 'live') {
            logMessages[type].push(message);
            const logElement = type === 'live' ? liveLog : videoLog;
            logElement.textContent = logMessages[type].join('\n');
            logElement.scrollTop = logElement.scrollHeight;
        }

        function resetState(type = 'live', keepFileData = false) {
            // If we want to keep data for the same file, we store it first
            if (keepFileData && currentFileId && fileHistory[currentFileId]) {
                // We don't reset the file data, we'll just reuse it
                showLog(`Preserving data for file: ${fileName} (ID: ${currentFileId})`, type);
                showLog(`Already have ${fileHistory[currentFileId].receivedCount}/${fileHistory[currentFileId].totalFrames} frames`, type);
            } else {
                // Reset all file data
                startReceived = false;
                totalFramesExpected = 0;
                fileName = '';
                fileSize = 0;
                framesData = [];
                framesReceived = [];
                lastQrData = null;
                lastQrTime = 0;
                currentFileId = '';
                isFileComplete = false;
            }

            if (type === 'live') {
                stopLiveBtn.disabled = true;
                startLiveBtn.disabled = false;
                liveVideo.style.display = 'none';
                isLiveScanning = false;
                if (!keepFileData) {
                    logMessages.live = [];
                    liveLog.textContent = '';
                    liveGrid.innerHTML = '';
                }
                capturedFramesCount = 0;
                framesCapturedWithQR = 0;
                liveFramesCounter.textContent = '0';
                liveQrCounter.textContent = '0';
            } else {
                processVideoBtn.disabled = true;
                stopProcessingBtn.disabled = true;
                currentProcessingFrame = 0;
                totalFrames = 0;
                isProcessingVideo = false;
                progressBar.style.width = '0%';
                progressBar.textContent = '';
                if (!keepFileData) {
                    logMessages.video = [];
                    videoLog.textContent = '';
                    videoGrid.innerHTML = '';
                }
                capturedFramesCount = 0;
                framesCapturedWithQR = 0;
                videoFramesCounter.textContent = '0';
                videoQrCounter.textContent = '0';
            }
        }

        function enhanceUIVisibility() {
            // Make grid more visible
            const grids = [liveGrid, videoGrid];
            grids.forEach(grid => {
                if (!grid) return;

                // Expand grid height for better visibility
                grid.style.maxHeight = '35vh';
                grid.style.minHeight = '100px';
                grid.style.backgroundColor = '#2a2a2a';
                grid.style.border = '2px solid #444';
                grid.style.padding = '10px';
                grid.style.borderRadius = '5px';
                grid.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';

                // Add a clear title to the grid
                const gridTitle = document.createElement('div');
                gridTitle.style.color = 'white';
                gridTitle.style.fontWeight = 'bold';
                gridTitle.style.padding = '5px';
                gridTitle.style.textAlign = 'center';
                gridTitle.style.marginBottom = '10px';
                gridTitle.textContent = 'QR Code Frame Status';

                // Insert title at the top of grid
                grid.insertBefore(gridTitle, grid.firstChild);
            });

            // Enhance logs for better visibility
            const logs = [liveLog, videoLog];
            logs.forEach(log => {
                if (!log) return;

                log.style.backgroundColor = '#111';
                log.style.color = '#0f0'; // Bright green for better visibility
                log.style.border = '1px solid #444';
                log.style.borderRadius = '4px';
                log.style.padding = '10px';
                log.style.fontSize = '13px';
                log.style.fontFamily = 'monospace';
                log.style.lineHeight = '1.5';

                // Add auto-scroll functionality to logs
                const originalShowLog = window.showLog;
                window.showLog = function (message, logType = 'live', isImportant = false) {
                    // Call the original function
                    originalShowLog(message, logType, isImportant);

                    // Auto-scroll to bottom
                    const logElement = logType === 'live' ? liveLog : videoLog;
                    if (logElement) {
                        logElement.scrollTop = logElement.scrollHeight;
                    }

                    // Also log to console for debugging
                    if (isImportant) {
                        console.warn(`[${logType}] ${message}`);
                    } else {
                        console.log(`[${logType}] ${message}`);
                    }
                };
            });

            // Make progress bar more visible
            const progressBar = document.getElementById('progressBar');
            if (progressBar) {
                progressBar.style.background = 'linear-gradient(to right, #4CAF50, #8BC34A)';
                progressBar.style.height = '20px';
                progressBar.style.transition = 'width 0.5s';
                progressBar.style.boxShadow = '0 0 5px rgba(76, 175, 80, 0.5)';
                progressBar.style.borderRadius = '2px';
            }
        }

        function initializeFullScreenCamera() {
            // Make the scan region fill most of the screen initially
            const scanRegion = document.querySelector('.scan-region');
            const videoContainer = document.querySelector('.video-container');

            if (!scanRegion || !videoContainer) return;

            // Set initial size to be large (80% of container)
            const initialSetup = function () {
                try {
                    const containerRect = videoContainer.getBoundingClientRect();
                    const width = Math.min(containerRect.width * 0.8, 600);
                    const height = Math.min(containerRect.height * 0.8, 600);

                    // Center the scan region
                    scanRegion.style.width = `${width}px`;
                    scanRegion.style.height = `${height}px`;
                    scanRegion.style.left = '50%';
                    scanRegion.style.top = '50%';
                    scanRegion.style.transform = 'translate(-50%, -50%)';

                    // Style the scan region for better visibility
                    scanRegion.style.border = '3px solid rgba(255, 0, 0, 0.7)';
                    scanRegion.style.boxShadow = '0 0 0 2000px rgba(0, 0, 0, 0.3)';
                    scanRegion.style.transition = 'all 0.3s ease';

                    // Update info display
                    const infoDisplay = scanRegion.querySelector('.scan-region-info');
                    if (infoDisplay) {
                        infoDisplay.style.background = 'rgba(0, 0, 0, 0.7)';
                        infoDisplay.style.color = 'white';
                        infoDisplay.style.padding = '5px';
                        infoDisplay.style.borderRadius = '3px';
                        infoDisplay.style.opacity = '1';
                        infoDisplay.textContent = `Scan area: ${Math.round(width)}×${Math.round(height)}px`;
                    }

                    // Log setup
                    showLog(`Scan region initialized to ${Math.round(width)}×${Math.round(height)}px`, 'live');
                } catch (err) {
                    console.error('Error setting up scan region:', err);
                }
            };

            // Add preset size buttons
            function addSizePresets() {
                const presetsContainer = document.createElement('div');
                presetsContainer.style.display = 'flex';
                presetsContainer.style.gap = '10px';
                presetsContainer.style.marginTop = '10px';
                presetsContainer.style.justifyContent = 'center';

                // Add preset buttons
                const presets = [
                    { name: 'Small', size: 0.5 },
                    { name: 'Medium', size: 0.7 },
                    { name: 'Large', size: 0.9 }
                ];

                presets.forEach(preset => {
                    const button = document.createElement('button');
                    button.textContent = preset.name;
                    button.style.padding = '5px 10px';
                    button.style.backgroundColor = '#333';
                    button.style.color = 'white';
                    button.style.border = 'none';
                    button.style.borderRadius = '3px';
                    button.style.cursor = 'pointer';

                    button.addEventListener('click', function () {
                        const containerRect = videoContainer.getBoundingClientRect();
                        const width = containerRect.width * preset.size;
                        const height = containerRect.height * preset.size;

                        scanRegion.style.width = `${width}px`;
                        scanRegion.style.height = `${height}px`;
                        scanRegion.style.left = '50%';
                        scanRegion.style.top = '50%';
                        scanRegion.style.transform = 'translate(-50%, -50%)';

                        // Update info display
                        const infoDisplay = scanRegion.querySelector('.scan-region-info');
                        if (infoDisplay) {
                            infoDisplay.textContent = `Scan area: ${Math.round(width)}×${Math.round(height)}px`;
                        }

                        showLog(`Scan region resized to ${preset.name} (${Math.round(width)}×${Math.round(height)}px)`, 'live');
                    });

                    presetsContainer.appendChild(button);
                });

                // Add the presets container before the video container
                const controls = document.querySelector('#live-tab .controls');
                if (controls) {
                    controls.appendChild(presetsContainer);
                }
            }

            // Call setup after a short delay to ensure elements are rendered
            setTimeout(initialSetup, 500);

            // Add size presets
            setTimeout(addSizePresets, 600);

            // Add a resize observer to adjust scan region when window size changes
            const resizeObserver = new ResizeObserver(entries => {
                // Only update if the transform is still centered (user hasn't moved it)
                if (scanRegion.style.transform.includes('translate(-50%, -50%)')) {
                    initialSetup();
                }
            });

            resizeObserver.observe(videoContainer);
        }

        // 3. Enhanced Visual UI with Set-Based Visualization

        // Update the grid to show set-based information
        function updateGrid(type = 'live') {
            const grid = type === 'live' ? liveGrid : videoGrid;
            grid.innerHTML = '';

            if (totalFramesExpected <= 0) return;

            // Add class for very large frame counts
            if (totalFramesExpected > 1000) {
                grid.classList.add('large-count');
            } else {
                grid.classList.remove('large-count');
            }

            // Ensure grid can grow in height with auto-scroll
            grid.style.maxHeight = '40vh';
            grid.style.overflowY = 'auto';

            // Calculate cell size based on frame count
            let cellSize;
            if (totalFramesExpected > 10000) {
                cellSize = 6;
            } else if (totalFramesExpected > 5000) {
                cellSize = 8;
            } else if (totalFramesExpected > 1000) {
                cellSize = 10;
            } else if (totalFramesExpected > 500) {
                cellSize = 12;
            } else {
                cellSize = Math.min(25, Math.max(15, Math.floor(grid.clientWidth / Math.min(totalFramesExpected, 20))));
            }

            const columns = Math.floor(grid.clientWidth / cellSize);
            grid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
            grid.style.setProperty('--cell-size', `${cellSize}px`);

            // Create a document fragment for better performance
            const fragment = document.createDocumentFragment();

            // Check if we have set data to show hierarchical view
            const hasSetInfo = setsData.length > 0 && chunksPerSelectedSet.length > 0;

            if (hasSetInfo) {
                // Add a container for sets
                const setsContainer = document.createElement('div');
                setsContainer.className = 'sets-container';
                setsContainer.style.display = 'flex';
                setsContainer.style.flexDirection = 'column';
                setsContainer.style.gap = '15px';
                setsContainer.style.width = '100%';
                setsContainer.style.padding = '10px 0';

                // Add a title for the sets view
                const setsTitle = document.createElement('div');
                setsTitle.style.fontSize = '14px';
                setsTitle.style.fontWeight = 'bold';
                setsTitle.style.color = '#fff';
                setsTitle.style.marginBottom = '5px';
                setsTitle.textContent = 'File Sets Progress';
                setsContainer.appendChild(setsTitle);

                // Create a set card for each set
                let setIndex = 0;
                let globalChunkOffset = 0;

                for (const setSize of chunksPerSelectedSet) {
                    if (!setSize) continue; // Skip empty sets

                    // Create a set card
                    const setCard = document.createElement('div');
                    setCard.className = 'set-card';
                    setCard.style.backgroundColor = '#1a1a1a';
                    setCard.style.borderRadius = '5px';
                    setCard.style.padding = '10px';
                    setCard.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';

                    // Set header with information
                    const setHeader = document.createElement('div');
                    setHeader.style.display = 'flex';
                    setHeader.style.justifyContent = 'space-between';
                    setHeader.style.alignItems = 'center';
                    setHeader.style.marginBottom = '10px';

                    // Set title with info
                    const setTitle = document.createElement('div');

                    // Check if set metadata received
                    const metadataReceived = window.setMetadataReceived ?
                        window.setMetadataReceived[setIndex] : false;

                    // Count received chunks for this set
                    let receivedInSet = 0;
                    for (let i = 0; i < setSize; i++) {
                        if (framesReceived[globalChunkOffset + i]) {
                            receivedInSet++;
                        }
                    }

                    // Calculate completion percentage
                    const completionPct = Math.round((receivedInSet / setSize) * 100);

                    // Title with completion info
                    setTitle.innerHTML = `<strong>Set ${setIndex + 1}</strong> 
                                  <span style="color: ${metadataReceived ? '#4CAF50' : '#ff9800'}">
                                      ${metadataReceived ? '✓' : '⚠️'} Metadata
                                  </span> - 
                                  <span style="color: ${receivedInSet === setSize ? '#4CAF50' : '#ff9800'}">
                                      ${receivedInSet}/${setSize} chunks (${completionPct}%)
                                  </span>`;
                    setTitle.style.color = '#fff';
                    setTitle.style.fontSize = '13px';

                    setHeader.appendChild(setTitle);

                    // Add progress bar
                    const progressContainer = document.createElement('div');
                    progressContainer.style.width = '100%';
                    progressContainer.style.height = '10px';
                    progressContainer.style.backgroundColor = '#333';
                    progressContainer.style.borderRadius = '5px';
                    progressContainer.style.overflow = 'hidden';

                    const progressBar = document.createElement('div');
                    progressBar.style.height = '100%';
                    progressBar.style.width = `${completionPct}%`;
                    progressBar.style.backgroundColor = receivedInSet === setSize ? '#4CAF50' : '#ff9800';

                    progressContainer.appendChild(progressBar);

                    // Add set components to the card
                    setCard.appendChild(setHeader);
                    setCard.appendChild(progressContainer);

                    // Add to the container
                    setsContainer.appendChild(setCard);

                    // Move to next set
                    setIndex++;
                    globalChunkOffset += setSize;
                }

                // Add the sets container to the fragment
                fragment.appendChild(setsContainer);

                // Add horizontal divider
                const divider = document.createElement('div');
                divider.style.width = '100%';
                divider.style.height = '1px';
                divider.style.backgroundColor = '#333';
                divider.style.margin = '15px 0';
                fragment.appendChild(divider);
            }

            // Add cells for individual chunks
            // For very large numbers, group them
            if (totalFramesExpected > 2000) {
                // Use a grouped approach for better performance
                const groupSize = Math.ceil(totalFramesExpected / 500);

                for (let i = 0; i < totalFramesExpected; i += groupSize) {
                    const endIdx = Math.min(i + groupSize - 1, totalFramesExpected - 1);

                    // Calculate received count
                    let receivedInGroup = 0;
                    for (let j = i; j <= endIdx; j++) {
                        if (framesReceived[j]) receivedInGroup++;
                    }

                    // Create a group cell
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.setAttribute('data-start', i + 1);
                    cell.setAttribute('data-end', endIdx + 1);

                    // Calculate completion percentage
                    const groupCompletionPct = Math.round((receivedInGroup / (endIdx - i + 1)) * 100);

                    // Visual styling based on completion
                    if (receivedInGroup === endIdx - i + 1) {
                        // Fully complete
                        cell.classList.add('received');
                    } else if (receivedInGroup > 0) {
                        // Partially complete - create a gradient
                        cell.style.background = `linear-gradient(to right, #4CAF50 ${groupCompletionPct}%, darkred ${groupCompletionPct}%)`;
                    }

                    // Tooltip
                    cell.setAttribute('title', `Chunks ${i + 1}-${endIdx + 1}: ${receivedInGroup}/${endIdx - i + 1} received (${groupCompletionPct}%)`);

                    fragment.appendChild(cell);
                }
            } else {
                // Standard approach for reasonable numbers of frames
                for (let i = 0; i < totalFramesExpected; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.setAttribute('data-index', i + 1);

                    // For smaller cells, use color-only approach
                    if (cellSize < 16) {
                        cell.textContent = '';
                    } else {
                        cell.textContent = i + 1;
                    }

                    if (framesReceived[i]) {
                        cell.classList.add('received');
                    } else if (startReceived && totalFramesExpected > 0 && currentFileId) {
                        // Highlight missing frames
                        cell.classList.add('missing');
                    }

                    // Tooltip with frame number
                    cell.setAttribute('title', `Chunk ${i + 1}`);

                    // Store cell reference for faster blinking
                    const cellId = `cell-${type}-${i}`;
                    cell.id = cellId;

                    fragment.appendChild(cell);
                }
            }

            // Add all cells
            grid.appendChild(fragment);

            // Add counter for missing frames
            const missingCount = framesReceived.filter(received => !received).length;
            const statsDiv = document.createElement('div');
            statsDiv.className = 'grid-stats';

            // Calculate progress percentage
            const progressPct = totalFramesExpected > 0 ?
                Math.round(((totalFramesExpected - missingCount) / totalFramesExpected) * 100) : 0;

            statsDiv.innerHTML = `<span class="grid-stats-received">${totalFramesExpected - missingCount}</span>/<span class="grid-stats-total">${totalFramesExpected}</span> chunks received (${progressPct}%)`;

            if (missingCount > 0) {
                statsDiv.innerHTML += ` <span class="grid-stats-missing">(${missingCount} missing)</span>`;
            }

            grid.appendChild(statsDiv);

            // Auto-scroll to show missing frames if less than half are missing
            if (missingCount > 0 && missingCount < totalFramesExpected * 0.5) {
                setTimeout(() => {
                    try {
                        const missingCells = grid.querySelectorAll('.grid-cell.missing');
                        if (missingCells.length > 0) {
                            missingCells[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    } catch (e) {
                        console.error("Auto-scroll error:", e);
                    }
                }, 100);
            }
        }

        function blinkCell(index, type = 'live') {
            const grid = type === 'live' ? liveGrid : videoGrid;

            // Handle grouped cells for large frame counts
            if (totalFramesExpected > 2000) {
                // Need to find which group contains this index
                const groupSize = Math.ceil(totalFramesExpected / 500);
                const groupIndex = Math.floor(index / groupSize);
                const groupStartIndex = groupIndex * groupSize;

                // Find cell by data attributes
                const cells = grid.querySelectorAll('.grid-cell');
                let targetCell = null;

                for (let i = 0; i < cells.length; i++) {
                    const start = parseInt(cells[i].getAttribute('data-start') || '-1');
                    const end = parseInt(cells[i].getAttribute('data-end') || '-1');

                    if (start <= index + 1 && index + 1 <= end) {
                        targetCell = cells[i];
                        break;
                    }
                }

                // If found the group cell, highlight it
                if (targetCell) {
                    targetCell.classList.add('blinking');

                    // Calculate updated completion for the group
                    const start = parseInt(targetCell.getAttribute('data-start')) - 1;
                    const end = parseInt(targetCell.getAttribute('data-end')) - 1;

                    // Count received frames in this group
                    let receivedInGroup = 0;
                    for (let i = start; i <= end; i++) {
                        if (framesReceived[i]) receivedInGroup++;
                    }

                    // Calculate completion percentage
                    const groupCompletionPct = Math.round((receivedInGroup / (end - start + 1)) * 100);

                    // Use requestAnimationFrame for better performance
                    requestAnimationFrame(() => {
                        setTimeout(() => {
                            targetCell.classList.remove('blinking');

                            // Update cell appearance based on completion
                            if (receivedInGroup === end - start + 1) {
                                // Fully complete
                                targetCell.classList.add('received');
                                targetCell.style.background = ''; // Remove gradient if exists
                            } else if (receivedInGroup > 0) {
                                // Partially complete - update gradient
                                targetCell.style.background = `linear-gradient(to right, #4CAF50 ${groupCompletionPct}%, darkred ${groupCompletionPct}%)`;
                            }

                            // Update tooltip
                            targetCell.setAttribute('title',
                                `Frames ${start + 1}-${end + 1}: ${receivedInGroup}/${end - start + 1} received (${groupCompletionPct}%)`);

                            // Update stats
                            updateGridStats(type);
                        }, 200);
                    });
                }
            } else {
                // Normal individual cell handling
                const cellId = `cell-${type}-${index}`;
                const cell = document.getElementById(cellId);

                if (cell) {
                    cell.classList.add('blinking');

                    // Use requestAnimationFrame for better performance
                    requestAnimationFrame(() => {
                        // Add a small delay to make the blink visible
                        setTimeout(() => {
                            cell.classList.remove('blinking');
                            if (framesReceived[index]) {
                                cell.classList.add('received');
                            }

                            // Update stats
                            updateGridStats(type);
                        }, 200);
                    });
                }
            }
        }

        // Separate function to update grid stats for better performance
        function updateGridStats(type) {
            const grid = type === 'live' ? liveGrid : videoGrid;
            const statsDiv = grid.querySelector('.grid-stats');

            if (statsDiv && totalFramesExpected > 0) {
                const missingCount = framesReceived.filter(received => !received).length;
                const receivedCount = totalFramesExpected - missingCount;
                const progressPct = Math.round((receivedCount / totalFramesExpected) * 100);

                // Update stats with new information
                const receivedSpan = statsDiv.querySelector('.grid-stats-received');
                const totalSpan = statsDiv.querySelector('.grid-stats-total');
                const missingSpan = statsDiv.querySelector('.grid-stats-missing');

                if (receivedSpan) receivedSpan.textContent = receivedCount;
                if (totalSpan) totalSpan.textContent = totalFramesExpected;

                // Update or add progress percentage
                let pctSpan = statsDiv.querySelector('.progress-pct');
                if (!pctSpan) {
                    // First create pct element if it doesn't exist
                    pctSpan = document.createElement('span');
                    pctSpan.className = 'progress-pct';
                    statsDiv.appendChild(pctSpan);
                }
                pctSpan.textContent = ` (${progressPct}%)`;

                // Update missing count
                if (missingSpan) {
                    if (missingCount > 0) {
                        missingSpan.textContent = `(${missingCount} missing)`;
                        missingSpan.style.display = 'inline';
                    } else {
                        missingSpan.style.display = 'none';
                    }
                } else if (missingCount > 0) {
                    const newMissingSpan = document.createElement('span');
                    newMissingSpan.className = 'grid-stats-missing';
                    newMissingSpan.textContent = ` (${missingCount} missing)`;
                    statsDiv.appendChild(newMissingSpan);
                }
            }
        }

        function updateProgressBar(current, total) {
            if (total <= 0) return;

            const percent = Math.min(100, Math.round((current / total) * 100));
            progressBar.style.width = `${percent}%`;
            progressBar.textContent = `${percent}%`;
        }

        // Live scanning functions
        async function startLiveScanning() {
            try {
                // Request highest resolution camera with preferred settings
                // This improves QR code detection significantly
                liveStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { min: 640, ideal: 1920 },
                        height: { min: 400, ideal: 1080 },
                        aspectRatio: { ideal: 1.7777777778 }
                    }
                });

                // Get camera capabilities
                const videoTrack = liveStream.getVideoTracks()[0];
                if (videoTrack) {
                    const capabilities = videoTrack.getCapabilities();
                    showLog(`Camera: ${videoTrack.label}`);
                    if (capabilities) {
                        const actualWidth = capabilities.width?.max || 'unknown';
                        const actualHeight = capabilities.height?.max || 'unknown';
                        showLog(`Camera resolution: ${actualWidth}x${actualHeight}`);
                    }
                }

                liveVideo.srcObject = liveStream;
                liveVideo.setAttribute('playsinline', 'true');

                try {
                    await liveVideo.play();
                    showLog('Camera started');
                } catch (err) {
                    showLog('Play error: ' + err.message + ' - Try tapping screen');

                    // Add tap-to-play handler
                    liveVideo.addEventListener('click', () => {
                        liveVideo.play().catch(e => showLog('Play failed: ' + e.message));
                    });
                }

                liveVideo.style.display = 'block';
                isLiveScanning = true;
                startLiveBtn.disabled = true;
                stopLiveBtn.disabled = false;

                showLog('Camera ready, scanning for QR codes...');
                requestAnimationFrame(scanLiveFrame);
            } catch (err) {
                showLog('Error starting camera: ' + err.message);

                // Try fallback to less demanding constraints
                try {
                    showLog('Trying fallback camera settings...');
                    liveStream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'environment' }
                    });

                    liveVideo.srcObject = liveStream;
                    await liveVideo.play();

                    liveVideo.style.display = 'block';
                    isLiveScanning = true;
                    startLiveBtn.disabled = true;
                    stopLiveBtn.disabled = false;

                    showLog('Camera started with fallback settings');
                    requestAnimationFrame(scanLiveFrame);
                } catch (fallbackErr) {
                    showLog('Error with fallback camera: ' + fallbackErr.message);
                }
            }
        }

        function stopLiveScanning() {
            if (liveStream) {
                liveStream.getTracks().forEach(track => track.stop());
                liveStream = null;
            }

            isLiveScanning = false;
            showLog('Camera stopped');
            resetState('live');
        }

        // Extract region of interest (ROI) from the full frame
        function extractROI(canvas, scanRegion) {
            // Get the scan region element and its dimensions
            const scanRegionEl = document.querySelector('.scan-region');

            // Calculate the actual coordinates of the scan region in the video
            const videoRect = liveVideo.getBoundingClientRect();
            const scanRect = scanRegionEl.getBoundingClientRect();

            // Convert from screen coordinates to video coordinates
            const scaleX = canvas.width / videoRect.width;
            const scaleY = canvas.height / videoRect.height;

            // Calculate the center of the scan region relative to the video
            const centerX = ((scanRect.left + scanRect.width / 2) - videoRect.left) * scaleX;
            const centerY = ((scanRect.top + scanRect.height / 2) - videoRect.top) * scaleY;

            // Calculate ROI dimensions in video coordinates
            const roiWidth = scanRect.width * scaleX;
            const roiHeight = scanRect.height * scaleY;

            // Calculate top-left corner of ROI
            const roiLeft = Math.max(0, centerX - roiWidth / 2);
            const roiTop = Math.max(0, centerY - roiHeight / 2);

            // Ensure ROI stays within canvas bounds
            const actualWidth = Math.min(roiWidth, canvas.width - roiLeft);
            const actualHeight = Math.min(roiHeight, canvas.height - roiTop);

            // Extract the region of interest
            try {
                return ctx.getImageData(roiLeft, roiTop, actualWidth, actualHeight);
            } catch (err) {
                console.error("Error extracting ROI:", err);
                // Fallback to full frame if ROI extraction fails
                return ctx.getImageData(0, 0, canvas.width, canvas.height);
            }
        }

        function scanLiveFrame() {
            if (!isLiveScanning) return;

            if (liveVideo.readyState === liveVideo.HAVE_ENOUGH_DATA) {
                canvas.width = liveVideo.videoWidth;
                canvas.height = liveVideo.videoHeight;
                ctx.drawImage(liveVideo, 0, 0);

                capturedFramesCount++;
                liveFramesCounter.textContent = capturedFramesCount;

                try {
                    // First try scanning just the ROI (region of interest)
                    const roiData = extractROI(canvas);
                    let qrCode = null;

                    // Try to detect QR in the ROI first
                    try {
                        qrCode = jsQR(roiData.data, roiData.width, roiData.height, {
                            inversionAttempts: 'attemptBoth', // Try both non-inverted and inverted for better detection
                            canOverwriteImage: true, // Allow overwriting the image data for performance
                            maxModuleCount: 177  // Support high capacity QR codes (version 40)
                        });
                    } catch (roiErr) {
                        console.error("Error processing ROI:", roiErr);
                    }

                    // If ROI detection fails, try the full frame every 10 frames as a fallback
                    if (!qrCode && capturedFramesCount % 10 === 0) {
                        const fullImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        qrCode = jsQR(fullImageData.data, fullImageData.width, fullImageData.height, {
                            inversionAttempts: 'attemptBoth',
                            canOverwriteImage: true,
                            maxModuleCount: 177
                        });

                        // If found in full frame but not ROI, log it
                        if (qrCode) {
                            console.log("QR detected in full frame but not in ROI");
                        }
                    }

                    // If QR code found, process it
                    if (qrCode) {
                        framesCapturedWithQR++;
                        liveQrCounter.textContent = framesCapturedWithQR;
                        processQrData(qrCode.data, 'live');

                        // Visually mark the detected QR code
                        ctx.strokeStyle = 'lime';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                        ctx.lineTo(qrCode.location.topRightCorner.x, qrCode.location.topRightCorner.y);
                        ctx.lineTo(qrCode.location.bottomRightCorner.x, qrCode.location.bottomRightCorner.y);
                        ctx.lineTo(qrCode.location.bottomLeftCorner.x, qrCode.location.bottomLeftCorner.y);
                        ctx.lineTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                        ctx.stroke();
                    }
                } catch (err) {
                    // Silent catch - continue scanning
                    console.error("Error in scanLiveFrame:", err);
                }
            }

            requestAnimationFrame(scanLiveFrame);
        }

        // Video file processing
        function handleFileInput(file) {
            if (!file || !file.type.startsWith('video/')) {
                showLog('Please select a valid video file', 'video');
                return;
            }

            const videoUrl = URL.createObjectURL(file);
            processingVideo.src = videoUrl;

            processingVideo.onloadedmetadata = () => {
                showLog(`Video loaded: ${file.name} (${Math.round(processingVideo.duration)}s)`, 'video');
                quickAnalysisBtn.disabled = false;
                processVideoBtn.disabled = false;
                dropzone.textContent = file.name;
            };

            processingVideo.onerror = () => {
                showLog(`Error loading video: ${processingVideo.error.message}`, 'video');
                URL.revokeObjectURL(videoUrl);
            };
        }

        // Smart search strategy for finding QR codes in videos
        let searchPhase = 'initial'; // 'initial', 'binary', 'sequential', 'completion'
        let binarySearchRanges = []; // Tracks ranges for binary search
        let foundQRTimeRanges = []; // Track time ranges where QR codes were found
        let fastForwardMode = false; // Skip ahead when QR codes found
        let initialSampleRate = 4; // Initial sparse sampling rate (1 frame per x seconds)

        // Preliminary analysis variables
        let estimatedFrameRate = 0;
        let estimatedQRCount = 0;
        let estimatedGridSize = 1;
        let isPerformingQuickAnalysis = false;
        let quickAnalysisSamples = 0;
        let quickAnalysisQRs = 0;

        // Perform a quick preliminary analysis to determine frame rate and estimate QR count
        function performQuickAnalysis() {
            if (!processingVideo.src) {
                showLog('No video loaded', 'video');
                return;
            }

            // Reset state but don't clear the grid yet
            resetAnalysisState();

            const duration = processingVideo.duration;
            if (!isFinite(duration) || duration <= 0) {
                showLog('Warning: Video has invalid duration. Using time-based analysis instead.', 'video');
            }

            // Disable buttons during analysis
            quickAnalysisBtn.disabled = true;
            processVideoBtn.disabled = true;
            stopProcessingBtn.disabled = false;

            isPerformingQuickAnalysis = true;

            showLog('Starting quick analysis to determine frame rate and QR count...', 'video');
            progressBar.style.width = '0%';

            // Use an accelerated sampling approach
            // 1. First sample: Very beginning to find metadata QR
            // 2. Next sample: Sparse but distributed samples throughout video
            // 3. Adaptive: Focus more on areas where QR codes are found

            // Create an array of timestamps to check in the first phase
            const timestamps = [];

            // First focus heavily on the beginning (first 10 seconds)
            for (let t = 0; t < Math.min(10, duration); t += 0.5) {
                timestamps.push(t);
            }

            // Then add sparse samples throughout the video
            // More frequent at the beginning, less frequent later
            const sampleCount = Math.min(30, Math.ceil(duration / 10));
            for (let i = 0; i < sampleCount; i++) {
                timestamps.push(10 + (i / sampleCount) * (duration - 10));
            }

            quickAnalysisSamples = timestamps.length;

            // Process the timestamps in order
            processQuickAnalysisFrames(timestamps, 0);
        }

        // Process frames at specific timestamps for quick analysis
        function processQuickAnalysisFrames(timestamps, index) {
            if (!isPerformingQuickAnalysis || index >= timestamps.length) {
                completeQuickAnalysis();
                return;
            }

            const timestamp = timestamps[index];
            const progress = Math.round((index / timestamps.length) * 100);
            progressBar.style.width = `${progress}%`;
            progressBar.textContent = `Analyzing: ${progress}%`;

            // Seek to the specific timestamp
            processingVideo.currentTime = timestamp;
            isWaitingForSeek = true;

            // Wait for the seek to complete
            const seekHandler = () => {
                if (Math.abs(processingVideo.currentTime - timestamp) > 0.1 && isWaitingForSeek) {
                    // Still seeking
                    return;
                }

                processingVideo.removeEventListener('timeupdate', seekHandler);
                isWaitingForSeek = false;

                // Capture and analyze the frame
                analyzeCurrentVideoFrame(timestamp, (qrCodesFound, gridSize) => {
                    // Track QR detections for estimating total count
                    quickAnalysisQRs += qrCodesFound;

                    // Update grid size estimation (take the maximum encountered)
                    if (gridSize > estimatedGridSize) {
                        estimatedGridSize = gridSize;
                    }

                    // Time tracking for frame rate estimation
                    if (qrCodesFound > 0) {
                        foundQRTimeRanges.push({
                            time: timestamp,
                            qrCount: qrCodesFound,
                            gridSize: gridSize
                        });
                    }

                    // Process next timestamp
                    processQuickAnalysisFrames(timestamps, index + 1);
                });
            };

            processingVideo.addEventListener('timeupdate', seekHandler);
        }

        // Analyze a single video frame during quick analysis
        function analyzeCurrentVideoFrame(timestamp, callback) {
            canvas.width = processingVideo.videoWidth;
            canvas.height = processingVideo.videoHeight;
            ctx.drawImage(processingVideo, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            // Try enhanced image for better detection
            const enhancedData = enhanceImageForQRDetection(imageData);

            // First try to detect metadata with grid information
            let foundGrid = tryDetectMetadataWithGridSize(enhancedData, timestamp);

            // Count detected QR codes
            let qrCodesDetected = 0;

            // Try multiple approaches for QR detection
            // First, try with the entire frame
            const qrCode = jsQR(enhancedData.data, enhancedData.width, enhancedData.height, {
                inversionAttempts: 'attemptBoth'
            });

            if (qrCode) {
                qrCodesDetected++;
                // Parse QR data to look for metadata
                const data = qrCode.data;
                if (data.startsWith('QR-BOOTSTRAP')) {
                    // This is a metadata QR, extract grid size if available
                    const gridMatch = data.match(/GRID=(\d+)/);
                    if (gridMatch) {
                        foundGrid = parseInt(gridMatch[1]);
                    }
                }
            }

            // If we know there's a grid, try to detect multiple QRs in a grid layout
            if (foundGrid > 1) {
                // First update the qrGridSize to the one we detected
                qrGridSize = foundGrid;
                // Try to detect QRs in a grid layout based on the grid size
                const gridQRs = detectQRCodesInGrid(enhancedData, [], timestamp);
                qrCodesDetected = Math.max(qrCodesDetected, gridQRs.length);
            }

            // Return results to the caller
            callback(qrCodesDetected, foundGrid);
        }

        // Complete the quick analysis and show results
        function completeQuickAnalysis() {
            if (!isPerformingQuickAnalysis) return;

            isPerformingQuickAnalysis = false;
            progressBar.style.width = '100%';
            progressBar.textContent = 'Analysis Complete';

            // Re-enable buttons
            quickAnalysisBtn.disabled = false;
            processVideoBtn.disabled = false;

            // Calculate estimated frame rate, if we have enough data
            if (foundQRTimeRanges.length >= 2) {
                // Sort by timestamp
                foundQRTimeRanges.sort((a, b) => a.time - b.time);

                // Calculate average time difference between detected QR frames
                let totalTimeDiff = 0;
                let consecutiveFrames = 0;

                for (let i = 1; i < foundQRTimeRanges.length; i++) {
                    const timeDiff = foundQRTimeRanges[i].time - foundQRTimeRanges[i - 1].time;
                    // Filter out large gaps
                    if (timeDiff < 1.0) {
                        totalTimeDiff += timeDiff;
                        consecutiveFrames++;
                    }
                }

                if (consecutiveFrames > 0) {
                    const avgTimeDiff = totalTimeDiff / consecutiveFrames;
                    estimatedFrameRate = Math.round(1 / avgTimeDiff);
                } else {
                    // Fallback to a conservative estimate
                    estimatedFrameRate = 10;
                }
            } else {
                // Not enough data points, use a conservative estimate
                estimatedFrameRate = 10;
            }

            // Estimate total QR count
            // Method: (detected QRs / timestamps sampled) * (video duration * estimatedFrameRate) * estimatedGridSize
            const duration = processingVideo.duration;
            if (isFinite(duration) && duration > 0 && quickAnalysisSamples > 0) {
                const detectionRate = quickAnalysisQRs / quickAnalysisSamples;
                const totalFrames = Math.round(duration * estimatedFrameRate);
                estimatedQRCount = Math.round(detectionRate * totalFrames * estimatedGridSize);
            } else {
                // Fallback: Just multiply by 100 as a rough estimate
                estimatedQRCount = quickAnalysisQRs * 100;
            }

            // Update the grid size for the main processing
            qrGridSize = estimatedGridSize;

            // Show analysis results
            showLog(`
Quick Analysis Results:
---------------------
Estimated Frame Rate: ${estimatedFrameRate} fps
Estimated QR Grid Size: ${estimatedGridSize} QRs per frame
QR Codes Detected: ${quickAnalysisQRs} in ${quickAnalysisSamples} samples
Estimated Total QR Count: ~${estimatedQRCount}
            `, 'video');

            // Update the UI to show that we're ready for full processing
            videoFramesCounter.textContent = quickAnalysisSamples;
            videoQrCounter.textContent = quickAnalysisQRs;

            // Adjust processing strategy based on findings
            if (estimatedQRCount > 10000) {
                showLog('Large number of QR codes detected. Optimizing processing strategy for high-density content.', 'video');
                initialSampleRate = 0.2; // Use higher frequency sampling
            } else if (estimatedQRCount > 1000) {
                showLog('Moderate number of QR codes detected. Using balanced processing strategy.', 'video');
                initialSampleRate = 0.5;
            }

            // Return to the beginning of the video
            processingVideo.currentTime = 0;
        }

        // Reset analysis state without clearing the grid
        function resetAnalysisState() {
            // Reset analysis variables
            estimatedFrameRate = 0;
            estimatedQRCount = 0;
            estimatedGridSize = 1;
            quickAnalysisSamples = 0;
            quickAnalysisQRs = 0;
            isPerformingQuickAnalysis = false;
            foundQRTimeRanges = [];

            // Don't reset these as they'll be used by the main processor
            // qrGridSize = 1;
            // searchPhase = 'initial';
        }

        function startVideoProcessing() {
            if (!processingVideo.src) {
                showLog('No video loaded', 'video');
                return;
            }

            // Only partial reset - keep file data for continuing transfer
            resetState('video', true);
            isProcessingVideo = true;
            processVideoBtn.disabled = true;
            stopProcessingBtn.disabled = false;

            // If we have partial file data, show status
            if (currentFileId && fileHistory[currentFileId]) {
                const receivedCount = fileHistory[currentFileId].framesReceived.filter(Boolean).length;
                const totalFrames = fileHistory[currentFileId].totalFrames;
                const progress = Math.round((receivedCount / totalFrames) * 100);

                showLog(`Resuming processing for file: ${fileHistory[currentFileId].fileName}`, 'video');
                showLog(`Current progress: ${receivedCount}/${totalFrames} frames (${progress}%)`, 'video');

                if (receivedCount === totalFrames) {
                    showLog('⚠️ Note: All frames already received for this file! Looking for metadata now...', 'video');
                } else {
                    const missing = totalFrames - receivedCount;
                    showLog(`Looking for ${missing} missing frames...`, 'video');

                    // Show hint about which frames we're missing 
                    const missingFrames = fileHistory[currentFileId].framesReceived
                        .map((received, i) => received ? null : i)
                        .filter(i => i !== null);

                    if (missingFrames.length <= 20) {
                        showLog(`Missing frames: ${missingFrames.map(i => i + 1).join(', ')}`, 'video');
                    } else {
                        // Show just a sample of missing frames
                        showLog(`First few missing frames: ${missingFrames.slice(0, 10).map(i => i + 1).join(', ')}...`, 'video');
                    }
                }

                // Restore current data from file history
                startReceived = true;
                totalFramesExpected = fileHistory[currentFileId].totalFrames;
                fileName = fileHistory[currentFileId].fileName;
                fileSize = fileHistory[currentFileId].fileSize;
                framesData = [...fileHistory[currentFileId].framesData];
                framesReceived = [...fileHistory[currentFileId].framesReceived];
                qrGridSize = fileHistory[currentFileId].qrGridSize || 1;

                // Update visual display
                updateGrid('video');
            }

            const duration = processingVideo.duration;

            // Handle invalid duration more gracefully
            const validDuration = isFinite(duration) && duration > 0;
            if (!validDuration) {
                showLog('Warning: Video has invalid duration (Infinity). Will use time-based processing instead.', 'video');
                // Don't stop - continue with a default duration for processing
                const assumedDuration = 3600; // Assume 60 minutes for processing

                searchPhase = 'sequential';
                let fps = 15; // Higher frame rate to catch more QR codes
                totalFrames = 5000; // Process much more frames to ensure we catch all QR codes
                showLog(`Using time-based processing with ${totalFrames} frames for high density QR code detection`, 'video');
                currentProcessingFrame = 0;

                // Set up our own time tracking
                processingVideo.addEventListener('timeupdate', function () {
                    videoTimeDisplay.textContent = processingVideo.currentTime.toFixed(1) + 's';
                });

                processNextFrameBatch();
                return;
            }

            // Check if we have data from quick analysis
            if (estimatedFrameRate > 0 && estimatedQRCount > 0) {
                showLog(`Using results from quick analysis:
- Estimated Frame Rate: ${estimatedFrameRate} fps
- Estimated QR Grid Size: ${estimatedGridSize} QRs per frame
- Estimated Total QR Count: ~${estimatedQRCount}`, 'video');

                // Use the grid size information from quick analysis
                qrGridSize = estimatedGridSize;

                // If we already found metadata and know we're looking for QR codes
                if (startReceived) {
                    showLog("Already found metadata during quick analysis. Focusing on areas with QR codes...", 'video');
                    processFocusedAreas();
                    return;
                }

                // If we detected a significant number of QR codes
                if (quickAnalysisQRs > 5) {
                    // Calculate optimal sampling based on estimated frame rate and QR density
                    let samplesPerSecond = Math.min(estimatedFrameRate, 15); // Cap at 15 samples per second

                    // For very high density content (many QRs per frame), increase sampling rate
                    if (estimatedGridSize > 4) {
                        samplesPerSecond = Math.min(estimatedFrameRate, 20); // Cap at 20 samples per second for high grid sizes
                    }

                    // For videos with estimated high QR counts, use focused sampling
                    if (estimatedQRCount > 10000) {
                        // Focus on time ranges where QR codes were found
                        showLog("High QR code density detected. Using focused processing on QR-rich regions...", 'video');
                        processFocusedAreas();
                    } else {
                        // For medium density, use a balanced approach
                        showLog("Using balanced approach based on quick analysis results...", 'video');
                        searchPhase = 'sequential';
                        totalFrames = Math.min(10000, Math.ceil(duration * samplesPerSecond));
                        currentProcessingFrame = 0;
                        processNextFrameBatch();
                    }
                } else {
                    // If we found few QRs during quick analysis, perform more intensive scanning
                    showLog("Few QR codes detected in quick analysis. Performing more intensive scan...", 'video');

                    // Set up search strategy based on video length
                    if (duration > 10) {
                        // For longer videos, use smart search
                        showLog(`Using enhanced search strategy for ${duration.toFixed(1)}s video`, 'video');
                        searchPhase = 'initial';

                        // Set up frames for intensive scanning, especially at the beginning
                        const earlyTimePoints = [];

                        // First 10 seconds at very high density (every ~50ms)
                        for (let t = 0; t < Math.min(10, duration); t += 0.05) {
                            earlyTimePoints.push(t);
                        }

                        // Process these points first
                        processSpecificFrames(earlyTimePoints, () => {
                            // If we found metadata, skip to processing that region
                            if (startReceived) {
                                showLog("Found metadata frame in intensive scan! Now searching for all chunks...", 'video');
                                processFocusedAreas();
                                return;
                            }

                            // If still no metadata, proceed with regular smart search
                            processSmartSearch();
                        });
                    } else {
                        // For short videos, use sequential processing
                        searchPhase = 'sequential';
                        let fps = 15; // Higher frame rate for thorough scanning

                        const maxFrames = 10000; // Safety limit
                        totalFrames = Math.min(maxFrames, Math.ceil(duration * fps));

                        showLog(`Sequential processing with intensive sampling: ${totalFrames} frames from ${duration.toFixed(1)}s video`, 'video');
                        currentProcessingFrame = 0;
                        processNextFrameBatch();
                    }
                }
            } else {
                // No quick analysis data available, use standard approach

                // Set up search strategy based on video length
                if (duration > 10 && isFinite(duration)) {
                    // For longer videos, use smart search
                    showLog(`Using smart search strategy for ${duration.toFixed(1)}s video`, 'video');
                    searchPhase = 'initial';

                    // First, do an intensive scan of the first few seconds
                    // This is critical for finding metadata frames which are usually at the start
                    showLog("First performing intensive scan of video beginning to find metadata frames...", 'video');

                    // Create a list of time points focused heavily on the first few seconds
                    const earlyTimePoints = [];

                    // First 10 seconds at very high density (every ~100ms)
                    for (let t = 0; t < Math.min(10, duration); t += 0.1) {
                        earlyTimePoints.push(t);
                    }

                    // Process these points first
                    processSpecificFrames(earlyTimePoints, () => {
                        // If we found metadata, skip to processing that region
                        if (startReceived) {
                            showLog("Found metadata frame in video beginning! Now searching for all chunks...", 'video');
                            processFocusedAreas();
                            return;
                        }

                        // If we didn't find metadata in the beginning, continue with regular search
                        showLog("No metadata found in video beginning, continuing with full video scan...", 'video');

                        // Adjust initial sample rate based on video length
                        if (duration > 300) { // > 5 minutes
                            initialSampleRate = 5; // Check every 5 seconds initially (doubled density)
                        } else if (duration > 120) { // > 2 minutes
                            initialSampleRate = 3; // Check every 3 seconds initially
                        } else if (duration > 60) { // > 1 minute
                            initialSampleRate = 1; // Check every 1 second initially
                        } else {
                            initialSampleRate = 0.5; // Check every 0.5 seconds for shorter videos
                        }

                        // Safety check - set upper limit on samples
                        const MAX_SAMPLES = 5000; // Increased from 1000
                        const safeInitialSampleRate = Math.max(initialSampleRate, duration / MAX_SAMPLES);

                        // Calculate initial sparse sampling
                        const initialSampleCount = Math.min(MAX_SAMPLES, Math.ceil(duration / safeInitialSampleRate));
                        totalFrames = initialSampleCount;

                        showLog(`Initial scan: ${initialSampleCount} samples at ${safeInitialSampleRate.toFixed(1)}s intervals`, 'video');

                        // Set up frames for the initial sparse sampling
                        currentProcessingFrame = 0;

                        // Start with initial sparse sampling to find QR code clusters
                        processSmartSearch();
                    });
                } else {
                    // For short videos, use sequential processing
                    searchPhase = 'sequential';
                    let fps = 10; // Default for short videos

                    // Safety check for very long videos
                    if (duration > 3600) { // > 1 hour
                        fps = 1; // Very sparse sampling for extremely long videos
                    } else if (duration > 600) { // > 10 minutes
                        fps = 2;
                    }

                    const maxFrames = 10000; // Safety limit
                    totalFrames = Math.min(maxFrames, Math.ceil(duration * fps));

                    showLog(`Sequential processing: ${totalFrames} frames from ${duration.toFixed(1)}s video`, 'video');
                    currentProcessingFrame = 0;
                    processNextFrameBatch();
                }
            }
        }

        // Smart search with adaptive strategy
        function processSmartSearch() {
            const duration = processingVideo.duration;

            // Double-check duration validity
            if (!isFinite(duration) || duration <= 0) {
                showLog('Invalid video duration detected in smart search. Switching to sequential processing.', 'video');
                searchPhase = 'sequential';
                let fps = 2; // Very conservative framerate
                totalFrames = 100; // Just process a small number of frames
                currentProcessingFrame = 0;
                processNextFrameBatch();
                return;
            }

            if (searchPhase === 'initial') {
                showLog(`Starting initial sparse sampling phase...`, 'video');

                // Create a list of frames at reasonable intervals (with safety check for duration)
                const samples = [];
                const maxSamples = 1000; // Prevent extremely large arrays
                const effectiveRate = Math.max(initialSampleRate, duration / maxSamples);

                for (let time = 0; time < duration; time += effectiveRate) {
                    samples.push(time);
                }

                // Last frame if not included
                if (samples[samples.length - 1] < duration - 1) {
                    samples.push(duration - 1);
                }

                // Process these sample frames
                processSpecificFrames(samples, () => {
                    // After initial phase completes
                    if (startReceived) {
                        // We found metadata! Move to sequential processing around found areas
                        searchPhase = 'sequential';
                        showLog(`Found QR metadata! Switching to sequential processing.`, 'video');

                        // If we haven't found all frames yet, determine processing range
                        const missingFrames = framesReceived.filter(received => !received).length;

                        if (missingFrames > 0) {
                            // Focus on processing promising areas
                            let minTime = duration;
                            let maxTime = 0;

                            // Find time range where QR codes were detected
                            foundQRTimeRanges.forEach(range => {
                                minTime = Math.min(minTime, range.start);
                                maxTime = Math.max(maxTime, range.end);
                            });

                            // Add buffer zones (10% of duration on either side)
                            const buffer = Math.min(10, duration * 0.1);
                            minTime = Math.max(0, minTime - buffer);
                            maxTime = Math.min(duration, maxTime + buffer);

                            showLog(`Processing focused time range: ${minTime.toFixed(1)}s to ${maxTime.toFixed(1)}s`, 'video');
                            processTimeRange(minTime, maxTime);
                        }
                    } else {
                        // No metadata found yet, switch to binary search
                        searchPhase = 'binary';
                        showLog(`No QR metadata found in sparse sampling. Switching to binary search.`, 'video');

                        // Set up binary search on the entire video
                        binarySearchRanges = [{ start: 0, end: duration, depth: 0 }];
                        processBinarySearchRanges();
                    }
                });
            } else if (searchPhase === 'binary') {
                processBinarySearchRanges();
            }
        }

        // Process a specific list of timestamps with batch processing for large arrays
        function processSpecificFrames(timePoints, onComplete) {
            // Process in smaller batches to avoid stack overflow
            const BATCH_SIZE = 100;
            let currentBatch = 0;
            const totalBatches = Math.ceil(timePoints.length / BATCH_SIZE);

            function processBatch(batchIndex) {
                if (batchIndex >= totalBatches || !isProcessingVideo) {
                    if (onComplete) onComplete();
                    return;
                }

                const startIndex = batchIndex * BATCH_SIZE;
                const endIndex = Math.min((batchIndex + 1) * BATCH_SIZE, timePoints.length);
                const currentBatchPoints = timePoints.slice(startIndex, endIndex);

                // Process this batch of points
                let pointIndex = 0;

                function processNextPoint() {
                    if (pointIndex >= currentBatchPoints.length || !isProcessingVideo) {
                        // This batch is done, move to next batch
                        setTimeout(() => {
                            processBatch(batchIndex + 1);
                        }, 50);
                        return;
                    }

                    const time = currentBatchPoints[pointIndex];
                    processingVideo.currentTime = time;

                    processingVideo.onseeked = () => {
                        try {
                            // Process the current frame
                            captureAndProcessFrame(time);

                            // Update progress based on overall position
                            const overallIndex = startIndex + pointIndex;
                            updateProgressBar(overallIndex + 1, timePoints.length);

                            // Check if we should fast-forward based on QR detection
                            if (startReceived && fastForwardMode) {
                                // Check if we've found all frames
                                const missingFrames = framesReceived.filter(received => !received).length;
                                if (missingFrames === 0) {
                                    showLog(`All frames found! Completing processing.`, 'video');
                                    if (onComplete) onComplete();
                                    return;
                                }
                            }

                            // Move to next point
                            pointIndex++;

                            // Continue to next frame with slight delay
                            setTimeout(processNextPoint, 30);
                        } catch (err) {
                            showLog(`Error processing frame at ${time}s: ${err.message}`, 'video');
                            // Move to next point even if there's an error
                            pointIndex++;
                            setTimeout(processNextPoint, 30);
                        }
                    };
                }

                // Start processing this batch
                processNextPoint();
            }

            // Start with the first batch
            processBatch(0);
        }

        // Process a specific time range with a given frames per second
        function processTimeRange(startTime, endTime, fps = 10) {
            const duration = endTime - startTime;
            const framesToProcess = Math.ceil(duration * fps);

            const timePoints = [];
            for (let i = 0; i < framesToProcess; i++) {
                const time = startTime + (i * duration) / framesToProcess;
                timePoints.push(time);
            }

            showLog(`Processing ${framesToProcess} frames in time range ${startTime.toFixed(1)}s - ${endTime.toFixed(1)}s`, 'video');
            processSpecificFrames(timePoints, () => {
                // Check if we've found all frames
                if (startReceived) {
                    const missingFrames = framesReceived.filter(received => !received).length;

                    if (missingFrames === 0) {
                        showLog(`All frames found! Processing complete.`, 'video');
                        assembleAndDownloadFile('video');
                    } else {
                        showLog(`Still missing ${missingFrames} frames after focused processing.`, 'video');
                        // Try processing the entire video at a lower frame rate
                        processEntireVideoAtLowerRate();
                    }
                } else {
                    showLog(`No QR metadata found in focused processing.`, 'video');
                    // Try processing the entire video at a lower frame rate
                    processEntireVideoAtLowerRate();
                }
            });
        }

        // Process binary search ranges
        function processBinarySearchRanges() {
            if (binarySearchRanges.length === 0 || !isProcessingVideo) {
                // No more ranges to process - move to sequential processing
                searchPhase = 'sequential';
                showLog(`Binary search complete. Processing entire video.`, 'video');
                processEntireVideoAtLowerRate();
                return;
            }

            // Sort ranges by depth (process shallow depths first)
            binarySearchRanges.sort((a, b) => a.depth - b.depth);

            // Get next range to process
            const range = binarySearchRanges.shift();
            const midPoint = (range.start + range.end) / 2;

            // Sample points within this range (start, mid, end)
            const samplePoints = [
                range.start,
                midPoint - (range.end - range.start) / 4,
                midPoint,
                midPoint + (range.end - range.start) / 4,
                range.end
            ].filter((value, index, self) => {
                // Remove duplicates and ensure all points are within video duration
                return self.indexOf(value) === index && value >= 0 && value <= processingVideo.duration;
            });

            showLog(`Binary search at depth ${range.depth}: ${range.start.toFixed(1)}s - ${range.end.toFixed(1)}s`, 'video');

            processSpecificFrames(samplePoints, () => {
                if (startReceived) {
                    // We found metadata! Move to sequential processing
                    searchPhase = 'sequential';
                    showLog(`Found QR metadata! Switching to sequential processing.`, 'video');

                    // Focus on found areas
                    processFocusedAreas();
                } else if (range.end - range.start > 10 && range.depth < 3) {
                    // If range is still large and we're not too deep, create sub-ranges
                    const newDepth = range.depth + 1;
                    binarySearchRanges.push(
                        { start: range.start, end: midPoint, depth: newDepth },
                        { start: midPoint, end: range.end, depth: newDepth }
                    );
                    processBinarySearchRanges();
                } else {
                    // Continue with the next range
                    processBinarySearchRanges();
                }
            });
        }

        // Process focused areas where QR codes were found
        function processFocusedAreas() {
            if (foundQRTimeRanges.length === 0) {
                // No focused areas found, process the entire video
                processEntireVideoAtLowerRate();
                return;
            }

            // Merge overlapping ranges
            foundQRTimeRanges.sort((a, b) => a.start - b.start);
            const mergedRanges = [foundQRTimeRanges[0]];

            for (let i = 1; i < foundQRTimeRanges.length; i++) {
                const currentRange = foundQRTimeRanges[i];
                const lastRange = mergedRanges[mergedRanges.length - 1];

                // Add buffer for merging (2 second buffer)
                if (currentRange.start <= lastRange.end + 2) {
                    // Merge ranges
                    lastRange.end = Math.max(lastRange.end, currentRange.end);
                } else {
                    // Add as new range
                    mergedRanges.push(currentRange);
                }
            }

            // Process each merged range with a higher frame rate
            let rangeIndex = 0;

            function processNextRange() {
                if (rangeIndex >= mergedRanges.length || !isProcessingVideo) {
                    // All ranges processed
                    if (startReceived) {
                        const missingFrames = framesReceived.filter(received => !received).length;
                        if (missingFrames === 0) {
                            showLog(`All frames found! Processing complete.`, 'video');
                            assembleAndDownloadFile('video');
                        } else {
                            showLog(`Still missing ${missingFrames} frames after focused processing.`, 'video');
                            processEntireVideoAtLowerRate();
                        }
                    } else {
                        processEntireVideoAtLowerRate();
                    }
                    return;
                }

                const range = mergedRanges[rangeIndex];
                showLog(`Processing focused range ${rangeIndex + 1}/${mergedRanges.length}: ${range.start.toFixed(1)}s - ${range.end.toFixed(1)}s`, 'video');

                // Process this range with a higher frame rate (15fps)
                processTimeRange(range.start, range.end, 15);
                rangeIndex++;
                processNextRange();
            }

            processNextRange();
        }

        // Process the entire video at an appropriate frame rate
        function processEntireVideoAtLowerRate() {
            const duration = processingVideo.duration;

            // Use higher frame rates for dense QR code videos
            // Dynamically adjust based on what we already found
            let fps;

            if (framesCapturedWithQR > 0 && capturedFramesCount > 0) {
                // Calculate QR density from what we've seen so far
                const qrDensity = framesCapturedWithQR / capturedFramesCount;

                if (qrDensity > 0.3) {
                    // Many QR codes found - high density video (likely 30fps QR transmission)
                    fps = Math.min(25, Math.max(20, Math.floor(qrDensity * 50)));
                    showLog(`High QR density detected (${Math.round(qrDensity * 100)}%), using ${fps} fps processing rate`, 'video');
                } else if (qrDensity > 0.1) {
                    // Medium density
                    fps = 15;
                } else {
                    // Low density, but still found some QR codes
                    fps = 8;
                }
            } else {
                // Default if we don't have data yet
                fps = duration > 300 ? 5 : duration > 60 ? 10 : 15;
            }

            // Calculate frames but avoid extreme values
            const maxFrames = 50000; // Allow up to 50,000 frames for very dense videos
            totalFrames = Math.min(maxFrames, Math.ceil(duration * fps));
            currentProcessingFrame = 0;

            showLog(`Processing entire video at ${fps} fps (${totalFrames} total frames) to find all QR codes`, 'video');
            processNextFrameBatch();
        }

        // Extract region of interest for video frames
        function extractVideoROI(canvas, videoElement) {
            // Define ROI size - make it adaptive to video size
            // For typical videos, use a centered region that's about 70% of the video size
            // This helps focus on the center where QR codes are most likely to be
            const roiWidthPct = 0.7;
            const roiHeightPct = 0.7;

            const roiWidth = Math.floor(canvas.width * roiWidthPct);
            const roiHeight = Math.floor(canvas.height * roiHeightPct);

            // Calculate the top-left corner to center the ROI
            const roiLeft = Math.floor((canvas.width - roiWidth) / 2);
            const roiTop = Math.floor((canvas.height - roiHeight) / 2);

            // Extract the region of interest
            try {
                return ctx.getImageData(roiLeft, roiTop, roiWidth, roiHeight);
            } catch (err) {
                console.error("Error extracting video ROI:", err);
                // Fallback to full frame if ROI extraction fails
                return ctx.getImageData(0, 0, canvas.width, canvas.height);
            }
        }

        // Capture and process a single frame at the current time position
        function captureAndProcessFrame(timePosition) {
            canvas.width = processingVideo.videoWidth;
            canvas.height = processingVideo.videoHeight;
            ctx.drawImage(processingVideo, 0, 0);

            capturedFramesCount++;
            videoFramesCounter.textContent = capturedFramesCount;

            try {
                // Fix for "Canvas2D: Multiple readback operations using getImageData are faster with the willReadFrequently attribute set to true"
                if (!canvas.willReadFrequently) {
                    canvas.willReadFrequently = true;
                    // Re-create the context with the new attribute
                    ctx = canvas.getContext('2d', { willReadFrequently: true });
                    // Redraw the current frame after updating context
                    ctx.drawImage(processingVideo, 0, 0);
                }
                // Save frame for diagnostics if enabled
                if (diagnosticsEnabled) {
                    saveFrameForDiagnostics(canvas, capturedFramesCount, timePosition);
                }

                // Array to hold detected QR codes
                const qrCodes = [];

                // First try with ROI (Region of Interest)
                const roiData = extractVideoROI(canvas, processingVideo);

                // Try to detect metadata with grid size information in ROI
                // This is more efficient than scanning the whole frame
                tryDetectMetadataWithGridSize(roiData, timePosition);

                // If we know we're in grid mode, try to detect QRs in a grid layout
                let foundInGrid = false;
                if (qrGridSize > 1) {
                    // For grid layouts, we might need the full frame
                    // as the QR codes could be distributed throughout
                    const fullImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    foundInGrid = detectQRCodesInGrid(fullImageData, qrCodes, timePosition);
                } else {
                    // For single QR, try the ROI first
                    // Use optimized parameters for QR detection
                    const qrCode = jsQR(roiData.data, roiData.width, roiData.height, {
                        inversionAttempts: 'attemptBoth', // Try both non-inverted and inverted
                        canOverwriteImage: true, // Allow overwriting for performance
                        maxModuleCount: 177  // Support high capacity QR codes (version 40)
                    });

                    if (qrCode) {
                        // Adjust QR code coordinates to match the full canvas
                        const roiOffsetX = Math.floor((canvas.width - roiData.width) / 2);
                        const roiOffsetY = Math.floor((canvas.height - roiData.height) / 2);
                        adjustQRCodeCoordinates(qrCode, roiOffsetX, roiOffsetY);

                        qrCodes.push(qrCode);
                        updateQRSizeStats(qrCode);
                        trackFrameRate(timePosition);
                        foundInGrid = true; // Mark as found so we don't do the full frame scan
                    }
                }

                // If not found in ROI or grid, try full frame scan
                if (!foundInGrid && qrCodes.length === 0) {
                    // Try with the full frame
                    const fullImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                    // Use optimized parameters for QR detection
                    const qrCode = jsQR(fullImageData.data, fullImageData.width, fullImageData.height, {
                        inversionAttempts: 'attemptBoth',
                        canOverwriteImage: true,
                        maxModuleCount: 177
                    });

                    if (qrCode) {
                        qrCodes.push(qrCode);
                        updateQRSizeStats(qrCode);
                        trackFrameRate(timePosition);

                        // If we find in full frame but not ROI, log it to help tune ROI size
                        if (capturedFramesCount % 20 === 0) {
                            console.log("QR found in full frame but not in ROI - may need to adjust ROI size");
                        }
                    }
                }

                // Try enhanced detection if no QR codes found
                if (qrCodes.length === 0 && capturedFramesCount % 10 === 0) {
                    try {
                        // Only try enhancement periodically to save performance
                        const enhancedImageData = enhanceImageForQRDetection(
                            qrCodes.length === 0 ? roiData : ctx.getImageData(0, 0, canvas.width, canvas.height)
                        );

                        const enhancedQrCode = jsQR(enhancedImageData.data, enhancedImageData.width, enhancedImageData.height, {
                            inversionAttempts: 'attemptBoth',
                            canOverwriteImage: true,
                            maxModuleCount: 177
                        });

                        if (enhancedQrCode) {
                            // If we used ROI for enhancement, adjust coordinates
                            if (qrCodes.length === 0) {
                                const roiOffsetX = Math.floor((canvas.width - roiData.width) / 2);
                                const roiOffsetY = Math.floor((canvas.height - roiData.height) / 2);
                                adjustQRCodeCoordinates(enhancedQrCode, roiOffsetX, roiOffsetY);
                            }

                            qrCodes.push(enhancedQrCode);
                            showLog(`QR detected after image enhancement! Frame ${capturedFramesCount}`, 'video');
                        }
                    } catch (err) {
                        console.error("Error in enhanced detection:", err);
                    }
                }

                // Process all detected QR codes
                if (qrCodes.length > 0) {
                    framesCapturedWithQR++;
                    videoQrCounter.textContent = framesCapturedWithQR;

                    // Draw all QR codes on the canvas
                    qrCodes.forEach((qrCode, index) => {
                        // Mark this QR on the video preview with different colors
                        const colors = ['lime', 'cyan', 'yellow', 'magenta', 'red', 'blue'];
                        ctx.strokeStyle = colors[index % colors.length];
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                        ctx.lineTo(qrCode.location.topRightCorner.x, qrCode.location.topRightCorner.y);
                        ctx.lineTo(qrCode.location.bottomRightCorner.x, qrCode.location.bottomRightCorner.y);
                        ctx.lineTo(qrCode.location.bottomLeftCorner.x, qrCode.location.bottomLeftCorner.y);
                        ctx.lineTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                        ctx.stroke();

                        // Add QR code index if multiple detected
                        if (qrCodes.length > 1) {
                            const centerX = (qrCode.location.topLeftCorner.x + qrCode.location.bottomRightCorner.x) / 2;
                            const centerY = (qrCode.location.topLeftCorner.y + qrCode.location.bottomRightCorner.y) / 2;
                            ctx.fillStyle = 'white';
                            ctx.strokeStyle = 'black';
                            ctx.lineWidth = 2;
                            ctx.font = 'bold 16px monospace';
                            ctx.strokeText(`QR #${index + 1}`, centerX - 20, centerY);
                            ctx.fillText(`QR #${index + 1}`, centerX - 20, centerY);
                        }

                        // Process the QR data
                        processQrData(qrCode.data, 'video');
                    });

                    // Store time position where QR was found (with safe handling)
                    try {
                        foundQRTimeRanges.push({
                            start: Math.max(0, timePosition - 2), // 2 sec buffer before
                            end: Math.min(processingVideo.duration, timePosition + 2), // 2 sec buffer after
                            qrCount: qrCodes.length,
                            timestamp: Date.now()
                        });

                        // Log detection information
                        if (qrCodes.length > 1) {
                            showLog(`Found ${qrCodes.length} QR codes in a single frame at ${timePosition.toFixed(2)}s!`, 'video');
                        }
                    } catch (e) {
                        showLog(`Warning: Could not store QR time range: ${e.message}`, 'video');
                        // If array is getting too large, consolidate ranges to avoid errors
                        if (foundQRTimeRanges.length > 500) {
                            const mergedRanges = [];
                            let lastRange = null;

                            // Simple consolidation by merging adjacent ranges
                            foundQRTimeRanges.sort((a, b) => a.start - b.start).forEach(range => {
                                if (!lastRange) {
                                    lastRange = { ...range };
                                    mergedRanges.push(lastRange);
                                } else if (range.start <= lastRange.end + 4) {
                                    // Merge with previous range
                                    lastRange.end = Math.max(lastRange.end, range.end);
                                } else {
                                    // New separate range
                                    lastRange = { ...range };
                                    mergedRanges.push(lastRange);
                                }
                            });

                            foundQRTimeRanges = mergedRanges;
                            showLog(`Consolidated ${foundQRTimeRanges.length} time ranges to avoid memory issues`, 'video');
                        }
                    }
                }
            } catch (err) {
                // Silent catch - continue processing
                console.error("Error in captureAndProcessFrame:", err);
            }
        }

        function stopVideoProcessing() {
            isProcessingVideo = false;
            isPerformingQuickAnalysis = false;
            quickAnalysisBtn.disabled = false;
            processVideoBtn.disabled = false;
            stopProcessingBtn.disabled = true;

            // Don't reset file state - keep tracking progress
            showLog('Processing stopped - file progress maintained', 'video');

            if (currentFileId && fileHistory[currentFileId]) {
                const receivedCount = fileHistory[currentFileId].receivedCount;
                const totalFrames = fileHistory[currentFileId].totalFrames;
                const progress = Math.round((receivedCount / totalFrames) * 100);

                showLog(`Current file progress: ${receivedCount}/${totalFrames} frames (${progress}%)`, 'video');

                if (receivedCount === totalFrames) {
                    showLog('All frames received for current file!', 'video');
                } else {
                    const missing = totalFrames - receivedCount;
                    showLog(`Still missing ${missing} frames - will capture them when processing resumes`, 'video');
                }
            }
        }

        function processNextFrameBatch() {
            if (!isProcessingVideo) return;

            // Calculate dynamic batch size based on performance and video characteristics
            // Use larger batches for videos with fewer found QRs to speed up processing
            let batchSize;
            if (capturedFramesCount > 0) {
                const qrRatio = framesCapturedWithQR / capturedFramesCount;
                if (qrRatio > 0.5) {
                    // High QR density - use smaller batches to process more carefully
                    batchSize = 10;
                } else if (qrRatio > 0.1) {
                    // Medium QR density - moderate batch size
                    batchSize = 20;
                } else {
                    // Low QR density - process more frames at once
                    batchSize = 50;
                }
            } else {
                // No data yet - start with moderate batch size
                batchSize = 25;
            }

            // Handle very large videos by ensuring reasonable progress
            if (totalFrames > 10000) {
                batchSize = Math.max(batchSize, Math.floor(totalFrames / 500)); // At least 500 batches
            }

            const startFrame = currentProcessingFrame;
            const endFrame = Math.min(startFrame + batchSize, totalFrames);

            if (startFrame % 20 === 0 || startFrame === 0) {
                showLog(`Processing frames ${startFrame + 1} to ${endFrame} of ${totalFrames}`, 'video');
            }

            // For videos with Infinity duration, use time-based increments
            if (!isFinite(processingVideo.duration) || processingVideo.duration <= 0) {
                // Update time display
                videoTimeDisplay.textContent = processingVideo.currentTime.toFixed(1) + 's';

                // For Infinity duration, use time increments instead of duration-based calculations
                processingVideo.currentTime += 1; // Move forward 1 second

                // Use requestAnimationFrame instead of nested setTimeout
                requestAnimationFrame(() => {
                    captureAndProcessFrame(processingVideo.currentTime);
                    currentProcessingFrame++;
                    updateProgressBar(currentProcessingFrame, totalFrames);
                    requestAnimationFrame(processNextFrameBatch);
                });
                return;
            }

            processingVideo.onseeked = () => {
                isWaitingForSeek = false; // Clear the seek waiting flag

                // Create and initialize context with willReadFrequently only once
                if (!canvas.willReadFrequently) {
                    // Set canvas size
                    canvas.width = processingVideo.videoWidth;
                    canvas.height = processingVideo.videoHeight;
                    // Create optimized context for frequent pixel reading
                    ctx = canvas.getContext('2d', { willReadFrequently: true });
                    canvas.willReadFrequently = true;
                }

                // Process the current frame
                ctx.drawImage(processingVideo, 0, 0);

                capturedFramesCount++;
                videoFramesCounter.textContent = capturedFramesCount;

                try {
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                    // Use a Web Worker for QR detection if supported
                    // This is a fallback using direct detection when workers aren't available
                    const qrCode = jsQR(imageData.data, imageData.width, imageData.height, {
                        inversionAttempts: 'dontInvert'
                    });

                    if (qrCode) {
                        // Mark this frame on the video preview
                        ctx.strokeStyle = 'lime';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                        ctx.lineTo(qrCode.location.topRightCorner.x, qrCode.location.topRightCorner.y);
                        ctx.lineTo(qrCode.location.bottomRightCorner.x, qrCode.location.bottomRightCorner.y);
                        ctx.lineTo(qrCode.location.bottomLeftCorner.x, qrCode.location.bottomLeftCorner.y);
                        ctx.lineTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                        ctx.stroke();

                        // Process the QR data
                        framesCapturedWithQR++;
                        videoQrCounter.textContent = framesCapturedWithQR;
                        processQrData(qrCode.data, 'video');

                        // Store time range where QR was found for better future processing
                        try {
                            foundQRTimeRanges.push({
                                start: Math.max(0, processingVideo.currentTime - 0.5),
                                end: Math.min(processingVideo.duration, processingVideo.currentTime + 0.5)
                            });
                        } catch (e) {
                            console.error("Error storing QR time range:", e);
                        }
                    }
                } catch (err) {
                    // Log error but continue processing
                    console.error("Error processing frame:", err);
                }

                // Move to next frame
                currentProcessingFrame++;
                updateProgressBar(currentProcessingFrame, totalFrames);

                // Use requestAnimationFrame for better performance and to avoid setTimeout violations
                if (currentProcessingFrame < endFrame && isProcessingVideo) {
                    // Process next frame in the current batch using requestAnimationFrame
                    requestAnimationFrame(() => seekToFrame(currentProcessingFrame));
                } else if (currentProcessingFrame < totalFrames && isProcessingVideo) {
                    // Process next batch
                    requestAnimationFrame(processNextFrameBatch);
                } else {
                    // Done processing
                    if (isProcessingVideo) {
                        showLog('Video processing complete', 'video');
                        stopVideoProcessing();

                        // Update completion stats
                        showLog(`Processed ${capturedFramesCount} frames, found QR codes in ${framesCapturedWithQR} frames`, 'video');

                        // Check if we found all frames
                        if (startReceived && framesReceived.every(Boolean)) {
                            assembleAndDownloadFile('video');
                        } else if (startReceived) {
                            const missingFrames = framesReceived
                                .map((received, i) => received ? null : i + 1)
                                .filter(Boolean);

                            if (missingFrames.length > 20) {
                                showLog(`Missing ${missingFrames.length} frames`, 'video');
                            } else {
                                showLog(`Missing frames: ${missingFrames.join(', ')}`, 'video');
                            }

                            // Offer to continue processing if we haven't processed the whole video
                            if (currentProcessingFrame < totalFrames - 1) {
                                showLog('Continuing to process more frames to find missing QR codes...', 'video');
                                requestAnimationFrame(() => {
                                    if (isProcessingVideo) return; // Already restarted
                                    startVideoProcessing();
                                });
                            } else {
                                showLog('Processed all frames but still missing some QR codes.', 'video');
                                showLog('Try playing the video manually to catch missing frames.', 'video');
                            }
                        }
                    }
                }
            };

            // Start processing by seeking to the first frame in the batch
            isWaitingForSeek = true;
            lastSeekTime = Date.now();
            seekToFrame(startFrame);

            // Safety check to prevent getting stuck
            // If seek operation doesn't complete within 2 seconds, force continue
            setTimeout(() => {
                if (isWaitingForSeek && Date.now() - lastSeekTime > 2000) {
                    showLog(`Seek timeout at frame ${currentProcessingFrame}, forcing continue`, 'video');
                    isWaitingForSeek = false;
                    currentProcessingFrame++;

                    if (currentProcessingFrame < totalFrames && isProcessingVideo) {
                        setTimeout(processNextFrameBatch, 10);
                    } else {
                        showLog('Video processing complete (with timeouts)', 'video');
                        stopVideoProcessing();
                    }
                }
            }, 2000);
        }

        function seekToFrame(frameIndex) {
            // Check if we need to prioritize areas where QR codes were already found
            if (foundQRTimeRanges.length > 0 && frameIndex > totalFrames * 0.3) {
                // After processing 30% of the video normally, start focusing on promising areas

                // Check if we're in a batch that should prioritize QR areas
                if (frameIndex % 20 === 0) { // Every 20 frames
                    // Find closest QR range to current position
                    const currentTime = (frameIndex * processingVideo.duration) / totalFrames;
                    let bestRange = null;
                    let bestDistance = Infinity;

                    for (const range of foundQRTimeRanges) {
                        const midpoint = (range.start + range.end) / 2;
                        const distance = Math.abs(midpoint - currentTime);

                        if (distance < bestDistance) {
                            bestDistance = distance;
                            bestRange = range;
                        }
                    }

                    // If we found a close range, bias our next several frames toward it
                    if (bestRange && bestDistance < processingVideo.duration / 4) {
                        // Calculate a time within this range
                        const rangeWidth = bestRange.end - bestRange.start;
                        const positionInRange = (frameIndex % 10) / 10; // Position 0-1 within range
                        const targetTime = bestRange.start + (rangeWidth * positionInRange);

                        // Use this target time with small jitter
                        const jitter = Math.random() * 0.03;
                        processingVideo.currentTime = Math.min(
                            targetTime + jitter,
                            processingVideo.duration - 0.1
                        );

                        if (frameIndex % 10 === 0) {
                            showLog(`Focusing on QR region at ${processingVideo.currentTime.toFixed(2)}s`, 'video');
                        }
                        return;
                    }
                }
            }

            // Normal timestamp calculation with adaptive frame rate
            let time;

            // Use smart distribution of frames - more at the beginning, fewer later
            if (frameIndex < totalFrames * 0.5) {
                // First half of frames: normal distribution
                time = (frameIndex * processingVideo.duration) / totalFrames;
            } else {
                // Second half: exponential distribution to focus more on beginning
                const factor = 1 + (frameIndex / totalFrames) * 2;
                time = (frameIndex * processingVideo.duration) / (totalFrames * factor);
            }

            // Add a small random offset to avoid getting stuck on the same frame
            const randomOffset = Math.random() * 0.05; // Up to 50ms jitter

            // Validate the time to prevent non-finite error
            if (isFinite(time) && time >= 0 && time <= processingVideo.duration) {
                // Ensure we don't exceed video duration
                const safeTime = Math.min(time + randomOffset, processingVideo.duration - 0.1);
                processingVideo.currentTime = safeTime;

                // Log frame position for debugging
                if (frameIndex % 50 === 0) {
                    showLog(`Seeking to frame ${frameIndex}: ${safeTime.toFixed(2)}s`, 'video');
                }
            } else {
                console.warn(`Invalid time value: ${time}, using 0 instead`);
                processingVideo.currentTime = 0;
            }
        }

        // Define data structures for set-based decoding
        let setsData = []; // Will store data about individual sets
        let setsReceived = []; // Will track which sets are fully received

        // Global variable for tracking chunk counts per set (moved to global scope)
        let chunksPerSelectedSet = [];

        // Initialize support for enhanced processing on page load
        document.addEventListener('DOMContentLoaded', function () {
            window.setsData = [];
            window.setsReceived = [];
            window.chunksPerSelectedSet = [];
            window.setMetadataReceived = [];
        });

        function processQrData(data, type = 'live') {
            const now = Date.now();

            // More intelligent debounce for QR processing with special handling for metadata
            let isRepeat = false;
            if (data === lastQrData) {
                // For very short intervals, always debounce
                if (now - lastQrTime < 300) {
                    return;
                }
                // For medium intervals, only accept critical frames (metadata) 
                if (now - lastQrTime < 2000) {
                    try {
                        const temp = JSON.parse(data);
                        if (!temp.type || (temp.type !== "global_metadata" && temp.type !== "set_metadata")) {
                            isRepeat = true;
                        }
                    } catch (e) {
                        // If we can't parse, treat as duplicate
                        isRepeat = true;
                    }

                    if (isRepeat) {
                        return;
                    }
                }
                // After 2 seconds, always process even if repeated
            }

            lastQrData = data;
            lastQrTime = now;

            try {
                let jsonData;
                try {
                    jsonData = JSON.parse(data);
                } catch (err) {
                    // Attempt to extract JSON from any wrapping text
                    const jsonMatch = data.match(/\{.*\}/);
                    if (jsonMatch) {
                        try {
                            jsonData = JSON.parse(jsonMatch[0]);
                        } catch (e) {
                            return; // Still not valid JSON, ignore
                        }
                    } else {
                        return; // Not valid JSON, ignore
                    }
                }

                // Check for protocol version
                const protocolVersion = jsonData.version || "1.0";

                // Process different QR data formats

                // Modern format (metadata, set_metadata, chunk, end) - Version 2.0
                if (jsonData.type) {
                    // Process global metadata
                    if (jsonData.type === "global_metadata" ||
                        (jsonData.type === "metadata" && protocolVersion === "2.0")) {

                        // Log this important event prominently
                        showLog(`🎯 GLOBAL METADATA DETECTED! File: ${jsonData.file_name || "unknown"}`, type);

                        // Create a file identifier using name, size and timestamp
                        const newFileName = jsonData.file_name || "file.dat";
                        const newFileSize = jsonData.file_size || 0;
                        const fileId = `${newFileName}_${newFileSize}`;

                        // Check if we've seen this file before
                        const isKnownFile = fileId === currentFileId && fileHistory[fileId];

                        if (isKnownFile) {
                            // We're seeing the same file again
                            showLog(`🔄 Detecting SAME FILE again: ${newFileName}`, type);
                            showLog(`Continuing where we left off - focusing on missing frames`, type);

                            // Restore file data from history
                            startReceived = true;
                            totalFramesExpected = fileHistory[fileId].totalFrames;
                            fileName = newFileName;
                            fileSize = newFileSize;
                            framesData = [...fileHistory[fileId].framesData];
                            framesReceived = [...fileHistory[fileId].framesReceived];
                            qrGridSize = fileHistory[fileId].qrGridSize || 1;
                            chunksPerSelectedSet = fileHistory[fileId].chunksPerSelectedSet || [];
                            setsData = fileHistory[fileId].setsData || [];
                            setsReceived = fileHistory[fileId].setsReceived || [];

                            // Count how many frames we're missing
                            const missingCount = framesReceived.filter(received => !received).length;
                            showLog(`Already have ${totalFramesExpected - missingCount}/${totalFramesExpected} chunks (${missingCount} missing)`, type);

                            // Check for incomplete sets
                            if (setsReceived.length > 0) {
                                const incompleteSets = setsReceived
                                    .map((complete, idx) => complete ? null : idx)
                                    .filter(idx => idx !== null);

                                if (incompleteSets.length > 0) {
                                    showLog(`Missing complete sets: ${incompleteSets.map(i => i + 1).join(', ')}`, type);
                                }
                            }

                            // If file is already complete, just download it
                            if (missingCount === 0) {
                                showLog(`✅ All chunks already received for this file!`, type);
                                isFileComplete = true;
                                if (type === 'video') {
                                    assembleAndDownloadFile(type);
                                }
                            } else {
                                isFileComplete = false;
                                showLog(`🔍 Looking for the ${missingCount} missing chunks...`, type);
                            }
                        } else {
                            // New file - start fresh
                            startReceived = true;
                            currentFileId = fileId;
                            isFileComplete = false;

                            // Store grid size information
                            if (jsonData.qr_grid_size) {
                                qrGridSize = parseInt(jsonData.qr_grid_size) || 1;
                                if (qrGridSize > 1) {
                                    showLog(`QR Grid Layout: ${qrGridSize} QRs per frame detected from metadata`, type);
                                }
                            }

                            // Initialize set data arrays
                            if (jsonData.total_selected_sets) {
                                const setCount = jsonData.total_selected_sets;
                                setsData = Array(setCount).fill(null);
                                setsReceived = Array(setCount).fill(false);

                                showLog(`File organized in ${setCount} sets`, type);

                                // Track which sets need metadata
                                window.setMetadataReceived = Array(setCount).fill(false);
                            }

                            // Store chunks per set information
                            if (jsonData.chunks_per_selected_set) {
                                chunksPerSelectedSet = [...jsonData.chunks_per_selected_set];
                                showLog(`Set sizes: ${chunksPerSelectedSet.join(', ')} chunks`, type);
                            }

                            // Calculate total chunks
                            let totalChunks = 0;

                            if (jsonData.actual_chunks_count) {
                                totalChunks = jsonData.actual_chunks_count;
                            } else if (jsonData.total_chunks) {
                                totalChunks = jsonData.total_chunks;
                            } else if (chunksPerSelectedSet.length > 0) {
                                // Calculate from set information
                                totalChunks = chunksPerSelectedSet.reduce((sum, count) => sum + count, 0);
                            } else if (jsonData.total_sets && jsonData.chunks_per_set) {
                                // Legacy calculation
                                totalChunks = jsonData.total_selected_sets * jsonData.chunks_per_set;
                            }

                            totalFramesExpected = totalChunks;
                            fileName = newFileName;
                            fileSize = newFileSize;

                            // Initialize data structures
                            framesData = Array(totalFramesExpected).fill('');
                            framesReceived = Array(totalFramesExpected).fill(false);

                            // Display metadata information
                            showLog(`Metadata details: ${fileName}, ${totalFramesExpected} chunks, size: ${formatFileSize(fileSize)}`, type);

                            // Additional organization details
                            if (jsonData.total_selected_sets) {
                                showLog(`File organized in ${jsonData.total_selected_sets} sets`, type);
                            }

                            // Show file queue information if available
                            if (jsonData.file_index && jsonData.total_files) {
                                showLog(`File ${jsonData.file_index} of ${jsonData.total_files} in sender's queue`, type);
                            }
                        }

                        // Save file data to history
                        fileHistory[fileId] = {
                            fileName: fileName,
                            fileSize: fileSize,
                            totalFrames: totalFramesExpected,
                            framesData: [...framesData],
                            framesReceived: [...framesReceived],
                            qrGridSize: qrGridSize,
                            chunksPerSelectedSet: [...chunksPerSelectedSet],
                            setsData: [...setsData],
                            setsReceived: [...setsReceived],
                            firstSeen: Date.now(),
                            receivedCount: framesReceived.filter(Boolean).length
                        };

                        // Update visual display
                        updateGrid(type);

                        // Estimate transfer time
                        if (detectedFrameRates.length > 0) {
                            const avgFrameRate = detectedFrameRates.reduce((sum, rate) => sum + rate, 0) / detectedFrameRates.length;
                            const estimatedSeconds = totalFramesExpected / avgFrameRate;
                            showLog(`Estimated time to receive all chunks: ${(estimatedSeconds / 60).toFixed(1)} minutes at ${avgFrameRate.toFixed(1)} fps`, type);
                        }
                    }
                    // Process set-specific metadata
                    else if (jsonData.type === "set_metadata") {
                        const setIndex = jsonData.set_index - 1; // Convert to 0-based

                        showLog(`📦 SET METADATA received for Set ${jsonData.set_index}`, type);

                        if (setIndex >= 0 && setIndex < setsData.length) {
                            // Store metadata for this set
                            setsData[setIndex] = {
                                index: setIndex,
                                chunksCount: jsonData.chunks_in_set,
                                globalOffset: jsonData.global_chunk_offset || 0,
                                fileName: jsonData.file_name,
                                timestamp: jsonData.timestamp
                            };

                            // Mark that we've received this set's metadata
                            if (window.setMetadataReceived && setIndex < window.setMetadataReceived.length) {
                                window.setMetadataReceived[setIndex] = true;
                            }

                            // Update chunksPerSelectedSet if not already set
                            if (!chunksPerSelectedSet[setIndex]) {
                                chunksPerSelectedSet[setIndex] = jsonData.chunks_in_set;

                                // Update file history
                                if (currentFileId && fileHistory[currentFileId]) {
                                    fileHistory[currentFileId].chunksPerSelectedSet = [...chunksPerSelectedSet];
                                }
                            }

                            showLog(`Set ${jsonData.set_index} has ${jsonData.chunks_in_set} chunks, offset: ${jsonData.global_chunk_offset || 0}`, type);

                            // Update file history with set data
                            if (currentFileId && fileHistory[currentFileId]) {
                                fileHistory[currentFileId].setsData = [...setsData];
                            }
                        } else {
                            showLog(`⚠️ Invalid set index: ${setIndex}`, type, true);
                        }
                    }
                    // Process chunk data
                    else if (jsonData.type === "chunk" && startReceived) {
                        // Calculate global chunk index
                        let chunkIndex = -1;

                        // Prioritize global_chunk_index if provided
                        if (jsonData.global_chunk_index !== undefined) {
                            chunkIndex = jsonData.global_chunk_index;
                        }
                        // Next try with set_index and chunk_index
                        else if (jsonData.set_index && jsonData.chunk_index) {
                            const setIndex = jsonData.set_index - 1; // 1-indexed to 0-indexed
                            const localChunkIndex = jsonData.chunk_index - 1; // 1-indexed to 0-indexed

                            // Use set metadata if available
                            if (setsData[setIndex] && setsData[setIndex].globalOffset !== undefined) {
                                chunkIndex = setsData[setIndex].globalOffset + localChunkIndex;
                            }
                            // Fall back to chunksPerSelectedSet
                            else if (chunksPerSelectedSet && chunksPerSelectedSet.length > 0) {
                                let offset = 0;
                                for (let i = 0; i < setIndex; i++) {
                                    offset += (i < chunksPerSelectedSet.length) ? chunksPerSelectedSet[i] : 0;
                                }
                                chunkIndex = offset + localChunkIndex;
                            }
                            // Last resort: use chunks_in_set from the current chunk
                            else {
                                const chunksPerSet = jsonData.chunks_in_set || 50;
                                chunkIndex = (setIndex * chunksPerSet) + localChunkIndex;
                            }
                        }

                        // Process the chunk if valid index
                        if (chunkIndex >= 0 && chunkIndex < totalFramesExpected) {
                            blinkCell(chunkIndex, type);

                            if (!framesReceived[chunkIndex]) {
                                framesData[chunkIndex] = jsonData.data || '';
                                framesReceived[chunkIndex] = true;

                                // Update chunk count and UI
                                const chunkSize = jsonData.data ? jsonData.data.length : 0;
                                showLog(`Chunk ${chunkIndex + 1}/${totalFramesExpected} received (${chunkSize} chars)`, type);

                                // Update the file history for this chunk
                                if (currentFileId && fileHistory[currentFileId]) {
                                    fileHistory[currentFileId].framesData[chunkIndex] = jsonData.data || '';
                                    fileHistory[currentFileId].framesReceived[chunkIndex] = true;
                                    fileHistory[currentFileId].receivedCount = fileHistory[currentFileId].framesReceived.filter(Boolean).length;
                                    fileHistory[currentFileId].lastUpdated = Date.now();
                                }

                                // Check if this set is now complete
                                if (jsonData.set_index) {
                                    const setIndex = jsonData.set_index - 1;
                                    const setComplete = checkSetCompletion(setIndex, type);

                                    if (setComplete) {
                                        showLog(`✅ Set ${jsonData.set_index} is now complete!`, type);
                                        setsReceived[setIndex] = true;

                                        // Update file history
                                        if (currentFileId && fileHistory[currentFileId]) {
                                            fileHistory[currentFileId].setsReceived = [...setsReceived];
                                        }
                                    }
                                }

                                // Update grid every few chunks for performance
                                if (chunkIndex % 5 === 0) {
                                    updateGrid(type);
                                }

                                // Check if all frames received
                                const missingCount = framesReceived.filter(received => !received).length;
                                const receivedCount = totalFramesExpected - missingCount;

                                if (receivedCount === totalFramesExpected) {
                                    showLog('💯 All chunks received!', type);
                                    updateGrid(type); // Final update

                                    // Mark file as complete
                                    isFileComplete = true;
                                    if (currentFileId && fileHistory[currentFileId]) {
                                        fileHistory[currentFileId].isComplete = true;
                                    }

                                    if (type === 'live') {
                                        assembleAndDownloadFile(type);
                                    }
                                } else if (receivedCount % 10 === 0) {
                                    // Log progress periodically
                                    showLog(`Progress: ${receivedCount}/${totalFramesExpected} chunks (${Math.round(receivedCount / totalFramesExpected * 100)}%)`, type);
                                }
                            } else {
                                // Already have this chunk - skip verbose logging
                                if (chunkIndex % 20 === 0) {
                                    showLog(`Skipping already received chunk ${chunkIndex + 1}/${totalFramesExpected}`, type);
                                }
                            }
                        } else {
                            // Invalid chunk index - log warning
                            showLog(`⚠️ Invalid chunk index ${chunkIndex} (max: ${totalFramesExpected - 1})`, type, true);
                        }
                    }
                    // Process end frame
                    else if (jsonData.type === "end" && startReceived) {
                        showLog(`📋 End frame received - verifying completeness`, type);

                        // Check for verification data
                        if (jsonData.total_chunks_sent !== undefined) {
                            const reportedChunks = jsonData.total_chunks_sent;
                            const receivedChunks = framesReceived.filter(Boolean).length;

                            showLog(`Chunks reported in end frame: ${reportedChunks}`, type);
                            showLog(`Chunks actually received: ${receivedChunks}`, type);

                            // Check for incompletely received sets
                            if (setsReceived.length > 0) {
                                const incompleteSets = setsReceived
                                    .map((received, idx) => received ? null : idx + 1)
                                    .filter(idx => idx !== null);

                                if (incompleteSets.length > 0) {
                                    showLog(`⚠️ Missing sets: ${incompleteSets.join(', ')}`, type, true);
                                    showLog(`Please ask sender to resend sets: ${incompleteSets.join(', ')}`, type);
                                }
                            }

                            // Check if all frames are received
                            const missingCount = framesReceived.filter(received => !received).length;

                            if (missingCount === 0) {
                                showLog(`✅ ALL CHUNKS VERIFIED - Transfer complete!`, type);
                                isFileComplete = true;

                                // Mark as complete in history
                                if (currentFileId && fileHistory[currentFileId]) {
                                    fileHistory[currentFileId].isComplete = true;
                                }

                                // Assemble and download
                                assembleAndDownloadFile(type);
                            } else {
                                // Some chunks still missing
                                showLog(`⚠️ Transfer not complete - still missing ${missingCount} chunks`, type);

                                // Generate missing chunks report
                                const missingChunks = createMissingChunksReport();
                                showLog(missingChunks, type);
                            }
                        }
                    }
                    else if (jsonData.type === "metadata" && protocolVersion !== "2.0") {
                        // Legacy metadata frame handling (version 1.0)
                        // Process similar to global_metadata but with slightly different structure

                        // Log this important event prominently
                        showLog(`🎯 METADATA FRAME DETECTED! File: ${jsonData.file_name || "unknown"}`, type);

                        // Create a file identifier using name, size and timestamp if available
                        const newFileName = jsonData.file_name || "file.dat";
                        const newFileSize = jsonData.file_size || 0;

                        // Generate a unique ID for this file based on name and size
                        const fileId = `${newFileName}_${newFileSize}`;

                        // Check if we've seen this file before and continue with regular processing
                        // ...rest of legacy metadata processing
                        // (Same code as before, not duplicating it here)
                    }
                }
                // Legacy/old format (marker-based)
                else if (jsonData.marker) {
                    // Legacy format handling (keep as is)
                    // ...
                }
            } catch (err) {
                console.error("Error processing QR data:", err);
                if (err.message !== lastQrError) {
                    // Only log new errors to avoid spam
                    showLog(`Error processing QR data: ${err.message}`, type);
                    lastQrError = err.message;
                }
            }
        }

        // Helper function to check if a set is complete
        function checkSetCompletion(setIndex, type = 'live') {
            if (!setsData[setIndex]) {
                return false;
            }

            const setInfo = setsData[setIndex];
            const globalOffset = setInfo.globalOffset || 0;
            const chunksCount = setInfo.chunksCount || chunksPerSelectedSet[setIndex] || 0;

            if (chunksCount === 0) {
                return false;
            }

            // Check if all chunks in this set are received
            for (let i = 0; i < chunksCount; i++) {
                const globalIndex = globalOffset + i;
                if (!framesReceived[globalIndex]) {
                    return false;
                }
            }

            return true;
        }

        // Helper function to create a formatted report of missing chunks
        function createMissingChunksReport() {
            const missing = framesReceived
                .map((received, idx) => received ? null : idx)
                .filter(idx => idx !== null);

            if (missing.length === 0) {
                return "No missing chunks!";
            }

            // Group missing chunks by set if set information is available
            if (setsData.length > 0 && chunksPerSelectedSet.length > 0) {
                const missingBySet = {};

                missing.forEach(chunkIdx => {
                    // Find which set this chunk belongs to
                    let targetSet = -1;
                    let localIdx = -1;
                    let runningOffset = 0;

                    for (let setIdx = 0; setIdx < chunksPerSelectedSet.length; setIdx++) {
                        const setSize = chunksPerSelectedSet[setIdx] || 0;
                        if (chunkIdx >= runningOffset && chunkIdx < runningOffset + setSize) {
                            targetSet = setIdx;
                            localIdx = chunkIdx - runningOffset;
                            break;
                        }
                        runningOffset += setSize;
                    }

                    if (targetSet !== -1) {
                        if (!missingBySet[targetSet]) {
                            missingBySet[targetSet] = [];
                        }
                        missingBySet[targetSet].push(localIdx);
                    }
                });

                // Create a formatted report
                let report = "Missing chunks by set:\n";
                Object.keys(missingBySet).forEach(setIdx => {
                    const setNum = parseInt(setIdx) + 1;
                    const count = missingBySet[setIdx].length;
                    const totalInSet = chunksPerSelectedSet[setIdx] || 0;
                    const pct = Math.round((count / totalInSet) * 100);

                    report += `Set ${setNum}: ${count}/${totalInSet} chunks missing (${pct}%)\n`;

                    // If few chunks missing, list them specifically
                    if (count <= 10) {
                        report += `  Missing indices: ${missingBySet[setIdx].map(i => i + 1).join(', ')}\n`;
                    }
                });

                return report;
            } else {
                // Simple report of missing chunks
                if (missing.length <= 20) {
                    return `Missing chunks: ${missing.map(i => i + 1).join(', ')}`;
                } else {
                    return `Missing ${missing.length} chunks (first 10: ${missing.slice(0, 10).map(i => i + 1).join(', ')}...)`;
                }
            }
        }

        // Variable to track last error message
        let lastQrError = '';

        // Format file size for display
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' bytes';
            else if (bytes < 1048576) return (bytes / 1024).toFixed(2) + ' KB';
            else if (bytes < 1073741824) return (bytes / 1048576).toFixed(2) + ' MB';
            else return (bytes / 1073741824).toFixed(2) + ' GB';
        }

        // Save frame for diagnostic purposes
        function saveFrameForDiagnostics(canvas, frameNumber, timePosition) {
            // Only save every 30th frame or frames with QR codes
            if (frameNumber % 30 !== 0 && framesCapturedWithQR === 0) return;

            try {
                // Limit total saved frames to avoid memory issues
                if (savedFrameCounter > 100) return;

                // Create a copy of the canvas with timestamp overlay
                const diagCanvas = document.createElement('canvas');
                diagCanvas.width = canvas.width;
                diagCanvas.height = canvas.height;
                const diagCtx = diagCanvas.getContext('2d');

                // Draw the frame
                diagCtx.drawImage(canvas, 0, 0);

                // Add frame information overlay
                diagCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                diagCtx.fillRect(0, 0, canvas.width, 30);
                diagCtx.fillStyle = 'white';
                diagCtx.font = '14px monospace';
                diagCtx.fillText(`Frame: ${frameNumber} | Time: ${timePosition.toFixed(2)}s | Res: ${canvas.width}×${canvas.height}`, 10, 20);

                // Convert to data URL (could be saved to IndexedDB in a production app)
                const dataURL = diagCanvas.toDataURL('image/jpeg', 0.7);

                // In a real app, we'd save this. For this demo, we log it
                console.log(`Saved diagnostic frame #${frameNumber} at ${timePosition.toFixed(2)}s`);
                savedFrameCounter++;

                // In production you could implement:
                // - Save to IndexedDB
                // - Download as a file
                // - Send to server
            } catch (err) {
                console.error("Error saving diagnostic frame:", err);
            }
        }

        // Enhance image for better QR detection
        function enhanceImageForQRDetection(imageData) {
            // Create a copy of the image data to work with
            const enhancedData = new ImageData(
                new Uint8ClampedArray(imageData.data),
                imageData.width,
                imageData.height
            );

            // Apply contrast enhancement
            const data = enhancedData.data;
            const contrast = 1.5; // Increase contrast
            const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));

            for (let i = 0; i < data.length; i += 4) {
                // Apply contrast to RGB channels
                data[i] = factor * (data[i] - 128) + 128;     // R
                data[i + 1] = factor * (data[i + 1] - 128) + 128; // G
                data[i + 2] = factor * (data[i + 2] - 128) + 128; // B
                // Alpha remains unchanged
            }

            return enhancedData;
        }

        // Track QR size statistics to optimize detection
        function updateQRSizeStats(qrCode) {
            try {
                const width = Math.abs(qrCode.location.topRightCorner.x - qrCode.location.topLeftCorner.x);
                const height = Math.abs(qrCode.location.bottomLeftCorner.y - qrCode.location.topLeftCorner.y);

                qrSizeStats.count++;
                qrSizeStats.totalWidth += width;
                qrSizeStats.totalHeight += height;
                qrSizeStats.minWidth = Math.min(qrSizeStats.minWidth, width);
                qrSizeStats.maxWidth = Math.max(qrSizeStats.maxWidth, width);
                qrSizeStats.minHeight = Math.min(qrSizeStats.minHeight, height);
                qrSizeStats.maxHeight = Math.max(qrSizeStats.maxHeight, height);

                // Log stats periodically
                if (qrSizeStats.count % 10 === 0) {
                    const avgWidth = qrSizeStats.totalWidth / qrSizeStats.count;
                    const avgHeight = qrSizeStats.totalHeight / qrSizeStats.count;

                    console.log(`QR size stats after ${qrSizeStats.count} detections:
                        Avg: ${avgWidth.toFixed(1)}×${avgHeight.toFixed(1)}px
                        Min: ${qrSizeStats.minWidth.toFixed(1)}×${qrSizeStats.minHeight.toFixed(1)}px
                        Max: ${qrSizeStats.maxWidth.toFixed(1)}×${qrSizeStats.maxHeight.toFixed(1)}px`);
                }
            } catch (err) {
                console.error("Error updating QR size stats:", err);
            }
        }

        // Track time between QR detections to estimate frame rate
        function trackFrameRate(timePosition) {
            const now = Date.now();

            if (lastQrDetectionTime > 0) {
                const timeDiff = now - lastQrDetectionTime;

                // Only track if less than 1 second between detections
                if (timeDiff < 1000) {
                    detectedFrameRates.push(1000 / timeDiff);

                    // Keep only recent measurements
                    if (detectedFrameRates.length > 20) {
                        detectedFrameRates.shift();
                    }

                    // Log estimated frame rate periodically
                    if (detectedFrameRates.length > 5 && framesCapturedWithQR % 10 === 0) {
                        const avgFrameRate = detectedFrameRates.reduce((sum, rate) => sum + rate, 0) / detectedFrameRates.length;
                        showLog(`Estimated QR code frame rate: ${avgFrameRate.toFixed(1)} fps`, 'video');
                    }
                }
            }

            lastQrDetectionTime = now;
        }

        // Try to detect metadata frame with grid size information
        function tryDetectMetadataWithGridSize(imageData, timePosition) {
            // Don't run this detection too often to save CPU
            if (capturedFramesCount % 5 !== 0) return;

            try {
                // Try to detect metadata
                const qrCode = jsQR(imageData.data, imageData.width, imageData.height, {
                    inversionAttempts: 'attemptBoth'
                });

                if (qrCode) {
                    try {
                        const data = JSON.parse(qrCode.data);

                        // Check if this is a metadata frame with grid size information
                        if (data.type === "metadata" && data.qr_grid_size) {
                            qrGridSize = parseInt(data.qr_grid_size) || 1;

                            if (qrGridSize > 1) {
                                showLog(`Detected QR grid layout: ${qrGridSize} QRs per frame`, 'video');
                            }

                            return true;
                        }
                    } catch (e) {
                        // Not valid JSON or not metadata
                        return false;
                    }
                }
            } catch (err) {
                console.error("Error detecting metadata:", err);
            }

            return false;
        }

        // Detect QR codes in a grid layout
        function detectQRCodesInGrid(imageData, qrCodes, timePosition) {
            if (qrGridSize <= 1) return false;

            try {
                // Calculate grid dimensions
                let cols, rows;
                switch (qrGridSize) {
                    case 2: cols = 2; rows = 1; break;
                    case 4: cols = 2; rows = 2; break;
                    case 8: cols = 4; rows = 2; break;
                    case 16: cols = 4; rows = 4; break;
                    case 32: cols = 8; rows = 4; break;
                    default: return false; // Unknown grid layout
                }

                const cellWidth = Math.floor(imageData.width / cols);
                const cellHeight = Math.floor(imageData.height / rows);

                // Check each cell in the grid
                let foundAny = false;

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        // Extract this grid cell
                        const cellData = extractImageRegion(
                            imageData,
                            col * cellWidth,
                            row * cellHeight,
                            cellWidth,
                            cellHeight
                        );

                        // Try to detect QR in this cell
                        const qrCode = jsQR(cellData.data, cellData.width, cellData.height, {
                            inversionAttempts: 'attemptBoth',
                            canOverwriteImage: true,
                            maxModuleCount: 177
                        });

                        if (qrCode) {
                            // Adjust QR code coordinates to the full image
                            adjustQRCodeCoordinates(qrCode, col * cellWidth, row * cellHeight);

                            // Add to detected QR codes
                            qrCodes.push(qrCode);
                            foundAny = true;

                            // Track frame rate and size stats
                            updateQRSizeStats(qrCode);
                            trackFrameRate(timePosition);
                        }
                    }
                }

                return foundAny;
            } catch (err) {
                console.error("Error in grid detection:", err);
                return false;
            }
        }

        // Extract a region from an ImageData object
        function extractImageRegion(imageData, x, y, width, height) {
            // Create a temporary canvas to extract the region
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');

            // Create a temporary ImageData to draw the full image
            const fullCanvas = document.createElement('canvas');
            fullCanvas.width = imageData.width;
            fullCanvas.height = imageData.height;
            const fullCtx = fullCanvas.getContext('2d');
            fullCtx.putImageData(imageData, 0, 0);

            // Draw the region into the temporary canvas
            tempCtx.drawImage(fullCanvas, x, y, width, height, 0, 0, width, height);

            // Get the image data for just this region
            return tempCtx.getImageData(0, 0, width, height);
        }

        // Adjust QR code coordinates from a grid cell to the full image
        function adjustQRCodeCoordinates(qrCode, offsetX, offsetY) {
            const locations = ['topLeftCorner', 'topRightCorner', 'bottomLeftCorner', 'bottomRightCorner'];

            for (const location of locations) {
                qrCode.location[location].x += offsetX;
                qrCode.location[location].y += offsetY;
            }
        }

        function assembleAndDownloadFile(type) {
            try {
                // Combine all data chunks
                const base64Data = framesData.join('');
                showLog(`Combined base64 data: ${base64Data.length} chars`, type);

                // Convert base64 to binary
                const rawData = atob(base64Data);
                showLog(`Decoded data length: ${rawData.length} bytes`, type);

                // Create typed array
                const bytes = new Uint8Array(rawData.length);
                for (let i = 0; i < rawData.length; i++) {
                    bytes[i] = rawData.charCodeAt(i);
                }

                // Verify size if provided
                if (fileSize > 0 && bytes.length !== fileSize) {
                    showLog(`Size mismatch: got ${bytes.length}, expected ${fileSize}`, type);
                }

                // Create blob and download
                const blob = new Blob([bytes], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = fileName.replace(/\.b64$/, '');
                a.click();

                URL.revokeObjectURL(url);
                showLog(`File downloaded: ${fileName}`, type);

                if (type === 'live') {
                    stopLiveScanning();
                }
            } catch (err) {
                showLog(`Error assembling file: ${err.message}`, type);
            }
        }

        // Make scan region draggable and resizable
        function initializeScanRegionControls() {
            const scanRegion = document.querySelector('.scan-region');
            const resizeHandle = document.querySelector('.scan-region-handle');
            const infoDisplay = document.querySelector('.scan-region-info');
            const videoContainer = document.querySelector('.video-container');
            const resetScanRegionBtn = document.getElementById('resetScanRegionBtn');

            let isDragging = false;
            let isResizing = false;
            let dragOffset = { x: 0, y: 0 };
            let initialSize = { width: 0, height: 0 };
            let initialMousePos = { x: 0, y: 0 };

            // Update info display
            function updateInfoDisplay() {
                const width = parseInt(scanRegion.style.width || 200);
                const height = parseInt(scanRegion.style.height || 200);
                infoDisplay.textContent = `Size: ${width}×${height}px - Drag to move, resize handle to adjust`;
            }

            // Reset scan region to center
            function resetScanRegion() {
                scanRegion.style.width = '200px';
                scanRegion.style.height = '200px';
                scanRegion.style.left = '50%';
                scanRegion.style.top = '50%';
                scanRegion.style.transform = 'translate(-50%, -50%)';
                updateInfoDisplay();
                showLog('Scan region reset to center', 'live');
            }

            // Add reset button event listener
            resetScanRegionBtn.addEventListener('click', resetScanRegion);

            // Start dragging
            scanRegion.addEventListener('mousedown', (e) => {
                if (e.target === resizeHandle) return; // Handle by resize handler

                e.preventDefault();
                isDragging = true;

                // Calculate offset from mouse position to region's top-left
                const regionRect = scanRegion.getBoundingClientRect();
                dragOffset.x = e.clientX - regionRect.left;
                dragOffset.y = e.clientY - regionRect.top;

                // Add temporary event listeners for dragging
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            });

            // Start resizing
            resizeHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                isResizing = true;

                // Store initial size and mouse position
                initialSize.width = scanRegion.offsetWidth;
                initialSize.height = scanRegion.offsetHeight;
                initialMousePos.x = e.clientX;
                initialMousePos.y = e.clientY;

                // Add temporary event listeners for resizing
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            });

            // Handle mouse move for both dragging and resizing
            function handleMouseMove(e) {
                e.preventDefault();

                if (isDragging) {
                    // Calculate new position
                    const containerRect = videoContainer.getBoundingClientRect();
                    const newLeft = e.clientX - containerRect.left - dragOffset.x;
                    const newTop = e.clientY - containerRect.top - dragOffset.y;

                    // Ensure region stays within container bounds
                    const maxLeft = containerRect.width - scanRegion.offsetWidth;
                    const maxTop = containerRect.height - scanRegion.offsetHeight;

                    scanRegion.style.left = `${Math.max(0, Math.min(newLeft, maxLeft))}px`;
                    scanRegion.style.top = `${Math.max(0, Math.min(newTop, maxTop))}px`;
                    scanRegion.style.transform = 'none'; // Override the centering transform
                }
                else if (isResizing) {
                    // Calculate size change
                    const deltaX = e.clientX - initialMousePos.x;
                    const deltaY = e.clientY - initialMousePos.y;

                    // Apply size constraints (minimum 100px, maximum container size)
                    const containerRect = videoContainer.getBoundingClientRect();
                    const newWidth = Math.max(100, Math.min(initialSize.width + deltaX, containerRect.width - parseInt(scanRegion.style.left || 0)));
                    const newHeight = Math.max(100, Math.min(initialSize.height + deltaY, containerRect.height - parseInt(scanRegion.style.top || 0)));

                    scanRegion.style.width = `${newWidth}px`;
                    scanRegion.style.height = `${newHeight}px`;

                    updateInfoDisplay();
                }
            }

            // End dragging or resizing
            function handleMouseUp() {
                isDragging = false;
                isResizing = false;

                // Remove temporary event listeners
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);

                updateInfoDisplay();

                // Log region position and size for debugging
                const regionRect = scanRegion.getBoundingClientRect();
                console.log(`Scan region: ${Math.round(regionRect.width)}×${Math.round(regionRect.height)}px at (${Math.round(regionRect.left)},${Math.round(regionRect.top)})`);
            }

            // Initialize with default size info
            updateInfoDisplay();
        }

        // Event listeners
        startLiveBtn.addEventListener('click', startLiveScanning);
        stopLiveBtn.addEventListener('click', stopLiveScanning);

        openVideoBtn.addEventListener('click', () => fileInput.click());
        quickAnalysisBtn.addEventListener('click', performQuickAnalysis);
        processVideoBtn.addEventListener('click', startVideoProcessing);
        stopProcessingBtn.addEventListener('click', stopVideoProcessing);

        // Initialize controls for the scan region
        document.addEventListener('DOMContentLoaded', initializeScanRegionControls);

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFileInput(e.target.files[0]);
            }
        });

        // Drag and drop support
        dropzone.addEventListener('click', () => fileInput.click());

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropzone.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
        });

        dropzone.addEventListener('dragover', () => {
            dropzone.style.backgroundColor = '#e6e6e6';
        });

        dropzone.addEventListener('dragleave', () => {
            dropzone.style.backgroundColor = '#f9f9f9';
        });

        dropzone.addEventListener('drop', (e) => {
            dropzone.style.backgroundColor = '#f9f9f9';

            if (e.dataTransfer.files.length > 0) {
                handleFileInput(e.dataTransfer.files[0]);
            }
        });

        // Add manual frame capture from video playback
        processingVideo.addEventListener('play', () => {
            // Only activate when not actively processing
            if (!isProcessingVideo && processingVideo.src) {
                const captureInterval = setInterval(() => {
                    if (processingVideo.paused || processingVideo.ended || isProcessingVideo) {
                        clearInterval(captureInterval);
                        return;
                    }

                    // Capture the current frame during normal playback
                    canvas.width = processingVideo.videoWidth;
                    canvas.height = processingVideo.videoHeight;
                    ctx.drawImage(processingVideo, 0, 0);

                    capturedFramesCount++;
                    videoFramesCounter.textContent = capturedFramesCount;

                    try {
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const qrCode = jsQR(imageData.data, imageData.width, imageData.height, {
                            inversionAttempts: 'dontInvert'
                        });

                        if (qrCode) {
                            framesCapturedWithQR++;
                            videoQrCounter.textContent = framesCapturedWithQR;
                            processQrData(qrCode.data, 'video');

                            // Visual feedback
                            ctx.strokeStyle = 'lime';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                            ctx.lineTo(qrCode.location.topRightCorner.x, qrCode.location.topRightCorner.y);
                            ctx.lineTo(qrCode.location.bottomRightCorner.x, qrCode.location.bottomRightCorner.y);
                            ctx.lineTo(qrCode.location.bottomLeftCorner.x, qrCode.location.bottomLeftCorner.y);
                            ctx.lineTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                            ctx.stroke();
                        }
                    } catch (err) {
                        // Silent catch
                    }
                }, 200); // Capture 5 frames per second during normal playback
            }
        });

        document.addEventListener('DOMContentLoaded', function () {
            // Setup global variable for chunks per set tracking
            window.chunksPerSelectedSet = [];

            // Apply UI enhancements
            enhanceUIVisibility();

            // Add keyboard shortcut for quick processing
            document.addEventListener('keydown', function (e) {
                // Ctrl+P for "Process Video"
                if (e.ctrlKey && e.key === 'p') {
                    e.preventDefault();
                    const processBtn = document.getElementById('processVideoBtn');
                    if (processBtn && !processBtn.disabled) {
                        processBtn.click();
                    }
                }

                // Ctrl+Q for "Quick Analysis"
                if (e.ctrlKey && e.key === 'q') {
                    e.preventDefault();
                    const quickBtn = document.getElementById('quickAnalysisBtn');
                    if (quickBtn && !quickBtn.disabled) {
                        quickBtn.click();
                    }
                }

                // Ctrl+S for "Stop Processing"
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    const stopBtn = document.getElementById('stopProcessingBtn');
                    if (stopBtn && !stopBtn.disabled) {
                        stopBtn.click();
                    }
                }
            });
        });

        // Show debug shortcuts in the UI
        function addShortcutInfo() {
            const videoPanel = document.querySelector('#video-tab .right-panel');
            if (videoPanel) {
                const shortcutInfo = document.createElement('div');
                shortcutInfo.style.background = '#333';
                shortcutInfo.style.color = '#fff';
                shortcutInfo.style.padding = '8px';
                shortcutInfo.style.borderRadius = '4px';
                shortcutInfo.style.marginTop = '10px';
                shortcutInfo.style.fontSize = '12px';
                shortcutInfo.style.fontFamily = 'monospace';
                shortcutInfo.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 5px;">Keyboard Shortcuts:</div>
            <div>Ctrl+Q: Quick Analysis</div>
            <div>Ctrl+P: Process Video</div>
            <div>Ctrl+S: Stop Processing</div>
        `;
                videoPanel.appendChild(shortcutInfo);
            }
        }

        // Call this after DOM is loaded
        window.addEventListener('load', addShortcutInfo);

        function enhanceMultipleFileSupport() {
            // Create a received files panel
            const createReceivedFilesPanel = function () {
                // Check if panel already exists
                let filesPanel = document.getElementById('receivedFilesPanel');
                if (filesPanel) return filesPanel;

                // Create the panel
                filesPanel = document.createElement('div');
                filesPanel.id = 'receivedFilesPanel';
                filesPanel.className = 'received-files-panel';
                filesPanel.style.backgroundColor = '#1a1a1a';
                filesPanel.style.border = '1px solid #333';
                filesPanel.style.borderRadius = '5px';
                filesPanel.style.padding = '15px';
                filesPanel.style.margin = '15px';
                filesPanel.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';

                // Add title
                const title = document.createElement('h3');
                title.textContent = 'Received Files';
                title.style.margin = '0 0 10px 0';
                title.style.color = '#fff';
                filesPanel.appendChild(title);

                // Add files list container
                const filesList = document.createElement('div');
                filesList.id = 'receivedFilesList';
                filesList.style.maxHeight = '200px';
                filesList.style.overflowY = 'auto';
                filesPanel.appendChild(filesList);

                // Add to right panel
                const rightPanels = document.querySelectorAll('.right-panel');
                rightPanels.forEach(panel => {
                    // Insert at the top
                    if (panel.firstChild) {
                        panel.insertBefore(filesPanel, panel.firstChild);
                    } else {
                        panel.appendChild(filesPanel);
                    }
                });

                return filesPanel;
            };

            // Update the received files list
            window.updateReceivedFilesList = function () {
                const panel = createReceivedFilesPanel();
                const filesList = document.getElementById('receivedFilesList');

                if (!filesList) return;

                // Clear list
                filesList.innerHTML = '';

                // Add files from history
                let hasCompleteFiles = false;

                Object.keys(fileHistory).forEach(fileId => {
                    const file = fileHistory[fileId];

                    // Skip incomplete files
                    if (!file.isComplete) return;

                    hasCompleteFiles = true;

                    // Create file item
                    const fileItem = document.createElement('div');
                    fileItem.className = 'received-file-item';
                    fileItem.style.padding = '10px';
                    fileItem.style.marginBottom = '5px';
                    fileItem.style.backgroundColor = '#333';
                    fileItem.style.borderRadius = '3px';
                    fileItem.style.display = 'flex';
                    fileItem.style.justifyContent = 'space-between';
                    fileItem.style.alignItems = 'center';

                    // File info
                    const fileInfo = document.createElement('div');
                    fileInfo.innerHTML = `
                <div style="font-weight:bold;color:#fff;">${file.fileName}</div>
                <div style="font-size:11px;color:#aaa;">${formatFileSize(file.fileSize)}</div>
                <div style="font-size:10px;color:#888;">Received: ${new Date(file.lastUpdated || file.firstSeen).toLocaleString()}</div>
            `;

                    // Download button
                    const downloadBtn = document.createElement('button');
                    downloadBtn.textContent = 'Download';
                    downloadBtn.style.padding = '5px 10px';
                    downloadBtn.style.backgroundColor = '#4CAF50';
                    downloadBtn.style.border = 'none';
                    downloadBtn.style.borderRadius = '3px';
                    downloadBtn.style.color = 'white';
                    downloadBtn.style.cursor = 'pointer';

                    // Add download functionality
                    downloadBtn.addEventListener('click', function () {
                        // Set up for download
                        currentFileId = fileId;
                        fileName = file.fileName;
                        fileSize = file.fileSize;
                        framesData = [...file.framesData];
                        framesReceived = [...file.framesReceived];

                        // Download the file
                        assembleAndDownloadFile('manual');
                    });

                    fileItem.appendChild(fileInfo);
                    fileItem.appendChild(downloadBtn);
                    filesList.appendChild(fileItem);
                });

                // Show message if no files
                if (!hasCompleteFiles) {
                    const noFiles = document.createElement('div');
                    noFiles.textContent = 'No completed files yet.';
                    noFiles.style.color = '#aaa';
                    noFiles.style.padding = '10px';
                    noFiles.style.fontStyle = 'italic';
                    filesList.appendChild(noFiles);
                }

                // Show/hide the panel based on content
                panel.style.display = hasCompleteFiles ? 'block' : 'none';
            };

            // Update received files list when a file is completed
            const originalAssembleAndDownloadFile = window.assembleAndDownloadFile;

            window.assembleAndDownloadFile = function (type) {
                // Call original function
                originalAssembleAndDownloadFile(type);

                // Update the files list
                setTimeout(window.updateReceivedFilesList, 500);
            };

            // Initialize the files panel
            createReceivedFilesPanel();
            window.updateReceivedFilesList();
        }

        // Start initializing these features when the DOM is loaded
        document.addEventListener('DOMContentLoaded', function () {
            // Initialize the full screen camera
            setTimeout(initializeFullScreenCamera, 500);

            // Initialize the multiple file support
            setTimeout(enhanceMultipleFileSupport, 700);

            // Add keyboard shortcuts for QR code scanning
            document.addEventListener('keydown', function (e) {
                // Space bar to start/stop camera
                if (e.key === ' ' || e.code === 'Space') {
                    e.preventDefault();

                    // Check which tab is active
                    const liveTabActive = document.getElementById('live-tab').classList.contains('active');

                    if (liveTabActive) {
                        if (isLiveScanning) {
                            // Stop camera
                            const stopBtn = document.getElementById('stopLiveBtn');
                            if (stopBtn && !stopBtn.disabled) {
                                stopBtn.click();
                            }
                        } else {
                            // Start camera
                            const startBtn = document.getElementById('startLiveBtn');
                            if (startBtn && !startBtn.disabled) {
                                startBtn.click();
                            }
                        }
                    }
                }
            });

            // Show keyboard shortcut info
            const addShortcutInfo = function () {
                const livePanel = document.querySelector('#live-tab .right-panel');
                if (livePanel) {
                    const shortcutInfo = document.createElement('div');
                    shortcutInfo.style.background = '#333';
                    shortcutInfo.style.color = '#fff';
                    shortcutInfo.style.padding = '8px';
                    shortcutInfo.style.borderRadius = '4px';
                    shortcutInfo.style.marginTop = '10px';
                    shortcutInfo.style.fontSize = '12px';
                    shortcutInfo.style.fontFamily = 'monospace';
                    shortcutInfo.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 5px;">Keyboard Shortcuts:</div>
                <div>Space: Start/Stop Camera</div>
            `;
                    livePanel.appendChild(shortcutInfo);
                }
            };

            // Add shortcut info after a short delay
            setTimeout(addShortcutInfo, 1000);
        });
        // Initialize
        showLog('Ready to scan. Click "Start Camera" to begin.', 'live');
        showLog('Ready to process. Select a video file to begin.', 'video');
    </script>
</body>

</html>
