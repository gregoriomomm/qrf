<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Video QR Code Decoder</title>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: sans-serif;
        }

        .container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }

        .tabs {
            display: flex;
            background: #f0f0f0;
            border-bottom: 1px solid #ddd;
        }

        .tab {
            padding: 12px 20px;
            cursor: pointer;
            border-right: 1px solid #ddd;
        }

        .tab.active {
            background: #fff;
            font-weight: bold;
        }

        .tab-content {
            display: none;
            flex: 1;
            overflow: hidden;
        }

        .tab-content.active {
            display: flex;
        }

        .panel {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .left-panel {
            width: 60%;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #222;
            position: relative;
            padding: 10px;
        }

        .controls {
            margin-bottom: 10px;
            z-index: 10;
        }

        button {
            margin: 5px;
            padding: 8px 15px;
            font-size: 14px;
            cursor: pointer;
        }

        .video-container {
            position: relative;
            width: 100%;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #liveVideo, #processingVideo {
            max-width: 100%;
            max-height: 100%;
            background: black;
            z-index: 5;
        }

        .scan-region {
            position: absolute;
            border: 2px solid red;
            width: 200px;
            height: 200px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 6;
        }

        .right-panel {
            width: 40%;
            display: flex;
            flex-direction: column;
            padding: 10px;
            background: #f0f0f0;
        }

        .grid {
            --cell-size: 20px;
            display: grid;
            gap: 1px;
            height: auto;
            max-height: 30%;
            width: 100%;
            place-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background: #1a1a1a;
            border-radius: 4px;
            overflow-y: auto;
            position: relative;
        }
        
        /* Improve performance for large grids */
        @media (min-width: 768px) {
            .grid {
                grid-template-columns: repeat(auto-fill, minmax(12px, 1fr)) !important;
            }
        }
        
        /* For very large frame counts */
        .grid.large-count {
            --cell-size: 10px;
            gap: 1px;
            grid-template-columns: repeat(auto-fill, minmax(8px, 1fr)) !important;
        }
        
        .status-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-family: monospace;
            background: #333;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
        }
        
        .counter-box {
            display: inline-block;
            padding: 3px 8px;
            margin-right: 5px;
            background: #222;
            border-radius: 3px;
            color: lime;
        }

        .progress-container {
            height: 20px;
            background: #2a2a2a;
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
            border: 1px solid #333;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            width: 0%;
            text-align: center;
            color: white;
            font-size: 12px;
            line-height: 20px;
            transition: width 0.3s;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .grid-cell {
            background: darkred;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            text-align: center;
            transition: background 0.2s, transform 0.1s;
            width: var(--cell-size);
            height: var(--cell-size);
            position: relative;
            cursor: pointer;
            user-select: none;
        }

        .grid-cell:hover {
            transform: scale(1.1);
            z-index: 2;
        }

        .grid-cell.received {
            background: #4CAF50;
            box-shadow: 0 0 2px rgba(76, 175, 80, 0.8);
        }
        
        .grid-cell.missing {
            background: #ff6b6b;
            box-shadow: 0 0 3px rgba(255, 0, 0, 0.8);
            animation: pulseMissing 2s infinite;
        }
        
        @keyframes pulseMissing {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }

        .grid-cell.blinking {
            background: yellow !important;
            color: black;
            animation: pulse 0.4s;
            transform: scale(1.2);
            z-index: 10;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1.2); }
        }
        
        .grid-stats {
            grid-column: 1 / -1;
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            background: #333;
            border-radius: 4px;
            text-align: center;
            font-family: monospace;
            color: white;
        }
        
        .grid-stats-received {
            color: #4CAF50;
            font-weight: bold;
        }
        
        .grid-stats-missing {
            color: #f44336;
            font-weight: bold;
        }

        .log {
            flex: 1;
            background: black;
            color: lime;
            padding: 10px;
            overflow-y: auto;
            white-space: pre;
            font-family: monospace;
            margin-top: 10px;
        }

        .hidden {
            display: none;
        }

        #canvas {
            display: none;
        }

        #fileInput {
            display: none;
        }

        .dropzone {
            border: 2px dashed #ccc;
            border-radius: 5px;
            padding: 25px;
            text-align: center;
            margin: 15px 0;
            background: #f9f9f9;
            cursor: pointer;
        }

        .dropzone:hover {
            background: #f0f0f0;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="tabs">
            <div class="tab active" data-tab="live">Live Camera</div>
            <div class="tab" data-tab="video">Video File</div>
        </div>

        <!-- Live Camera Tab -->
        <div class="tab-content active" id="live-tab">
            <div class="panel">
                <div class="left-panel">
                    <div class="controls">
                        <button id="startLiveBtn">Start Camera</button>
                        <button id="stopLiveBtn" disabled>Stop Camera</button>
                    </div>
                    <div class="video-container">
                        <video id="liveVideo" playsinline></video>
                        <div class="scan-region"></div>
                    </div>
                </div>
                <div class="right-panel">
                    <div class="status-container">
                        <div>Frames: <span class="counter-box" id="liveFramesCounter">0</span></div>
                        <div>QR detected: <span class="counter-box" id="liveQrCounter">0</span></div>
                    </div>
                    <div class="grid" id="liveGrid"></div>
                    <div class="log" id="liveLog"></div>
                </div>
            </div>
        </div>

        <!-- Video File Tab -->
        <div class="tab-content" id="video-tab">
            <div class="panel">
                <div class="left-panel">
                    <div class="controls">
                        <button id="openVideoBtn">Open Video</button>
                        <button id="quickAnalysisBtn" disabled>Quick Analysis</button>
                        <button id="processVideoBtn" disabled>Process Video</button>
                        <button id="stopProcessingBtn" disabled>Stop Processing</button>
                    </div>
                    <div class="video-container">
                        <video id="processingVideo" controls></video>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar" id="progressBar"></div>
                    </div>
                    <input type="file" id="fileInput" accept="video/*" />
                    <div class="dropzone">
                        <p>Drop video file here or click to select</p>
                    </div>
                </div>
                <div class="right-panel">
                    <div class="status-container">
                        <div>Frames: <span class="counter-box" id="videoFramesCounter">0</span></div>
                        <div>QR detected: <span class="counter-box" id="videoQrCounter">0</span></div>
                        <div>Time: <span class="counter-box" id="videoTimeDisplay">0.0s</span></div>
                    </div>
                    <div class="grid" id="videoGrid"></div>
                    <div class="log" id="videoLog"></div>
                </div>
            </div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // DOM Elements
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        const canvas = document.getElementById('canvas');
        // Initialize canvas with willReadFrequently to avoid warnings
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        canvas.willReadFrequently = true;
        
        // Live tab elements
        const liveVideo = document.getElementById('liveVideo');
        const startLiveBtn = document.getElementById('startLiveBtn');
        const stopLiveBtn = document.getElementById('stopLiveBtn');
        const liveGrid = document.getElementById('liveGrid');
        const liveLog = document.getElementById('liveLog');
        const liveFramesCounter = document.getElementById('liveFramesCounter');
        const liveQrCounter = document.getElementById('liveQrCounter');
        
        // Video tab elements
        const processingVideo = document.getElementById('processingVideo');
        const openVideoBtn = document.getElementById('openVideoBtn');
        const quickAnalysisBtn = document.getElementById('quickAnalysisBtn');
        const processVideoBtn = document.getElementById('processVideoBtn');
        const stopProcessingBtn = document.getElementById('stopProcessingBtn');
        const fileInput = document.getElementById('fileInput');
        const dropzone = document.querySelector('.dropzone');
        const videoGrid = document.getElementById('videoGrid');
        const videoLog = document.getElementById('videoLog');
        const progressBar = document.getElementById('progressBar');
        const videoFramesCounter = document.getElementById('videoFramesCounter');
        const videoQrCounter = document.getElementById('videoQrCounter');
        const videoTimeDisplay = document.getElementById('videoTimeDisplay');

        // State variables
        let liveStream = null;
        let isLiveScanning = false;
        let isProcessingVideo = false;
        let currentProcessingFrame = 0;
        let totalFrames = 0;
        let capturedFramesCount = 0;
        let framesCapturedWithQR = 0;
        let isWaitingForSeek = false;
        let lastSeekTime = 0;
        
        // Data storage
        let startReceived = false;
        let totalFramesExpected = 0;
        let fileName = '';
        let fileSize = 0;
        let framesData = [];
        let framesReceived = [];
        let lastQrData = null;
        let lastQrTime = 0;
        
        // Persistent data storage for handling repeated videos
        let fileHistory = {};  // Object to store file metadata and frame status
        let currentFileId = ''; // Current file identifier
        let isFileComplete = false; // Flag to track if current file is complete
        
        // Enhanced debugging and analysis
        let diagnosticsEnabled = true;  // Set to true to enable diagnostic captures
        let savedFrameCounter = 0;      // Counter for saved diagnostic frames
        let qrGridSize = 1;             // Default to single QR code
        let qrPositions = {};           // Track where QR codes are found on frames
        let detectedFrameRates = [];    // Store time differences to estimate fps
        let lastQrDetectionTime = 0;    // Track time of last QR detection
        let qrSizeStats = {             // Track QR code size statistics
            count: 0,
            totalWidth: 0,
            totalHeight: 0,
            minWidth: Infinity,
            maxWidth: 0,
            minHeight: Infinity,
            maxHeight: 0
        };
        let logMessages = {
            live: [],
            video: []
        };

        // Tab switching
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                
                // Update active tab
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Update active content
                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(`${tabName}-tab`).classList.add('active');
                
                // Stop any active processes when switching tabs
                if (tabName === 'live' && isProcessingVideo) {
                    stopVideoProcessing();
                } else if (tabName === 'video' && isLiveScanning) {
                    stopLiveScanning();
                }
            });
        });

        // Logging functions
        function showLog(message, type = 'live') {
            logMessages[type].push(message);
            const logElement = type === 'live' ? liveLog : videoLog;
            logElement.textContent = logMessages[type].join('\n');
            logElement.scrollTop = logElement.scrollHeight;
        }

        function resetState(type = 'live', keepFileData = false) {
            // If we want to keep data for the same file, we store it first
            if (keepFileData && currentFileId && fileHistory[currentFileId]) {
                // We don't reset the file data, we'll just reuse it
                showLog(`Preserving data for file: ${fileName} (ID: ${currentFileId})`, type);
                showLog(`Already have ${fileHistory[currentFileId].receivedCount}/${fileHistory[currentFileId].totalFrames} frames`, type);
            } else {
                // Reset all file data
                startReceived = false;
                totalFramesExpected = 0;
                fileName = '';
                fileSize = 0;
                framesData = [];
                framesReceived = [];
                lastQrData = null;
                lastQrTime = 0;
                currentFileId = '';
                isFileComplete = false;
            }
            
            if (type === 'live') {
                stopLiveBtn.disabled = true;
                startLiveBtn.disabled = false;
                liveVideo.style.display = 'none';
                isLiveScanning = false;
                if (!keepFileData) {
                    logMessages.live = [];
                    liveLog.textContent = '';
                    liveGrid.innerHTML = '';
                }
                capturedFramesCount = 0;
                framesCapturedWithQR = 0;
                liveFramesCounter.textContent = '0';
                liveQrCounter.textContent = '0';
            } else {
                processVideoBtn.disabled = true;
                stopProcessingBtn.disabled = true;
                currentProcessingFrame = 0;
                totalFrames = 0;
                isProcessingVideo = false;
                progressBar.style.width = '0%';
                progressBar.textContent = '';
                if (!keepFileData) {
                    logMessages.video = [];
                    videoLog.textContent = '';
                    videoGrid.innerHTML = '';
                }
                capturedFramesCount = 0;
                framesCapturedWithQR = 0;
                videoFramesCounter.textContent = '0';
                videoQrCounter.textContent = '0';
            }
        }

        function updateGrid(type = 'live') {
            const grid = type === 'live' ? liveGrid : videoGrid;
            grid.innerHTML = '';
            
            if (totalFramesExpected <= 0) return;
            
            // Add class for very large frame counts
            if (totalFramesExpected > 1000) {
                grid.classList.add('large-count');
            } else {
                grid.classList.remove('large-count');
            }
            
            // Calculate optimal grid layout based on screen size and frame count
            const gridWidth = grid.clientWidth;
            
            // Adjust cell size based on number of frames
            let cellSize;
            if (totalFramesExpected > 5000) {
                cellSize = 8;  // Tiny cells for massive frame counts
            } else if (totalFramesExpected > 1000) {
                cellSize = 10; // Very small cells for large frame counts
            } else if (totalFramesExpected > 500) {
                cellSize = 15; // Small cells
            } else {
                cellSize = Math.min(30, Math.max(15, Math.floor(gridWidth / 20))); // Dynamic cell size
            }
            
            const columns = Math.floor(gridWidth / cellSize);
            
            grid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
            grid.style.setProperty('--cell-size', `${cellSize}px`);
            
            // Create a document fragment for better performance
            const fragment = document.createDocumentFragment();
            
            // For very large numbers, create group indicators rather than individual cells
            if (totalFramesExpected > 2000) {
                // Use a grouped approach for better performance
                const groupSize = Math.ceil(totalFramesExpected / 500); // About 500 visual elements
                
                for (let i = 0; i < totalFramesExpected; i += groupSize) {
                    const endIdx = Math.min(i + groupSize - 1, totalFramesExpected - 1);
                    
                    // Calculate how many frames are received in this group
                    let receivedInGroup = 0;
                    for (let j = i; j <= endIdx; j++) {
                        if (framesReceived[j]) receivedInGroup++;
                    }
                    
                    // Create a group cell
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.setAttribute('data-start', i + 1);
                    cell.setAttribute('data-end', endIdx + 1);
                    
                    // Calculate completion percentage
                    const groupCompletionPct = Math.round((receivedInGroup / (endIdx - i + 1)) * 100);
                    
                    // Visual styling based on completion
                    if (receivedInGroup === endIdx - i + 1) {
                        // Fully complete
                        cell.classList.add('received');
                    } else if (receivedInGroup > 0) {
                        // Partially complete - create a gradient or pattern
                        cell.style.background = `linear-gradient(to right, #4CAF50 ${groupCompletionPct}%, darkred ${groupCompletionPct}%)`;
                    }
                    
                    // Tooltip shows frame range and completion
                    cell.setAttribute('title', `Frames ${i+1}-${endIdx+1}: ${receivedInGroup}/${endIdx-i+1} received (${groupCompletionPct}%)`);
                    
                    fragment.appendChild(cell);
                }
            } else {
                // Standard approach for reasonable numbers of frames
                for (let i = 0; i < totalFramesExpected; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.setAttribute('data-index', i + 1);
                    
                    // For smaller cells, use a color-only approach
                    if (cellSize < 20) {
                        cell.textContent = '';
                    } else {
                        cell.textContent = i + 1;
                    }
                    
                    if (framesReceived[i]) {
                        cell.classList.add('received');
                    } else if (startReceived && totalFramesExpected > 0 && currentFileId) {
                        // For known files with missing frames, highlight them specially
                        cell.classList.add('missing');
                        cell.style.background = '#ff6b6b'; // Bright red for missing frames
                        cell.style.border = '1px solid #ff0000';
                    }
                    
                    // Add tooltip with frame number
                    cell.setAttribute('title', `Frame ${i + 1}`);
                    
                    // Store cell reference for faster blinking
                    const cellId = `cell-${type}-${i}`;
                    cell.id = cellId;
                    
                    fragment.appendChild(cell);
                }
            }
            
            // Append all cells at once
            grid.appendChild(fragment);
            
            // Add counter for missing frames
            const missingCount = framesReceived.filter(received => !received).length;
            const statsDiv = document.createElement('div');
            statsDiv.className = 'grid-stats';
            
            // Calculate progress percentage
            const progressPct = totalFramesExpected > 0 ? 
                Math.round(((totalFramesExpected - missingCount) / totalFramesExpected) * 100) : 0;
                
            statsDiv.innerHTML = `<span class="grid-stats-received">${totalFramesExpected - missingCount}</span>/<span class="grid-stats-total">${totalFramesExpected}</span> frames received (${progressPct}%)`;
            
            if (missingCount > 0) {
                statsDiv.innerHTML += ` <span class="grid-stats-missing">(${missingCount} missing)</span>`;
            }
            
            grid.appendChild(statsDiv);
        }

        function blinkCell(index, type = 'live') {
            const grid = type === 'live' ? liveGrid : videoGrid;
            
            // Handle grouped cells for large frame counts
            if (totalFramesExpected > 2000) {
                // Need to find which group contains this index
                const groupSize = Math.ceil(totalFramesExpected / 500);
                const groupIndex = Math.floor(index / groupSize);
                const groupStartIndex = groupIndex * groupSize;
                
                // Find cell by data attributes
                const cells = grid.querySelectorAll('.grid-cell');
                let targetCell = null;
                
                for (let i = 0; i < cells.length; i++) {
                    const start = parseInt(cells[i].getAttribute('data-start') || '-1');
                    const end = parseInt(cells[i].getAttribute('data-end') || '-1');
                    
                    if (start <= index + 1 && index + 1 <= end) {
                        targetCell = cells[i];
                        break;
                    }
                }
                
                // If found the group cell, highlight it
                if (targetCell) {
                    targetCell.classList.add('blinking');
                    
                    // Calculate updated completion for the group
                    const start = parseInt(targetCell.getAttribute('data-start')) - 1;
                    const end = parseInt(targetCell.getAttribute('data-end')) - 1;
                    
                    // Count received frames in this group
                    let receivedInGroup = 0;
                    for (let i = start; i <= end; i++) {
                        if (framesReceived[i]) receivedInGroup++;
                    }
                    
                    // Calculate completion percentage
                    const groupCompletionPct = Math.round((receivedInGroup / (end - start + 1)) * 100);
                    
                    // Use requestAnimationFrame for better performance
                    requestAnimationFrame(() => {
                        setTimeout(() => {
                            targetCell.classList.remove('blinking');
                            
                            // Update cell appearance based on completion
                            if (receivedInGroup === end - start + 1) {
                                // Fully complete
                                targetCell.classList.add('received');
                                targetCell.style.background = ''; // Remove gradient if exists
                            } else if (receivedInGroup > 0) {
                                // Partially complete - update gradient
                                targetCell.style.background = `linear-gradient(to right, #4CAF50 ${groupCompletionPct}%, darkred ${groupCompletionPct}%)`;
                            }
                            
                            // Update tooltip
                            targetCell.setAttribute('title', 
                                `Frames ${start+1}-${end+1}: ${receivedInGroup}/${end-start+1} received (${groupCompletionPct}%)`);
                                
                            // Update stats
                            updateGridStats(type);
                        }, 200);
                    });
                }
            } else {
                // Normal individual cell handling
                const cellId = `cell-${type}-${index}`;
                const cell = document.getElementById(cellId);
                
                if (cell) {
                    cell.classList.add('blinking');
                    
                    // Use requestAnimationFrame for better performance
                    requestAnimationFrame(() => {
                        // Add a small delay to make the blink visible
                        setTimeout(() => {
                            cell.classList.remove('blinking');
                            if (framesReceived[index]) {
                                cell.classList.add('received');
                            }
                            
                            // Update stats
                            updateGridStats(type);
                        }, 200);
                    });
                }
            }
        }
        
        // Separate function to update grid stats for better performance
        function updateGridStats(type) {
            const grid = type === 'live' ? liveGrid : videoGrid;
            const statsDiv = grid.querySelector('.grid-stats');
            
            if (statsDiv && totalFramesExpected > 0) {
                const missingCount = framesReceived.filter(received => !received).length;
                const receivedCount = totalFramesExpected - missingCount;
                const progressPct = Math.round((receivedCount / totalFramesExpected) * 100);
                
                // Update stats with new information
                const receivedSpan = statsDiv.querySelector('.grid-stats-received');
                const totalSpan = statsDiv.querySelector('.grid-stats-total');
                const missingSpan = statsDiv.querySelector('.grid-stats-missing');
                
                if (receivedSpan) receivedSpan.textContent = receivedCount;
                if (totalSpan) totalSpan.textContent = totalFramesExpected;
                
                // Update or add progress percentage
                let pctSpan = statsDiv.querySelector('.progress-pct');
                if (!pctSpan) {
                    // First create pct element if it doesn't exist
                    pctSpan = document.createElement('span');
                    pctSpan.className = 'progress-pct';
                    statsDiv.appendChild(pctSpan);
                }
                pctSpan.textContent = ` (${progressPct}%)`;
                
                // Update missing count
                if (missingSpan) {
                    if (missingCount > 0) {
                        missingSpan.textContent = `(${missingCount} missing)`;
                        missingSpan.style.display = 'inline';
                    } else {
                        missingSpan.style.display = 'none';
                    }
                } else if (missingCount > 0) {
                    const newMissingSpan = document.createElement('span');
                    newMissingSpan.className = 'grid-stats-missing';
                    newMissingSpan.textContent = ` (${missingCount} missing)`;
                    statsDiv.appendChild(newMissingSpan);
                }
            }
        }

        function updateProgressBar(current, total) {
            if (total <= 0) return;
            
            const percent = Math.min(100, Math.round((current / total) * 100));
            progressBar.style.width = `${percent}%`;
            progressBar.textContent = `${percent}%`;
        }

        // Live scanning functions
        async function startLiveScanning() {
            try {
                liveStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                });
                
                liveVideo.srcObject = liveStream;
                liveVideo.setAttribute('playsinline', 'true');
                
                try {
                    await liveVideo.play();
                    showLog('Camera started');
                } catch (err) {
                    showLog('Play error: ' + err.message + ' - Try tapping screen');
                    
                    // Add tap-to-play handler
                    liveVideo.addEventListener('click', () => {
                        liveVideo.play().catch(e => showLog('Play failed: ' + e.message));
                    });
                }
                
                liveVideo.style.display = 'block';
                isLiveScanning = true;
                startLiveBtn.disabled = true;
                stopLiveBtn.disabled = false;
                
                showLog('Camera ready, scanning for QR codes...');
                requestAnimationFrame(scanLiveFrame);
            } catch (err) {
                showLog('Error starting camera: ' + err.message);
            }
        }

        function stopLiveScanning() {
            if (liveStream) {
                liveStream.getTracks().forEach(track => track.stop());
                liveStream = null;
            }
            
            isLiveScanning = false;
            showLog('Camera stopped');
            resetState('live');
        }

        function scanLiveFrame() {
            if (!isLiveScanning) return;
            
            if (liveVideo.readyState === liveVideo.HAVE_ENOUGH_DATA) {
                canvas.width = liveVideo.videoWidth;
                canvas.height = liveVideo.videoHeight;
                ctx.drawImage(liveVideo, 0, 0);
                
                capturedFramesCount++;
                liveFramesCounter.textContent = capturedFramesCount;
                
                try {
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const qrCode = jsQR(imageData.data, imageData.width, imageData.height, {
                        inversionAttempts: 'attemptBoth', // Try both non-inverted and inverted for better detection
                        canOverwriteImage: true, // Allow overwriting the image data for performance
                        maxModuleCount: 177  // Support high capacity QR codes (version 40)
                    });
                    
                    if (qrCode) {
                        framesCapturedWithQR++;
                        liveQrCounter.textContent = framesCapturedWithQR;
                        processQrData(qrCode.data, 'live');
                    }
                } catch (err) {
                    // Silent catch - continue scanning
                }
            }
            
            requestAnimationFrame(scanLiveFrame);
        }

        // Video file processing
        function handleFileInput(file) {
            if (!file || !file.type.startsWith('video/')) {
                showLog('Please select a valid video file', 'video');
                return;
            }
            
            const videoUrl = URL.createObjectURL(file);
            processingVideo.src = videoUrl;
            
            processingVideo.onloadedmetadata = () => {
                showLog(`Video loaded: ${file.name} (${Math.round(processingVideo.duration)}s)`, 'video');
                quickAnalysisBtn.disabled = false;
                processVideoBtn.disabled = false;
                dropzone.textContent = file.name;
            };
            
            processingVideo.onerror = () => {
                showLog(`Error loading video: ${processingVideo.error.message}`, 'video');
                URL.revokeObjectURL(videoUrl);
            };
        }

        // Smart search strategy for finding QR codes in videos
        let searchPhase = 'initial'; // 'initial', 'binary', 'sequential', 'completion'
        let binarySearchRanges = []; // Tracks ranges for binary search
        let foundQRTimeRanges = []; // Track time ranges where QR codes were found
        let fastForwardMode = false; // Skip ahead when QR codes found
        let initialSampleRate = 4; // Initial sparse sampling rate (1 frame per x seconds)
        
        // Preliminary analysis variables
        let estimatedFrameRate = 0;
        let estimatedQRCount = 0;
        let estimatedGridSize = 1;
        let isPerformingQuickAnalysis = false;
        let quickAnalysisSamples = 0;
        let quickAnalysisQRs = 0;
        
        // Perform a quick preliminary analysis to determine frame rate and estimate QR count
        function performQuickAnalysis() {
            if (!processingVideo.src) {
                showLog('No video loaded', 'video');
                return;
            }
            
            // Reset state but don't clear the grid yet
            resetAnalysisState();
            
            const duration = processingVideo.duration;
            if (!isFinite(duration) || duration <= 0) {
                showLog('Warning: Video has invalid duration. Using time-based analysis instead.', 'video');
            }
            
            // Disable buttons during analysis
            quickAnalysisBtn.disabled = true;
            processVideoBtn.disabled = true;
            stopProcessingBtn.disabled = false;
            
            isPerformingQuickAnalysis = true;
            
            showLog('Starting quick analysis to determine frame rate and QR count...', 'video');
            progressBar.style.width = '0%';
            
            // Use an accelerated sampling approach
            // 1. First sample: Very beginning to find metadata QR
            // 2. Next sample: Sparse but distributed samples throughout video
            // 3. Adaptive: Focus more on areas where QR codes are found
            
            // Create an array of timestamps to check in the first phase
            const timestamps = [];
            
            // First focus heavily on the beginning (first 10 seconds)
            for (let t = 0; t < Math.min(10, duration); t += 0.5) {
                timestamps.push(t);
            }
            
            // Then add sparse samples throughout the video
            // More frequent at the beginning, less frequent later
            const sampleCount = Math.min(30, Math.ceil(duration / 10));
            for (let i = 0; i < sampleCount; i++) {
                timestamps.push(10 + (i / sampleCount) * (duration - 10));
            }
            
            quickAnalysisSamples = timestamps.length;
            
            // Process the timestamps in order
            processQuickAnalysisFrames(timestamps, 0);
        }
        
        // Process frames at specific timestamps for quick analysis
        function processQuickAnalysisFrames(timestamps, index) {
            if (!isPerformingQuickAnalysis || index >= timestamps.length) {
                completeQuickAnalysis();
                return;
            }
            
            const timestamp = timestamps[index];
            const progress = Math.round((index / timestamps.length) * 100);
            progressBar.style.width = `${progress}%`;
            progressBar.textContent = `Analyzing: ${progress}%`;
            
            // Seek to the specific timestamp
            processingVideo.currentTime = timestamp;
            isWaitingForSeek = true;
            
            // Wait for the seek to complete
            const seekHandler = () => {
                if (Math.abs(processingVideo.currentTime - timestamp) > 0.1 && isWaitingForSeek) {
                    // Still seeking
                    return;
                }
                
                processingVideo.removeEventListener('timeupdate', seekHandler);
                isWaitingForSeek = false;
                
                // Capture and analyze the frame
                analyzeCurrentVideoFrame(timestamp, (qrCodesFound, gridSize) => {
                    // Track QR detections for estimating total count
                    quickAnalysisQRs += qrCodesFound;
                    
                    // Update grid size estimation (take the maximum encountered)
                    if (gridSize > estimatedGridSize) {
                        estimatedGridSize = gridSize;
                    }
                    
                    // Time tracking for frame rate estimation
                    if (qrCodesFound > 0) {
                        foundQRTimeRanges.push({
                            time: timestamp,
                            qrCount: qrCodesFound,
                            gridSize: gridSize
                        });
                    }
                    
                    // Process next timestamp
                    processQuickAnalysisFrames(timestamps, index + 1);
                });
            };
            
            processingVideo.addEventListener('timeupdate', seekHandler);
        }
        
        // Analyze a single video frame during quick analysis
        function analyzeCurrentVideoFrame(timestamp, callback) {
            canvas.width = processingVideo.videoWidth;
            canvas.height = processingVideo.videoHeight;
            ctx.drawImage(processingVideo, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Try enhanced image for better detection
            const enhancedData = enhanceImageForQRDetection(imageData);
            
            // First try to detect metadata with grid information
            let foundGrid = tryDetectMetadataWithGridSize(enhancedData, timestamp);
            
            // Count detected QR codes
            let qrCodesDetected = 0;
            
            // Try multiple approaches for QR detection
            // First, try with the entire frame
            const qrCode = jsQR(enhancedData.data, enhancedData.width, enhancedData.height, {
                inversionAttempts: 'attemptBoth'
            });
            
            if (qrCode) {
                qrCodesDetected++;
                // Parse QR data to look for metadata
                const data = qrCode.data;
                if (data.startsWith('QR-BOOTSTRAP')) {
                    // This is a metadata QR, extract grid size if available
                    const gridMatch = data.match(/GRID=(\d+)/);
                    if (gridMatch) {
                        foundGrid = parseInt(gridMatch[1]);
                    }
                }
            }
            
            // If we know there's a grid, try to detect multiple QRs in a grid layout
            if (foundGrid > 1) {
                // First update the qrGridSize to the one we detected
                qrGridSize = foundGrid;
                // Try to detect QRs in a grid layout based on the grid size
                const gridQRs = detectQRCodesInGrid(enhancedData, [], timestamp);
                qrCodesDetected = Math.max(qrCodesDetected, gridQRs.length);
            }
            
            // Return results to the caller
            callback(qrCodesDetected, foundGrid);
        }
        
        // Complete the quick analysis and show results
        function completeQuickAnalysis() {
            if (!isPerformingQuickAnalysis) return;
            
            isPerformingQuickAnalysis = false;
            progressBar.style.width = '100%';
            progressBar.textContent = 'Analysis Complete';
            
            // Re-enable buttons
            quickAnalysisBtn.disabled = false;
            processVideoBtn.disabled = false;
            
            // Calculate estimated frame rate, if we have enough data
            if (foundQRTimeRanges.length >= 2) {
                // Sort by timestamp
                foundQRTimeRanges.sort((a, b) => a.time - b.time);
                
                // Calculate average time difference between detected QR frames
                let totalTimeDiff = 0;
                let consecutiveFrames = 0;
                
                for (let i = 1; i < foundQRTimeRanges.length; i++) {
                    const timeDiff = foundQRTimeRanges[i].time - foundQRTimeRanges[i-1].time;
                    // Filter out large gaps
                    if (timeDiff < 1.0) {
                        totalTimeDiff += timeDiff;
                        consecutiveFrames++;
                    }
                }
                
                if (consecutiveFrames > 0) {
                    const avgTimeDiff = totalTimeDiff / consecutiveFrames;
                    estimatedFrameRate = Math.round(1 / avgTimeDiff);
                } else {
                    // Fallback to a conservative estimate
                    estimatedFrameRate = 10;
                }
            } else {
                // Not enough data points, use a conservative estimate
                estimatedFrameRate = 10;
            }
            
            // Estimate total QR count
            // Method: (detected QRs / timestamps sampled) * (video duration * estimatedFrameRate) * estimatedGridSize
            const duration = processingVideo.duration;
            if (isFinite(duration) && duration > 0 && quickAnalysisSamples > 0) {
                const detectionRate = quickAnalysisQRs / quickAnalysisSamples;
                const totalFrames = Math.round(duration * estimatedFrameRate);
                estimatedQRCount = Math.round(detectionRate * totalFrames * estimatedGridSize);
            } else {
                // Fallback: Just multiply by 100 as a rough estimate
                estimatedQRCount = quickAnalysisQRs * 100;
            }
            
            // Update the grid size for the main processing
            qrGridSize = estimatedGridSize;
            
            // Show analysis results
            showLog(`
Quick Analysis Results:
---------------------
Estimated Frame Rate: ${estimatedFrameRate} fps
Estimated QR Grid Size: ${estimatedGridSize} QRs per frame
QR Codes Detected: ${quickAnalysisQRs} in ${quickAnalysisSamples} samples
Estimated Total QR Count: ~${estimatedQRCount}
            `, 'video');
            
            // Update the UI to show that we're ready for full processing
            videoFramesCounter.textContent = quickAnalysisSamples;
            videoQrCounter.textContent = quickAnalysisQRs;
            
            // Adjust processing strategy based on findings
            if (estimatedQRCount > 10000) {
                showLog('Large number of QR codes detected. Optimizing processing strategy for high-density content.', 'video');
                initialSampleRate = 0.2; // Use higher frequency sampling
            } else if (estimatedQRCount > 1000) {
                showLog('Moderate number of QR codes detected. Using balanced processing strategy.', 'video');
                initialSampleRate = 0.5;
            }
            
            // Return to the beginning of the video
            processingVideo.currentTime = 0;
        }
        
        // Reset analysis state without clearing the grid
        function resetAnalysisState() {
            // Reset analysis variables
            estimatedFrameRate = 0;
            estimatedQRCount = 0;
            estimatedGridSize = 1;
            quickAnalysisSamples = 0;
            quickAnalysisQRs = 0;
            isPerformingQuickAnalysis = false;
            foundQRTimeRanges = [];
            
            // Don't reset these as they'll be used by the main processor
            // qrGridSize = 1;
            // searchPhase = 'initial';
        }
        
        function startVideoProcessing() {
            if (!processingVideo.src) {
                showLog('No video loaded', 'video');
                return;
            }
            
            // Only partial reset - keep file data for continuing transfer
            resetState('video', true);
            isProcessingVideo = true;
            processVideoBtn.disabled = true;
            stopProcessingBtn.disabled = false;
            
            // If we have partial file data, show status
            if (currentFileId && fileHistory[currentFileId]) {
                const receivedCount = fileHistory[currentFileId].framesReceived.filter(Boolean).length;
                const totalFrames = fileHistory[currentFileId].totalFrames;
                const progress = Math.round((receivedCount / totalFrames) * 100);
                
                showLog(`Resuming processing for file: ${fileHistory[currentFileId].fileName}`, 'video');
                showLog(`Current progress: ${receivedCount}/${totalFrames} frames (${progress}%)`, 'video');
                
                if (receivedCount === totalFrames) {
                    showLog('⚠️ Note: All frames already received for this file! Looking for metadata now...', 'video');
                } else {
                    const missing = totalFrames - receivedCount;
                    showLog(`Looking for ${missing} missing frames...`, 'video');
                    
                    // Show hint about which frames we're missing 
                    const missingFrames = fileHistory[currentFileId].framesReceived
                        .map((received, i) => received ? null : i)
                        .filter(i => i !== null);
                    
                    if (missingFrames.length <= 20) {
                        showLog(`Missing frames: ${missingFrames.map(i => i+1).join(', ')}`, 'video');
                    } else {
                        // Show just a sample of missing frames
                        showLog(`First few missing frames: ${missingFrames.slice(0, 10).map(i => i+1).join(', ')}...`, 'video');
                    }
                }
                
                // Restore current data from file history
                startReceived = true;
                totalFramesExpected = fileHistory[currentFileId].totalFrames;
                fileName = fileHistory[currentFileId].fileName;
                fileSize = fileHistory[currentFileId].fileSize;
                framesData = [...fileHistory[currentFileId].framesData];
                framesReceived = [...fileHistory[currentFileId].framesReceived];
                qrGridSize = fileHistory[currentFileId].qrGridSize || 1;
                
                // Update visual display
                updateGrid('video');
            }
            
            const duration = processingVideo.duration;
            
            // Handle invalid duration more gracefully
            const validDuration = isFinite(duration) && duration > 0;
            if (!validDuration) {
                showLog('Warning: Video has invalid duration (Infinity). Will use time-based processing instead.', 'video');
                // Don't stop - continue with a default duration for processing
                const assumedDuration = 3600; // Assume 60 minutes for processing
                
                searchPhase = 'sequential';
                let fps = 15; // Higher frame rate to catch more QR codes
                totalFrames = 5000; // Process much more frames to ensure we catch all QR codes
                showLog(`Using time-based processing with ${totalFrames} frames for high density QR code detection`, 'video');
                currentProcessingFrame = 0;
                
                // Set up our own time tracking
                processingVideo.addEventListener('timeupdate', function() {
                    videoTimeDisplay.textContent = processingVideo.currentTime.toFixed(1) + 's';
                });
                
                processNextFrameBatch();
                return;
            }
            
            // Check if we have data from quick analysis
            if (estimatedFrameRate > 0 && estimatedQRCount > 0) {
                showLog(`Using results from quick analysis:
- Estimated Frame Rate: ${estimatedFrameRate} fps
- Estimated QR Grid Size: ${estimatedGridSize} QRs per frame
- Estimated Total QR Count: ~${estimatedQRCount}`, 'video');
                
                // Use the grid size information from quick analysis
                qrGridSize = estimatedGridSize;
                
                // If we already found metadata and know we're looking for QR codes
                if (startReceived) {
                    showLog("Already found metadata during quick analysis. Focusing on areas with QR codes...", 'video');
                    processFocusedAreas();
                    return;
                }
                
                // If we detected a significant number of QR codes
                if (quickAnalysisQRs > 5) {
                    // Calculate optimal sampling based on estimated frame rate and QR density
                    let samplesPerSecond = Math.min(estimatedFrameRate, 15); // Cap at 15 samples per second
                    
                    // For very high density content (many QRs per frame), increase sampling rate
                    if (estimatedGridSize > 4) {
                        samplesPerSecond = Math.min(estimatedFrameRate, 20); // Cap at 20 samples per second for high grid sizes
                    }
                    
                    // For videos with estimated high QR counts, use focused sampling
                    if (estimatedQRCount > 10000) {
                        // Focus on time ranges where QR codes were found
                        showLog("High QR code density detected. Using focused processing on QR-rich regions...", 'video');
                        processFocusedAreas();
                    } else {
                        // For medium density, use a balanced approach
                        showLog("Using balanced approach based on quick analysis results...", 'video');
                        searchPhase = 'sequential';
                        totalFrames = Math.min(10000, Math.ceil(duration * samplesPerSecond));
                        currentProcessingFrame = 0;
                        processNextFrameBatch();
                    }
                } else {
                    // If we found few QRs during quick analysis, perform more intensive scanning
                    showLog("Few QR codes detected in quick analysis. Performing more intensive scan...", 'video');
                    
                    // Set up search strategy based on video length
                    if (duration > 10) {
                        // For longer videos, use smart search
                        showLog(`Using enhanced search strategy for ${duration.toFixed(1)}s video`, 'video');
                        searchPhase = 'initial';
                        
                        // Set up frames for intensive scanning, especially at the beginning
                        const earlyTimePoints = [];
                        
                        // First 10 seconds at very high density (every ~50ms)
                        for (let t = 0; t < Math.min(10, duration); t += 0.05) {
                            earlyTimePoints.push(t);
                        }
                        
                        // Process these points first
                        processSpecificFrames(earlyTimePoints, () => {
                            // If we found metadata, skip to processing that region
                            if (startReceived) {
                                showLog("Found metadata frame in intensive scan! Now searching for all chunks...", 'video');
                                processFocusedAreas();
                                return;
                            }
                            
                            // If still no metadata, proceed with regular smart search
                            processSmartSearch();
                        });
                    } else {
                        // For short videos, use sequential processing
                        searchPhase = 'sequential';
                        let fps = 15; // Higher frame rate for thorough scanning
                        
                        const maxFrames = 10000; // Safety limit
                        totalFrames = Math.min(maxFrames, Math.ceil(duration * fps));
                        
                        showLog(`Sequential processing with intensive sampling: ${totalFrames} frames from ${duration.toFixed(1)}s video`, 'video');
                        currentProcessingFrame = 0;
                        processNextFrameBatch();
                    }
                }
            } else {
                // No quick analysis data available, use standard approach
                
                // Set up search strategy based on video length
                if (duration > 10 && isFinite(duration)) {
                    // For longer videos, use smart search
                    showLog(`Using smart search strategy for ${duration.toFixed(1)}s video`, 'video');
                    searchPhase = 'initial';
                    
                    // First, do an intensive scan of the first few seconds
                    // This is critical for finding metadata frames which are usually at the start
                    showLog("First performing intensive scan of video beginning to find metadata frames...", 'video');
                    
                    // Create a list of time points focused heavily on the first few seconds
                    const earlyTimePoints = [];
                    
                    // First 10 seconds at very high density (every ~100ms)
                    for (let t = 0; t < Math.min(10, duration); t += 0.1) {
                        earlyTimePoints.push(t);
                    }
                    
                    // Process these points first
                    processSpecificFrames(earlyTimePoints, () => {
                        // If we found metadata, skip to processing that region
                        if (startReceived) {
                            showLog("Found metadata frame in video beginning! Now searching for all chunks...", 'video');
                            processFocusedAreas();
                            return;
                        }
                        
                        // If we didn't find metadata in the beginning, continue with regular search
                        showLog("No metadata found in video beginning, continuing with full video scan...", 'video');
                        
                        // Adjust initial sample rate based on video length
                        if (duration > 300) { // > 5 minutes
                            initialSampleRate = 5; // Check every 5 seconds initially (doubled density)
                        } else if (duration > 120) { // > 2 minutes
                            initialSampleRate = 3; // Check every 3 seconds initially
                        } else if (duration > 60) { // > 1 minute
                            initialSampleRate = 1; // Check every 1 second initially
                        } else {
                            initialSampleRate = 0.5; // Check every 0.5 seconds for shorter videos
                        }
                        
                        // Safety check - set upper limit on samples
                        const MAX_SAMPLES = 5000; // Increased from 1000
                        const safeInitialSampleRate = Math.max(initialSampleRate, duration / MAX_SAMPLES);
                        
                        // Calculate initial sparse sampling
                        const initialSampleCount = Math.min(MAX_SAMPLES, Math.ceil(duration / safeInitialSampleRate));
                        totalFrames = initialSampleCount;
                        
                        showLog(`Initial scan: ${initialSampleCount} samples at ${safeInitialSampleRate.toFixed(1)}s intervals`, 'video');
                        
                        // Set up frames for the initial sparse sampling
                        currentProcessingFrame = 0;
                        
                        // Start with initial sparse sampling to find QR code clusters
                        processSmartSearch();
                    });
                } else {
                    // For short videos, use sequential processing
                    searchPhase = 'sequential';
                    let fps = 10; // Default for short videos
                    
                    // Safety check for very long videos
                    if (duration > 3600) { // > 1 hour
                        fps = 1; // Very sparse sampling for extremely long videos
                    } else if (duration > 600) { // > 10 minutes
                        fps = 2;
                    }
                    
                    const maxFrames = 10000; // Safety limit
                    totalFrames = Math.min(maxFrames, Math.ceil(duration * fps));
                    
                    showLog(`Sequential processing: ${totalFrames} frames from ${duration.toFixed(1)}s video`, 'video');
                    currentProcessingFrame = 0;
                    processNextFrameBatch();
                }
            }
        }
        
        // Smart search with adaptive strategy
        function processSmartSearch() {
            const duration = processingVideo.duration;
            
            // Double-check duration validity
            if (!isFinite(duration) || duration <= 0) {
                showLog('Invalid video duration detected in smart search. Switching to sequential processing.', 'video');
                searchPhase = 'sequential';
                let fps = 2; // Very conservative framerate
                totalFrames = 100; // Just process a small number of frames
                currentProcessingFrame = 0;
                processNextFrameBatch();
                return;
            }
            
            if (searchPhase === 'initial') {
                showLog(`Starting initial sparse sampling phase...`, 'video');
                
                // Create a list of frames at reasonable intervals (with safety check for duration)
                const samples = [];
                const maxSamples = 1000; // Prevent extremely large arrays
                const effectiveRate = Math.max(initialSampleRate, duration / maxSamples);
                
                for (let time = 0; time < duration; time += effectiveRate) {
                    samples.push(time);
                }
                
                // Last frame if not included
                if (samples[samples.length-1] < duration - 1) {
                    samples.push(duration - 1);
                }
                
                // Process these sample frames
                processSpecificFrames(samples, () => {
                    // After initial phase completes
                    if (startReceived) {
                        // We found metadata! Move to sequential processing around found areas
                        searchPhase = 'sequential';
                        showLog(`Found QR metadata! Switching to sequential processing.`, 'video');
                        
                        // If we haven't found all frames yet, determine processing range
                        const missingFrames = framesReceived.filter(received => !received).length;
                        
                        if (missingFrames > 0) {
                            // Focus on processing promising areas
                            let minTime = duration;
                            let maxTime = 0;
                            
                            // Find time range where QR codes were detected
                            foundQRTimeRanges.forEach(range => {
                                minTime = Math.min(minTime, range.start);
                                maxTime = Math.max(maxTime, range.end);
                            });
                            
                            // Add buffer zones (10% of duration on either side)
                            const buffer = Math.min(10, duration * 0.1);
                            minTime = Math.max(0, minTime - buffer);
                            maxTime = Math.min(duration, maxTime + buffer);
                            
                            showLog(`Processing focused time range: ${minTime.toFixed(1)}s to ${maxTime.toFixed(1)}s`, 'video');
                            processTimeRange(minTime, maxTime);
                        }
                    } else {
                        // No metadata found yet, switch to binary search
                        searchPhase = 'binary';
                        showLog(`No QR metadata found in sparse sampling. Switching to binary search.`, 'video');
                        
                        // Set up binary search on the entire video
                        binarySearchRanges = [{start: 0, end: duration, depth: 0}];
                        processBinarySearchRanges();
                    }
                });
            } else if (searchPhase === 'binary') {
                processBinarySearchRanges();
            }
        }
        
        // Process a specific list of timestamps with batch processing for large arrays
        function processSpecificFrames(timePoints, onComplete) {
            // Process in smaller batches to avoid stack overflow
            const BATCH_SIZE = 100;
            let currentBatch = 0;
            const totalBatches = Math.ceil(timePoints.length / BATCH_SIZE);
            
            function processBatch(batchIndex) {
                if (batchIndex >= totalBatches || !isProcessingVideo) {
                    if (onComplete) onComplete();
                    return;
                }
                
                const startIndex = batchIndex * BATCH_SIZE;
                const endIndex = Math.min((batchIndex + 1) * BATCH_SIZE, timePoints.length);
                const currentBatchPoints = timePoints.slice(startIndex, endIndex);
                
                // Process this batch of points
                let pointIndex = 0;
                
                function processNextPoint() {
                    if (pointIndex >= currentBatchPoints.length || !isProcessingVideo) {
                        // This batch is done, move to next batch
                        setTimeout(() => {
                            processBatch(batchIndex + 1);
                        }, 50);
                        return;
                    }
                    
                    const time = currentBatchPoints[pointIndex];
                    processingVideo.currentTime = time;
                    
                    processingVideo.onseeked = () => {
                        try {
                            // Process the current frame
                            captureAndProcessFrame(time);
                            
                            // Update progress based on overall position
                            const overallIndex = startIndex + pointIndex;
                            updateProgressBar(overallIndex + 1, timePoints.length);
                            
                            // Check if we should fast-forward based on QR detection
                            if (startReceived && fastForwardMode) {
                                // Check if we've found all frames
                                const missingFrames = framesReceived.filter(received => !received).length;
                                if (missingFrames === 0) {
                                    showLog(`All frames found! Completing processing.`, 'video');
                                    if (onComplete) onComplete();
                                    return;
                                }
                            }
                            
                            // Move to next point
                            pointIndex++;
                            
                            // Continue to next frame with slight delay
                            setTimeout(processNextPoint, 30);
                        } catch (err) {
                            showLog(`Error processing frame at ${time}s: ${err.message}`, 'video');
                            // Move to next point even if there's an error
                            pointIndex++;
                            setTimeout(processNextPoint, 30);
                        }
                    };
                }
                
                // Start processing this batch
                processNextPoint();
            }
            
            // Start with the first batch
            processBatch(0);
        }
        
        // Process a specific time range with a given frames per second
        function processTimeRange(startTime, endTime, fps = 10) {
            const duration = endTime - startTime;
            const framesToProcess = Math.ceil(duration * fps);
            
            const timePoints = [];
            for (let i = 0; i < framesToProcess; i++) {
                const time = startTime + (i * duration) / framesToProcess;
                timePoints.push(time);
            }
            
            showLog(`Processing ${framesToProcess} frames in time range ${startTime.toFixed(1)}s - ${endTime.toFixed(1)}s`, 'video');
            processSpecificFrames(timePoints, () => {
                // Check if we've found all frames
                if (startReceived) {
                    const missingFrames = framesReceived.filter(received => !received).length;
                    
                    if (missingFrames === 0) {
                        showLog(`All frames found! Processing complete.`, 'video');
                        assembleAndDownloadFile('video');
                    } else {
                        showLog(`Still missing ${missingFrames} frames after focused processing.`, 'video');
                        // Try processing the entire video at a lower frame rate
                        processEntireVideoAtLowerRate();
                    }
                } else {
                    showLog(`No QR metadata found in focused processing.`, 'video');
                    // Try processing the entire video at a lower frame rate
                    processEntireVideoAtLowerRate();
                }
            });
        }
        
        // Process binary search ranges
        function processBinarySearchRanges() {
            if (binarySearchRanges.length === 0 || !isProcessingVideo) {
                // No more ranges to process - move to sequential processing
                searchPhase = 'sequential';
                showLog(`Binary search complete. Processing entire video.`, 'video');
                processEntireVideoAtLowerRate();
                return;
            }
            
            // Sort ranges by depth (process shallow depths first)
            binarySearchRanges.sort((a, b) => a.depth - b.depth);
            
            // Get next range to process
            const range = binarySearchRanges.shift();
            const midPoint = (range.start + range.end) / 2;
            
            // Sample points within this range (start, mid, end)
            const samplePoints = [
                range.start, 
                midPoint - (range.end - range.start) / 4,
                midPoint,
                midPoint + (range.end - range.start) / 4,
                range.end
            ].filter((value, index, self) => {
                // Remove duplicates and ensure all points are within video duration
                return self.indexOf(value) === index && value >= 0 && value <= processingVideo.duration;
            });
            
            showLog(`Binary search at depth ${range.depth}: ${range.start.toFixed(1)}s - ${range.end.toFixed(1)}s`, 'video');
            
            processSpecificFrames(samplePoints, () => {
                if (startReceived) {
                    // We found metadata! Move to sequential processing
                    searchPhase = 'sequential';
                    showLog(`Found QR metadata! Switching to sequential processing.`, 'video');
                    
                    // Focus on found areas
                    processFocusedAreas();
                } else if (range.end - range.start > 10 && range.depth < 3) {
                    // If range is still large and we're not too deep, create sub-ranges
                    const newDepth = range.depth + 1;
                    binarySearchRanges.push(
                        {start: range.start, end: midPoint, depth: newDepth},
                        {start: midPoint, end: range.end, depth: newDepth}
                    );
                    processBinarySearchRanges();
                } else {
                    // Continue with the next range
                    processBinarySearchRanges();
                }
            });
        }
        
        // Process focused areas where QR codes were found
        function processFocusedAreas() {
            if (foundQRTimeRanges.length === 0) {
                // No focused areas found, process the entire video
                processEntireVideoAtLowerRate();
                return;
            }
            
            // Merge overlapping ranges
            foundQRTimeRanges.sort((a, b) => a.start - b.start);
            const mergedRanges = [foundQRTimeRanges[0]];
            
            for (let i = 1; i < foundQRTimeRanges.length; i++) {
                const currentRange = foundQRTimeRanges[i];
                const lastRange = mergedRanges[mergedRanges.length - 1];
                
                // Add buffer for merging (2 second buffer)
                if (currentRange.start <= lastRange.end + 2) {
                    // Merge ranges
                    lastRange.end = Math.max(lastRange.end, currentRange.end);
                } else {
                    // Add as new range
                    mergedRanges.push(currentRange);
                }
            }
            
            // Process each merged range with a higher frame rate
            let rangeIndex = 0;
            
            function processNextRange() {
                if (rangeIndex >= mergedRanges.length || !isProcessingVideo) {
                    // All ranges processed
                    if (startReceived) {
                        const missingFrames = framesReceived.filter(received => !received).length;
                        if (missingFrames === 0) {
                            showLog(`All frames found! Processing complete.`, 'video');
                            assembleAndDownloadFile('video');
                        } else {
                            showLog(`Still missing ${missingFrames} frames after focused processing.`, 'video');
                            processEntireVideoAtLowerRate();
                        }
                    } else {
                        processEntireVideoAtLowerRate();
                    }
                    return;
                }
                
                const range = mergedRanges[rangeIndex];
                showLog(`Processing focused range ${rangeIndex+1}/${mergedRanges.length}: ${range.start.toFixed(1)}s - ${range.end.toFixed(1)}s`, 'video');
                
                // Process this range with a higher frame rate (15fps)
                processTimeRange(range.start, range.end, 15);
                rangeIndex++;
                processNextRange();
            }
            
            processNextRange();
        }
        
        // Process the entire video at an appropriate frame rate
        function processEntireVideoAtLowerRate() {
            const duration = processingVideo.duration;
            
            // Use higher frame rates for dense QR code videos
            // Dynamically adjust based on what we already found
            let fps;
            
            if (framesCapturedWithQR > 0 && capturedFramesCount > 0) {
                // Calculate QR density from what we've seen so far
                const qrDensity = framesCapturedWithQR / capturedFramesCount;
                
                if (qrDensity > 0.3) {
                    // Many QR codes found - high density video (likely 30fps QR transmission)
                    fps = Math.min(25, Math.max(20, Math.floor(qrDensity * 50)));
                    showLog(`High QR density detected (${Math.round(qrDensity*100)}%), using ${fps} fps processing rate`, 'video');
                } else if (qrDensity > 0.1) {
                    // Medium density
                    fps = 15;
                } else {
                    // Low density, but still found some QR codes
                    fps = 8;
                }
            } else {
                // Default if we don't have data yet
                fps = duration > 300 ? 5 : duration > 60 ? 10 : 15;
            }
            
            // Calculate frames but avoid extreme values
            const maxFrames = 50000; // Allow up to 50,000 frames for very dense videos
            totalFrames = Math.min(maxFrames, Math.ceil(duration * fps));
            currentProcessingFrame = 0;
            
            showLog(`Processing entire video at ${fps} fps (${totalFrames} total frames) to find all QR codes`, 'video');
            processNextFrameBatch();
        }
        
        // Capture and process a single frame at the current time position
        function captureAndProcessFrame(timePosition) {
            canvas.width = processingVideo.videoWidth;
            canvas.height = processingVideo.videoHeight;
            ctx.drawImage(processingVideo, 0, 0);
            
            capturedFramesCount++;
            videoFramesCounter.textContent = capturedFramesCount;
            
            try {
                // Fix for "Canvas2D: Multiple readback operations using getImageData are faster with the willReadFrequently attribute set to true"
                if (!canvas.willReadFrequently) {
                    canvas.willReadFrequently = true;
                    // Re-create the context with the new attribute
                    ctx = canvas.getContext('2d', { willReadFrequently: true });
                    // Redraw the current frame after updating context
                    ctx.drawImage(processingVideo, 0, 0);
                }
                // Save frame for diagnostics if enabled
                if (diagnosticsEnabled) {
                    saveFrameForDiagnostics(canvas, capturedFramesCount, timePosition);
                }
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Array to hold detected QR codes
                const qrCodes = [];
                
                // Try to detect metadata with grid size information
                tryDetectMetadataWithGridSize(imageData, timePosition);
                
                // If we know we're in grid mode, try to detect QRs in a grid layout
                let foundInGrid = false;
                if (qrGridSize > 1) {
                    foundInGrid = detectQRCodesInGrid(imageData, qrCodes, timePosition);
                }
                
                // If not found in grid or grid size is 1, try regular detection
                if (!foundInGrid) {
                    // Use optimized parameters for QR detection
                    const qrCode = jsQR(imageData.data, imageData.width, imageData.height, {
                        inversionAttempts: 'attemptBoth', // Try both non-inverted and inverted for better detection
                        canOverwriteImage: true, // Allow overwriting the image data for performance
                        maxModuleCount: 177  // Support high capacity QR codes (version 40)
                    });
                    
                    if (qrCode) {
                        qrCodes.push(qrCode);
                        updateQRSizeStats(qrCode);
                        trackFrameRate(timePosition);
                    }
                }
                
                // Try enhanced detection if no QR codes found
                if (qrCodes.length === 0 && capturedFramesCount % 10 === 0) {
                    try {
                        // Only try enhancement periodically to save performance
                        const enhancedImageData = enhanceImageForQRDetection(imageData);
                        const enhancedQrCode = jsQR(enhancedImageData.data, enhancedImageData.width, enhancedImageData.height, {
                            inversionAttempts: 'attemptBoth',
                            canOverwriteImage: true,
                            maxModuleCount: 177
                        });
                        
                        if (enhancedQrCode) {
                            qrCodes.push(enhancedQrCode);
                            showLog(`QR detected after image enhancement! Frame ${capturedFramesCount}`, 'video');
                        }
                    } catch (err) {
                        console.error("Error in enhanced detection:", err);
                    }
                }
                
                // Process all detected QR codes
                if (qrCodes.length > 0) {
                    framesCapturedWithQR++;
                    videoQrCounter.textContent = framesCapturedWithQR;
                    
                    // Draw all QR codes on the canvas
                    qrCodes.forEach((qrCode, index) => {
                        // Mark this QR on the video preview with different colors
                        const colors = ['lime', 'cyan', 'yellow', 'magenta', 'red', 'blue'];
                        ctx.strokeStyle = colors[index % colors.length];
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                        ctx.lineTo(qrCode.location.topRightCorner.x, qrCode.location.topRightCorner.y);
                        ctx.lineTo(qrCode.location.bottomRightCorner.x, qrCode.location.bottomRightCorner.y);
                        ctx.lineTo(qrCode.location.bottomLeftCorner.x, qrCode.location.bottomLeftCorner.y);
                        ctx.lineTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                        ctx.stroke();
                        
                        // Add QR code index if multiple detected
                        if (qrCodes.length > 1) {
                            const centerX = (qrCode.location.topLeftCorner.x + qrCode.location.bottomRightCorner.x) / 2;
                            const centerY = (qrCode.location.topLeftCorner.y + qrCode.location.bottomRightCorner.y) / 2;
                            ctx.fillStyle = 'white';
                            ctx.strokeStyle = 'black';
                            ctx.lineWidth = 2;
                            ctx.font = 'bold 16px monospace';
                            ctx.strokeText(`QR #${index+1}`, centerX - 20, centerY);
                            ctx.fillText(`QR #${index+1}`, centerX - 20, centerY);
                        }
                        
                        // Process the QR data
                        processQrData(qrCode.data, 'video');
                    });
                    
                    // Store time position where QR was found (with safe handling)
                    try {
                        foundQRTimeRanges.push({
                            start: Math.max(0, timePosition - 2), // 2 sec buffer before
                            end: Math.min(processingVideo.duration, timePosition + 2), // 2 sec buffer after
                            qrCount: qrCodes.length,
                            timestamp: Date.now()
                        });
                        
                        // Log detection information
                        if (qrCodes.length > 1) {
                            showLog(`Found ${qrCodes.length} QR codes in a single frame at ${timePosition.toFixed(2)}s!`, 'video');
                        }
                    } catch (e) {
                        showLog(`Warning: Could not store QR time range: ${e.message}`, 'video');
                        // If array is getting too large, consolidate ranges to avoid errors
                        if (foundQRTimeRanges.length > 500) {
                            const mergedRanges = [];
                            let lastRange = null;
                            
                            // Simple consolidation by merging adjacent ranges
                            foundQRTimeRanges.sort((a, b) => a.start - b.start).forEach(range => {
                                if (!lastRange) {
                                    lastRange = {...range};
                                    mergedRanges.push(lastRange);
                                } else if (range.start <= lastRange.end + 4) {
                                    // Merge with previous range
                                    lastRange.end = Math.max(lastRange.end, range.end);
                                } else {
                                    // New separate range
                                    lastRange = {...range};
                                    mergedRanges.push(lastRange);
                                }
                            });
                            
                            foundQRTimeRanges = mergedRanges;
                            showLog(`Consolidated ${foundQRTimeRanges.length} time ranges to avoid memory issues`, 'video');
                        }
                    }
                    
                    processQrData(qrCode.data, 'video');
                }
            } catch (err) {
                // Silent catch - continue processing
            }
        }

        function stopVideoProcessing() {
            isProcessingVideo = false;
            isPerformingQuickAnalysis = false;
            quickAnalysisBtn.disabled = false;
            processVideoBtn.disabled = false;
            stopProcessingBtn.disabled = true;
            
            // Don't reset file state - keep tracking progress
            showLog('Processing stopped - file progress maintained', 'video');
            
            if (currentFileId && fileHistory[currentFileId]) {
                const receivedCount = fileHistory[currentFileId].receivedCount;
                const totalFrames = fileHistory[currentFileId].totalFrames;
                const progress = Math.round((receivedCount / totalFrames) * 100);
                
                showLog(`Current file progress: ${receivedCount}/${totalFrames} frames (${progress}%)`, 'video');
                
                if (receivedCount === totalFrames) {
                    showLog('All frames received for current file!', 'video');
                } else {
                    const missing = totalFrames - receivedCount;
                    showLog(`Still missing ${missing} frames - will capture them when processing resumes`, 'video');
                }
            }
        }

        function processNextFrameBatch() {
            if (!isProcessingVideo) return;
            
            // Calculate dynamic batch size based on performance and video characteristics
            // Use larger batches for videos with fewer found QRs to speed up processing
            let batchSize;
            if (capturedFramesCount > 0) {
                const qrRatio = framesCapturedWithQR / capturedFramesCount;
                if (qrRatio > 0.5) {
                    // High QR density - use smaller batches to process more carefully
                    batchSize = 10;
                } else if (qrRatio > 0.1) {
                    // Medium QR density - moderate batch size
                    batchSize = 20;
                } else {
                    // Low QR density - process more frames at once
                    batchSize = 50;
                }
            } else {
                // No data yet - start with moderate batch size
                batchSize = 25;
            }
            
            // Handle very large videos by ensuring reasonable progress
            if (totalFrames > 10000) {
                batchSize = Math.max(batchSize, Math.floor(totalFrames / 500)); // At least 500 batches
            }
            
            const startFrame = currentProcessingFrame;
            const endFrame = Math.min(startFrame + batchSize, totalFrames);
            
            if (startFrame % 20 === 0 || startFrame === 0) {
                showLog(`Processing frames ${startFrame+1} to ${endFrame} of ${totalFrames}`, 'video');
            }
            
            // For videos with Infinity duration, use time-based increments
            if (!isFinite(processingVideo.duration) || processingVideo.duration <= 0) {
                // Update time display
                videoTimeDisplay.textContent = processingVideo.currentTime.toFixed(1) + 's';
                
                // For Infinity duration, use time increments instead of duration-based calculations
                processingVideo.currentTime += 1; // Move forward 1 second
                
                // Use requestAnimationFrame instead of nested setTimeout
                requestAnimationFrame(() => {
                    captureAndProcessFrame(processingVideo.currentTime);
                    currentProcessingFrame++;
                    updateProgressBar(currentProcessingFrame, totalFrames);
                    requestAnimationFrame(processNextFrameBatch);
                });
                return;
            }
            
            processingVideo.onseeked = () => {
                isWaitingForSeek = false; // Clear the seek waiting flag
                
                // Create and initialize context with willReadFrequently only once
                if (!canvas.willReadFrequently) {
                    // Set canvas size
                    canvas.width = processingVideo.videoWidth;
                    canvas.height = processingVideo.videoHeight;
                    // Create optimized context for frequent pixel reading
                    ctx = canvas.getContext('2d', { willReadFrequently: true });
                    canvas.willReadFrequently = true;
                }
                
                // Process the current frame
                ctx.drawImage(processingVideo, 0, 0);
                
                capturedFramesCount++;
                videoFramesCounter.textContent = capturedFramesCount;
                
                try {
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    // Use a Web Worker for QR detection if supported
                    // This is a fallback using direct detection when workers aren't available
                    const qrCode = jsQR(imageData.data, imageData.width, imageData.height, {
                        inversionAttempts: 'dontInvert'
                    });
                    
                    if (qrCode) {
                        // Mark this frame on the video preview
                        ctx.strokeStyle = 'lime';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                        ctx.lineTo(qrCode.location.topRightCorner.x, qrCode.location.topRightCorner.y);
                        ctx.lineTo(qrCode.location.bottomRightCorner.x, qrCode.location.bottomRightCorner.y);
                        ctx.lineTo(qrCode.location.bottomLeftCorner.x, qrCode.location.bottomLeftCorner.y);
                        ctx.lineTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                        ctx.stroke();
                        
                        // Process the QR data
                        framesCapturedWithQR++;
                        videoQrCounter.textContent = framesCapturedWithQR;
                        processQrData(qrCode.data, 'video');
                        
                        // Store time range where QR was found for better future processing
                        try {
                            foundQRTimeRanges.push({
                                start: Math.max(0, processingVideo.currentTime - 0.5),
                                end: Math.min(processingVideo.duration, processingVideo.currentTime + 0.5)
                            });
                        } catch(e) {
                            console.error("Error storing QR time range:", e);
                        }
                    }
                } catch (err) {
                    // Log error but continue processing
                    console.error("Error processing frame:", err);
                }
                
                // Move to next frame
                currentProcessingFrame++;
                updateProgressBar(currentProcessingFrame, totalFrames);
                
                // Use requestAnimationFrame for better performance and to avoid setTimeout violations
                if (currentProcessingFrame < endFrame && isProcessingVideo) {
                    // Process next frame in the current batch using requestAnimationFrame
                    requestAnimationFrame(() => seekToFrame(currentProcessingFrame));
                } else if (currentProcessingFrame < totalFrames && isProcessingVideo) {
                    // Process next batch
                    requestAnimationFrame(processNextFrameBatch);
                } else {
                    // Done processing
                    if (isProcessingVideo) {
                        showLog('Video processing complete', 'video');
                        stopVideoProcessing();
                        
                        // Update completion stats
                        showLog(`Processed ${capturedFramesCount} frames, found QR codes in ${framesCapturedWithQR} frames`, 'video');
                        
                        // Check if we found all frames
                        if (startReceived && framesReceived.every(Boolean)) {
                            assembleAndDownloadFile('video');
                        } else if (startReceived) {
                            const missingFrames = framesReceived
                                .map((received, i) => received ? null : i + 1)
                                .filter(Boolean);
                            
                            if (missingFrames.length > 20) {
                                showLog(`Missing ${missingFrames.length} frames`, 'video');
                            } else {
                                showLog(`Missing frames: ${missingFrames.join(', ')}`, 'video');
                            }
                            
                            // Offer to continue processing if we haven't processed the whole video
                            if (currentProcessingFrame < totalFrames - 1) {
                                showLog('Continuing to process more frames to find missing QR codes...', 'video');
                                requestAnimationFrame(() => {
                                    if (isProcessingVideo) return; // Already restarted
                                    startVideoProcessing();
                                });
                            } else {
                                showLog('Processed all frames but still missing some QR codes.', 'video');
                                showLog('Try playing the video manually to catch missing frames.', 'video');
                            }
                        }
                    }
                }
            };
            
            // Start processing by seeking to the first frame in the batch
            isWaitingForSeek = true;
            lastSeekTime = Date.now();
            seekToFrame(startFrame);
            
            // Safety check to prevent getting stuck
            // If seek operation doesn't complete within 2 seconds, force continue
            setTimeout(() => {
                if (isWaitingForSeek && Date.now() - lastSeekTime > 2000) {
                    showLog(`Seek timeout at frame ${currentProcessingFrame}, forcing continue`, 'video');
                    isWaitingForSeek = false;
                    currentProcessingFrame++;
                    
                    if (currentProcessingFrame < totalFrames && isProcessingVideo) {
                        setTimeout(processNextFrameBatch, 10);
                    } else {
                        showLog('Video processing complete (with timeouts)', 'video');
                        stopVideoProcessing();
                    }
                }
            }, 2000);
        }

        function seekToFrame(frameIndex) {
            // Check if we need to prioritize areas where QR codes were already found
            if (foundQRTimeRanges.length > 0 && frameIndex > totalFrames * 0.3) {
                // After processing 30% of the video normally, start focusing on promising areas
                
                // Check if we're in a batch that should prioritize QR areas
                if (frameIndex % 20 === 0) { // Every 20 frames
                    // Find closest QR range to current position
                    const currentTime = (frameIndex * processingVideo.duration) / totalFrames;
                    let bestRange = null;
                    let bestDistance = Infinity;
                    
                    for (const range of foundQRTimeRanges) {
                        const midpoint = (range.start + range.end) / 2;
                        const distance = Math.abs(midpoint - currentTime);
                        
                        if (distance < bestDistance) {
                            bestDistance = distance;
                            bestRange = range;
                        }
                    }
                    
                    // If we found a close range, bias our next several frames toward it
                    if (bestRange && bestDistance < processingVideo.duration / 4) {
                        // Calculate a time within this range
                        const rangeWidth = bestRange.end - bestRange.start;
                        const positionInRange = (frameIndex % 10) / 10; // Position 0-1 within range
                        const targetTime = bestRange.start + (rangeWidth * positionInRange);
                        
                        // Use this target time with small jitter
                        const jitter = Math.random() * 0.03;
                        processingVideo.currentTime = Math.min(
                            targetTime + jitter, 
                            processingVideo.duration - 0.1
                        );
                        
                        if (frameIndex % 10 === 0) {
                            showLog(`Focusing on QR region at ${processingVideo.currentTime.toFixed(2)}s`, 'video');
                        }
                        return;
                    }
                }
            }
            
            // Normal timestamp calculation with adaptive frame rate
            let time;
            
            // Use smart distribution of frames - more at the beginning, fewer later
            if (frameIndex < totalFrames * 0.5) {
                // First half of frames: normal distribution
                time = (frameIndex * processingVideo.duration) / totalFrames;
            } else {
                // Second half: exponential distribution to focus more on beginning
                const factor = 1 + (frameIndex / totalFrames) * 2;
                time = (frameIndex * processingVideo.duration) / (totalFrames * factor);
            }
            
            // Add a small random offset to avoid getting stuck on the same frame
            const randomOffset = Math.random() * 0.05; // Up to 50ms jitter
            
            // Validate the time to prevent non-finite error
            if (isFinite(time) && time >= 0 && time <= processingVideo.duration) {
                // Ensure we don't exceed video duration
                const safeTime = Math.min(time + randomOffset, processingVideo.duration - 0.1);
                processingVideo.currentTime = safeTime;
                
                // Log frame position for debugging
                if (frameIndex % 50 === 0) {
                    showLog(`Seeking to frame ${frameIndex}: ${safeTime.toFixed(2)}s`, 'video');
                }
            } else {
                console.warn(`Invalid time value: ${time}, using 0 instead`);
                processingVideo.currentTime = 0;
            }
        }

        // QR code data processing
        function processQrData(data, type = 'live') {
            const now = Date.now();
            
            // More intelligent debounce for QR processing
            // Allow re-processing of the same code after a longer time
            // but immediately accept new codes
            let isRepeat = false;
            if (data === lastQrData) {
                // For very short intervals, always debounce
                if (now - lastQrTime < 300) {
                    return;
                }
                // For medium intervals, only accept critical frames (metadata/set headers) 
                if (now - lastQrTime < 2000) {
                    try {
                        const temp = JSON.parse(data);
                        if (temp.type !== "metadata" && temp.type !== "set_header") {
                            isRepeat = true;
                        }
                    } catch(e) {
                        // If we can't parse, treat as duplicate
                        isRepeat = true;
                    }
                    
                    if (isRepeat) {
                        return;
                    }
                }
                // After 2 seconds, always process even if repeated
            }
            
            lastQrData = data;
            lastQrTime = now;
            
            try {
                let jsonData;
                try {
                    jsonData = JSON.parse(data);
                } catch (err) {
                    // Attempt to extract JSON from any wrapping text
                    const jsonMatch = data.match(/\{.*\}/);
                    if (jsonMatch) {
                        try {
                            jsonData = JSON.parse(jsonMatch[0]);
                        } catch (e) {
                            return; // Still not valid JSON, ignore
                        }
                    } else {
                        return; // Not valid JSON, ignore
                    }
                }
                
                // Process different QR data formats
                
                // Modern format (metadata, set_header, chunk, end)
                if (jsonData.type) {
                    if (jsonData.type === "metadata") {
                        // Log this important event prominently
                        showLog(`🎯 METADATA FRAME DETECTED! File: ${jsonData.file_name || "unknown"}`, type);
                        
                        // Create a file identifier using name, size and timestamp if available
                        const newFileName = jsonData.file_name || "file.dat";
                        const newFileSize = jsonData.file_size || 0;
                        
                        // Generate a unique ID for this file based on name and size
                        const fileId = `${newFileName}_${newFileSize}`;
                        
                        // Check if we've seen this file before
                        const isKnownFile = fileId === currentFileId && fileHistory[fileId];
                        
                        if (isKnownFile) {
                            // We're seeing the same file again - this is a repeat
                            showLog(`🔄 Detected SAME FILE again: ${newFileName}`, type);
                            showLog(`Continuing where we left off - focusing on missing frames`, type);
                            
                            // Restore file data from history
                            startReceived = true;
                            totalFramesExpected = fileHistory[fileId].totalFrames;
                            fileName = newFileName;
                            fileSize = newFileSize;
                            framesData = [...fileHistory[fileId].framesData];
                            framesReceived = [...fileHistory[fileId].framesReceived];
                            qrGridSize = fileHistory[fileId].qrGridSize || 1;
                            
                            // Count how many frames we're missing
                            const missingCount = framesReceived.filter(received => !received).length;
                            showLog(`Already have ${totalFramesExpected - missingCount}/${totalFramesExpected} chunks (${missingCount} missing)`, type);
                            
                            // If file is already complete, just download it
                            if (missingCount === 0) {
                                showLog(`✅ All chunks already received for this file!`, type);
                                isFileComplete = true;
                                if (type === 'video') {
                                    assembleAndDownloadFile(type);
                                }
                            } else {
                                isFileComplete = false;
                                showLog(`🔍 Looking for the ${missingCount} missing chunks...`, type);
                            }
                        } else {
                            // New file or reset - start fresh
                            startReceived = true;
                            currentFileId = fileId;
                            isFileComplete = false;
                            
                            // Store grid size information if present
                            if (jsonData.qr_grid_size) {
                                qrGridSize = parseInt(jsonData.qr_grid_size) || 1;
                                if (qrGridSize > 1) {
                                    showLog(`QR Grid Layout: ${qrGridSize} QRs per frame detected from metadata`, type);
                                }
                            }
                            
                            // Calculate total chunks from various possible formats
                            let totalChunks = 0;
                            
                            if (jsonData.total_chunks) {
                                // Direct total chunks field
                                totalChunks = jsonData.total_chunks;
                            } else if (jsonData.total_sets && jsonData.chunks_per_set) {
                                // Calculate from sets and chunks per set
                                totalChunks = jsonData.total_sets * jsonData.chunks_per_set;
                            } else if (jsonData.file_size && (jsonData.chunk_size || jsonData.bytes_per_chunk)) {
                                // Calculate from file size and chunk size
                                const chunkSize = jsonData.chunk_size || jsonData.bytes_per_chunk || 500;
                                totalChunks = Math.ceil(jsonData.file_size / (chunkSize * 0.75)); // Approximate for base64 expansion
                            }
                            
                            totalFramesExpected = totalChunks || 0;
                            fileName = newFileName;
                            fileSize = newFileSize;
                            
                            // Initialize data structures with the correct size
                            framesData = Array(totalFramesExpected).fill('');
                            framesReceived = Array(totalFramesExpected).fill(false);
                            
                            // Display comprehensive metadata information
                            const metadataInfo = `
🔍 METADATA INFORMATION:
------------------------
📄 File Name: ${fileName}
📦 File Size: ${formatFileSize(fileSize)}
📊 Total Chunks: ${totalFramesExpected}
⏰ Timestamp: ${new Date(jsonData.timestamp).toLocaleString()}
${jsonData.total_sets ? `📚 Organization: ${jsonData.total_sets} sets with ${jsonData.chunks_per_set} chunks per set` : ''}
${jsonData.qr_grid_size ? `📱 QR Grid: ${jsonData.qr_grid_size} QRs per frame` : '📱 QR Grid: Single QR per frame'}
${jsonData.selected_sets ? `🎯 Selected Sets: ${jsonData.selected_sets.length} of ${jsonData.total_sets}` : ''}
------------------------`;
                            
                            console.log(metadataInfo);
                            showLog(`Metadata details: ${fileName}, ${totalFramesExpected} chunks, size: ${formatFileSize(fileSize)}`, type);
                            
                            // Detailed logging
                            if (jsonData.total_sets) {
                                showLog(`Organization: ${jsonData.total_sets} sets with ${jsonData.chunks_per_set} chunks per set`, type);
                            }
                        }
                        
                        // Save file data to history
                        fileHistory[fileId] = {
                            fileName: fileName,
                            fileSize: fileSize,
                            totalFrames: totalFramesExpected,
                            framesData: [...framesData],
                            framesReceived: [...framesReceived],
                            qrGridSize: qrGridSize,
                            firstSeen: Date.now(),
                            receivedCount: framesReceived.filter(Boolean).length
                        };
                        
                        // Update visual display
                        updateGrid(type);
                        
                        // Estimate total time to receive all chunks
                        if (detectedFrameRates.length > 0) {
                            const avgFrameRate = detectedFrameRates.reduce((sum, rate) => sum + rate, 0) / detectedFrameRates.length;
                            const estimatedSeconds = totalFramesExpected / avgFrameRate;
                            showLog(`Estimated time to receive all chunks: ${(estimatedSeconds / 60).toFixed(1)} minutes`, type);
                        }
                    }
                    else if (jsonData.type === "chunk" && startReceived) {
                        // Calculate global chunk index
                        let chunkIndex = -1;
                        
                        if (jsonData.chunk_index && jsonData.set_index) {
                            // Format with set_index and chunk_index
                            const setIndex = jsonData.set_index - 1; // 1-indexed to 0-indexed
                            const localChunkIndex = jsonData.chunk_index - 1; // 1-indexed to 0-indexed
                            const chunksPerSet = jsonData.chunks_in_set || 50; // Default from encoder
                            
                            chunkIndex = (setIndex * chunksPerSet) + localChunkIndex;
                        } else if (jsonData.chunk_index) {
                            // Simple format with just chunk_index
                            chunkIndex = jsonData.chunk_index - 1; // 1-indexed to 0-indexed
                        }
                        
                        // Process the chunk if valid index
                        if (chunkIndex >= 0 && chunkIndex < totalFramesExpected) {
                            blinkCell(chunkIndex, type);
                            
                            if (!framesReceived[chunkIndex]) {
                                framesData[chunkIndex] = jsonData.data || '';
                                framesReceived[chunkIndex] = true;
                                
                                const chunkSize = jsonData.data ? jsonData.data.length : 0;
                                showLog(`Chunk ${chunkIndex + 1}/${totalFramesExpected} received (${chunkSize} chars)`, type);
                                
                                // Update the file history for this chunk
                                if (currentFileId && fileHistory[currentFileId]) {
                                    fileHistory[currentFileId].framesData[chunkIndex] = jsonData.data || '';
                                    fileHistory[currentFileId].framesReceived[chunkIndex] = true;
                                    fileHistory[currentFileId].receivedCount = fileHistory[currentFileId].framesReceived.filter(Boolean).length;
                                    fileHistory[currentFileId].lastUpdated = Date.now();
                                }
                                
                                // Only update grid occasionally for performance
                                if (chunkIndex % 5 === 0) {
                                    updateGrid(type);
                                }
                                
                                // Check if all frames received
                                const missingCount = framesReceived.filter(received => !received).length;
                                const receivedCount = totalFramesExpected - missingCount;
                                
                                if (receivedCount === totalFramesExpected) {
                                    showLog('💯 All chunks received!', type);
                                    updateGrid(type); // Final update
                                    
                                    // Mark file as complete
                                    isFileComplete = true;
                                    if (currentFileId && fileHistory[currentFileId]) {
                                        fileHistory[currentFileId].isComplete = true;
                                    }
                                    
                                    if (type === 'live') {
                                        assembleAndDownloadFile(type);
                                    }
                                } else if (receivedCount % 10 === 0) {
                                    // Log progress at regular intervals
                                    showLog(`Progress: ${receivedCount}/${totalFramesExpected} chunks (${Math.round(receivedCount/totalFramesExpected*100)}%)`, type);
                                }
                            } else {
                                // We already have this chunk - skip it but let the user know
                                if (chunkIndex % 10 === 0) {
                                    showLog(`Skipping already received chunk ${chunkIndex + 1}/${totalFramesExpected}`, type);
                                }
                            }
                        }
                    }
                }
                // Legacy/old format (marker-based)
                else if (jsonData.marker) {
                    // Process start marker
                    if (jsonData.marker === "###QRSTART###" && !startReceived) {
                        startReceived = true;
                        totalFramesExpected = jsonData.frames;
                        fileName = jsonData.file;
                        fileSize = jsonData.size || 0;
                        
                        framesData = Array(totalFramesExpected).fill('');
                        framesReceived = Array(totalFramesExpected).fill(false);
                        
                        showLog(`Start marker: ${fileName}, ${totalFramesExpected} frames, size: ${fileSize}`, type);
                        updateGrid(type);
                    }
                    // Process data marker
                    else if (jsonData.marker === "#DATA#" && startReceived) {
                        const frameIndex = jsonData.current - 1;
                        
                        blinkCell(frameIndex, type);
                        
                        if (frameIndex < framesData.length && !framesReceived[frameIndex]) {
                            framesData[frameIndex] = jsonData.contents;
                            framesReceived[frameIndex] = true;
                            
                            showLog(`Frame ${frameIndex + 1}/${totalFramesExpected} received (${jsonData.contents.length} chars)`, type);
                            updateGrid(type);
                            
                            // Check if all frames received
                            if (framesReceived.every(Boolean)) {
                                showLog('All frames received!', type);
                                if (type === 'live') {
                                    assembleAndDownloadFile(type);
                                }
                            }
                        }
                    }
                }
            } catch (err) {
                console.error("Error processing QR data:", err);
                if (err.message !== lastQrError) {
                    // Only log new errors to avoid spam
                    showLog(`Error processing QR data: ${err.message}`, type);
                    lastQrError = err.message;
                }
            }
        }
        
        // Variable to track last error message
        let lastQrError = '';
        
        // Format file size for display
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' bytes';
            else if (bytes < 1048576) return (bytes / 1024).toFixed(2) + ' KB';
            else if (bytes < 1073741824) return (bytes / 1048576).toFixed(2) + ' MB';
            else return (bytes / 1073741824).toFixed(2) + ' GB';
        }
        
        // Save frame for diagnostic purposes
        function saveFrameForDiagnostics(canvas, frameNumber, timePosition) {
            // Only save every 30th frame or frames with QR codes
            if (frameNumber % 30 !== 0 && framesCapturedWithQR === 0) return;
            
            try {
                // Limit total saved frames to avoid memory issues
                if (savedFrameCounter > 100) return;
                
                // Create a copy of the canvas with timestamp overlay
                const diagCanvas = document.createElement('canvas');
                diagCanvas.width = canvas.width;
                diagCanvas.height = canvas.height;
                const diagCtx = diagCanvas.getContext('2d');
                
                // Draw the frame
                diagCtx.drawImage(canvas, 0, 0);
                
                // Add frame information overlay
                diagCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                diagCtx.fillRect(0, 0, canvas.width, 30);
                diagCtx.fillStyle = 'white';
                diagCtx.font = '14px monospace';
                diagCtx.fillText(`Frame: ${frameNumber} | Time: ${timePosition.toFixed(2)}s | Res: ${canvas.width}×${canvas.height}`, 10, 20);
                
                // Convert to data URL (could be saved to IndexedDB in a production app)
                const dataURL = diagCanvas.toDataURL('image/jpeg', 0.7);
                
                // In a real app, we'd save this. For this demo, we log it
                console.log(`Saved diagnostic frame #${frameNumber} at ${timePosition.toFixed(2)}s`);
                savedFrameCounter++;
                
                // In production you could implement:
                // - Save to IndexedDB
                // - Download as a file
                // - Send to server
            } catch (err) {
                console.error("Error saving diagnostic frame:", err);
            }
        }
        
        // Enhance image for better QR detection
        function enhanceImageForQRDetection(imageData) {
            // Create a copy of the image data to work with
            const enhancedData = new ImageData(
                new Uint8ClampedArray(imageData.data),
                imageData.width,
                imageData.height
            );
            
            // Apply contrast enhancement
            const data = enhancedData.data;
            const contrast = 1.5; // Increase contrast
            const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
            
            for (let i = 0; i < data.length; i += 4) {
                // Apply contrast to RGB channels
                data[i] = factor * (data[i] - 128) + 128;     // R
                data[i+1] = factor * (data[i+1] - 128) + 128; // G
                data[i+2] = factor * (data[i+2] - 128) + 128; // B
                // Alpha remains unchanged
            }
            
            return enhancedData;
        }
        
        // Track QR size statistics to optimize detection
        function updateQRSizeStats(qrCode) {
            try {
                const width = Math.abs(qrCode.location.topRightCorner.x - qrCode.location.topLeftCorner.x);
                const height = Math.abs(qrCode.location.bottomLeftCorner.y - qrCode.location.topLeftCorner.y);
                
                qrSizeStats.count++;
                qrSizeStats.totalWidth += width;
                qrSizeStats.totalHeight += height;
                qrSizeStats.minWidth = Math.min(qrSizeStats.minWidth, width);
                qrSizeStats.maxWidth = Math.max(qrSizeStats.maxWidth, width);
                qrSizeStats.minHeight = Math.min(qrSizeStats.minHeight, height);
                qrSizeStats.maxHeight = Math.max(qrSizeStats.maxHeight, height);
                
                // Log stats periodically
                if (qrSizeStats.count % 10 === 0) {
                    const avgWidth = qrSizeStats.totalWidth / qrSizeStats.count;
                    const avgHeight = qrSizeStats.totalHeight / qrSizeStats.count;
                    
                    console.log(`QR size stats after ${qrSizeStats.count} detections:
                        Avg: ${avgWidth.toFixed(1)}×${avgHeight.toFixed(1)}px
                        Min: ${qrSizeStats.minWidth.toFixed(1)}×${qrSizeStats.minHeight.toFixed(1)}px
                        Max: ${qrSizeStats.maxWidth.toFixed(1)}×${qrSizeStats.maxHeight.toFixed(1)}px`);
                }
            } catch (err) {
                console.error("Error updating QR size stats:", err);
            }
        }
        
        // Track time between QR detections to estimate frame rate
        function trackFrameRate(timePosition) {
            const now = Date.now();
            
            if (lastQrDetectionTime > 0) {
                const timeDiff = now - lastQrDetectionTime;
                
                // Only track if less than 1 second between detections
                if (timeDiff < 1000) {
                    detectedFrameRates.push(1000 / timeDiff);
                    
                    // Keep only recent measurements
                    if (detectedFrameRates.length > 20) {
                        detectedFrameRates.shift();
                    }
                    
                    // Log estimated frame rate periodically
                    if (detectedFrameRates.length > 5 && framesCapturedWithQR % 10 === 0) {
                        const avgFrameRate = detectedFrameRates.reduce((sum, rate) => sum + rate, 0) / detectedFrameRates.length;
                        showLog(`Estimated QR code frame rate: ${avgFrameRate.toFixed(1)} fps`, 'video');
                    }
                }
            }
            
            lastQrDetectionTime = now;
        }
        
        // Try to detect metadata frame with grid size information
        function tryDetectMetadataWithGridSize(imageData, timePosition) {
            // Don't run this detection too often to save CPU
            if (capturedFramesCount % 5 !== 0) return;
            
            try {
                // Try to detect metadata
                const qrCode = jsQR(imageData.data, imageData.width, imageData.height, {
                    inversionAttempts: 'attemptBoth'
                });
                
                if (qrCode) {
                    try {
                        const data = JSON.parse(qrCode.data);
                        
                        // Check if this is a metadata frame with grid size information
                        if (data.type === "metadata" && data.qr_grid_size) {
                            qrGridSize = parseInt(data.qr_grid_size) || 1;
                            
                            if (qrGridSize > 1) {
                                showLog(`Detected QR grid layout: ${qrGridSize} QRs per frame`, 'video');
                            }
                            
                            return true;
                        }
                    } catch (e) {
                        // Not valid JSON or not metadata
                        return false;
                    }
                }
            } catch (err) {
                console.error("Error detecting metadata:", err);
            }
            
            return false;
        }
        
        // Detect QR codes in a grid layout
        function detectQRCodesInGrid(imageData, qrCodes, timePosition) {
            if (qrGridSize <= 1) return false;
            
            try {
                // Calculate grid dimensions
                let cols, rows;
                switch(qrGridSize) {
                    case 2: cols = 2; rows = 1; break; 
                    case 4: cols = 2; rows = 2; break;
                    case 8: cols = 4; rows = 2; break;
                    case 16: cols = 4; rows = 4; break;
                    case 32: cols = 8; rows = 4; break;
                    default: return false; // Unknown grid layout
                }
                
                const cellWidth = Math.floor(imageData.width / cols);
                const cellHeight = Math.floor(imageData.height / rows);
                
                // Check each cell in the grid
                let foundAny = false;
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        // Extract this grid cell
                        const cellData = extractImageRegion(
                            imageData,
                            col * cellWidth,
                            row * cellHeight,
                            cellWidth,
                            cellHeight
                        );
                        
                        // Try to detect QR in this cell
                        const qrCode = jsQR(cellData.data, cellData.width, cellData.height, {
                            inversionAttempts: 'attemptBoth',
                            canOverwriteImage: true,
                            maxModuleCount: 177
                        });
                        
                        if (qrCode) {
                            // Adjust QR code coordinates to the full image
                            adjustQRCodeCoordinates(qrCode, col * cellWidth, row * cellHeight);
                            
                            // Add to detected QR codes
                            qrCodes.push(qrCode);
                            foundAny = true;
                            
                            // Track frame rate and size stats
                            updateQRSizeStats(qrCode);
                            trackFrameRate(timePosition);
                        }
                    }
                }
                
                return foundAny;
            } catch (err) {
                console.error("Error in grid detection:", err);
                return false;
            }
        }
        
        // Extract a region from an ImageData object
        function extractImageRegion(imageData, x, y, width, height) {
            // Create a temporary canvas to extract the region
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Create a temporary ImageData to draw the full image
            const fullCanvas = document.createElement('canvas');
            fullCanvas.width = imageData.width;
            fullCanvas.height = imageData.height;
            const fullCtx = fullCanvas.getContext('2d');
            fullCtx.putImageData(imageData, 0, 0);
            
            // Draw the region into the temporary canvas
            tempCtx.drawImage(fullCanvas, x, y, width, height, 0, 0, width, height);
            
            // Get the image data for just this region
            return tempCtx.getImageData(0, 0, width, height);
        }
        
        // Adjust QR code coordinates from a grid cell to the full image
        function adjustQRCodeCoordinates(qrCode, offsetX, offsetY) {
            const locations = ['topLeftCorner', 'topRightCorner', 'bottomLeftCorner', 'bottomRightCorner'];
            
            for (const location of locations) {
                qrCode.location[location].x += offsetX;
                qrCode.location[location].y += offsetY;
            }
        }

        function assembleAndDownloadFile(type) {
            try {
                // Combine all data chunks
                const base64Data = framesData.join('');
                showLog(`Combined base64 data: ${base64Data.length} chars`, type);
                
                // Convert base64 to binary
                const rawData = atob(base64Data);
                showLog(`Decoded data length: ${rawData.length} bytes`, type);
                
                // Create typed array
                const bytes = new Uint8Array(rawData.length);
                for (let i = 0; i < rawData.length; i++) {
                    bytes[i] = rawData.charCodeAt(i);
                }
                
                // Verify size if provided
                if (fileSize > 0 && bytes.length !== fileSize) {
                    showLog(`Size mismatch: got ${bytes.length}, expected ${fileSize}`, type);
                }
                
                // Create blob and download
                const blob = new Blob([bytes], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName.replace(/\.b64$/, '');
                a.click();
                
                URL.revokeObjectURL(url);
                showLog(`File downloaded: ${fileName}`, type);
                
                if (type === 'live') {
                    stopLiveScanning();
                }
            } catch (err) {
                showLog(`Error assembling file: ${err.message}`, type);
            }
        }

        // Event listeners
        startLiveBtn.addEventListener('click', startLiveScanning);
        stopLiveBtn.addEventListener('click', stopLiveScanning);
        
        openVideoBtn.addEventListener('click', () => fileInput.click());
        quickAnalysisBtn.addEventListener('click', performQuickAnalysis);
        processVideoBtn.addEventListener('click', startVideoProcessing);
        stopProcessingBtn.addEventListener('click', stopVideoProcessing);
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFileInput(e.target.files[0]);
            }
        });

        // Drag and drop support
        dropzone.addEventListener('click', () => fileInput.click());
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropzone.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
        });
        
        dropzone.addEventListener('dragover', () => {
            dropzone.style.backgroundColor = '#e6e6e6';
        });
        
        dropzone.addEventListener('dragleave', () => {
            dropzone.style.backgroundColor = '#f9f9f9';
        });
        
        dropzone.addEventListener('drop', (e) => {
            dropzone.style.backgroundColor = '#f9f9f9';
            
            if (e.dataTransfer.files.length > 0) {
                handleFileInput(e.dataTransfer.files[0]);
            }
        });

        // Add manual frame capture from video playback
        processingVideo.addEventListener('play', () => {
            // Only activate when not actively processing
            if (!isProcessingVideo && processingVideo.src) {
                const captureInterval = setInterval(() => {
                    if (processingVideo.paused || processingVideo.ended || isProcessingVideo) {
                        clearInterval(captureInterval);
                        return;
                    }
                    
                    // Capture the current frame during normal playback
                    canvas.width = processingVideo.videoWidth;
                    canvas.height = processingVideo.videoHeight;
                    ctx.drawImage(processingVideo, 0, 0);
                    
                    capturedFramesCount++;
                    videoFramesCounter.textContent = capturedFramesCount;
                    
                    try {
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const qrCode = jsQR(imageData.data, imageData.width, imageData.height, {
                            inversionAttempts: 'dontInvert'
                        });
                        
                        if (qrCode) {
                            framesCapturedWithQR++;
                            videoQrCounter.textContent = framesCapturedWithQR;
                            processQrData(qrCode.data, 'video');
                            
                            // Visual feedback
                            ctx.strokeStyle = 'lime';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                            ctx.lineTo(qrCode.location.topRightCorner.x, qrCode.location.topRightCorner.y);
                            ctx.lineTo(qrCode.location.bottomRightCorner.x, qrCode.location.bottomRightCorner.y);
                            ctx.lineTo(qrCode.location.bottomLeftCorner.x, qrCode.location.bottomLeftCorner.y);
                            ctx.lineTo(qrCode.location.topLeftCorner.x, qrCode.location.topLeftCorner.y);
                            ctx.stroke();
                        }
                    } catch (err) {
                        // Silent catch
                    }
                }, 200); // Capture 5 frames per second during normal playback
            }
        });
        
        // Initialize
        showLog('Ready to scan. Click "Start Camera" to begin.', 'live');
        showLog('Ready to process. Select a video file to begin.', 'video');
    </script>
</body>

</html>