<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>QR File Transfer - Optimized Encoder</title><script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script><style>*{margin:0;padding:0;box-sizing:border-box}
body{font-family:system-ui,-apple-system,sans-serif;line-height:1.5;background:#f5f5f5;color:#333;max-width:1200px;margin:0 auto;padding:20px}
h1{margin:20px 0;color:#2563eb}
.container{display:flex;flex-wrap:wrap;gap:20px}
.panel{background:#fff;padding:20px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,.1);flex:1;min-width:300px}
.control-panel{display:flex;flex-direction:column;gap:15px}
.control-group{display:flex;flex-direction:column;gap:8px}
.control-label{font-weight:700}
button{padding:12px;background:#2563eb;color:#fff;border:none;border-radius:4px;cursor:pointer;font-weight:700;margin-top:10px;transition:background .2s}
button:hover{background:#1d4ed8}
button:disabled{background:#94a3b8;cursor:not-allowed}
.display-container{display:flex;flex-direction:column;align-items:center;justify-content:center}
#qrDisplay{position:relative;margin:0 auto 20px;border:1px solid #ddd;padding:20px;border-radius:8px;background:#fff;max-width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center}
.progress-container{width:100%;background:#e5e7eb;border-radius:4px;overflow:hidden;height:10px;margin-top:15px}
.progress-bar{height:100%;background:#2563eb;width:0;transition:width .3s}
.file-info{margin-top:20px;padding:15px;background:#f0f9ff;border-radius:8px;border-left:4px solid #2563eb}
.metadata-info{margin-top:10px;padding:10px;background:#f0f9ff;border-radius:8px;border-left:4px solid #1d4ed8}
.info-row{display:flex;justify-content:space-between;margin-bottom:8px}
.info-label{font-weight:700;color:#1e40af}
.fullscreen{position:fixed;top:0;left:0;width:100vw;height:100vh;background:#000;z-index:1000;display:flex;justify-content:center;align-items:center;flex-direction:column}
.fullscreen .qr-container{
display:flex;
justify-content:center;
align-items:center;
width:80vmin;
height:80vmin;
position:relative;
}
.fullscreen-qr {
width: 100%;
height: 100%;
object-fit: contain;
max-width: 95vh;
max-height: 95vh;
}
.fullscreen-progress{position:absolute;bottom:50px;width:80%;max-width:400px}
.fullscreen-counter{position:absolute;top:20px;left:20px;background:rgba(0,0,0,.5);color:#fff;padding:10px;border-radius:4px;font-weight:bold;font-size:16px;z-index:10}
.exit-button{position:absolute;top:20px;right:20px;background:#ef4444;color:#fff;border:none;width:40px;height:40px;border-radius:20px;font-size:20px;cursor:pointer}
.countdown-display{
font-size:120px;
color:#1890ff;
position:absolute;
top:50%;
left:50%;
transform:translate(-50%,-50%);
text-shadow:0 0 10px rgba(24,144,255,.5);
z-index:100;
display:none;
background:rgba(0,0,0,.4);
width:200px;
height:200px;
border-radius:50%;
line-height:200px;
text-align:center;
font-weight:bold;
}
.fullscreen .countdown-display {
width: 250px;
height: 250px;
line-height: 250px;
font-size: 150px;
background: rgba(0,0,0,.6);
}
input[type=range]{width:100%;height:8px;background:#e5e7eb;border-radius:4px;appearance:none;outline:0}
input[type=range]::-webkit-slider-thumb{appearance:none;width:16px;height:16px;background:#2563eb;border-radius:50%;cursor:pointer}
.slider-labels{display:flex;justify-content:space-between;font-size:12px;color:#6b7280;margin-top:5px}
.value-display{font-weight:700;color:#2563eb;margin-left:auto}
.file-input-container{position:relative;overflow:hidden;display:inline-block;width:100%}
.file-input-label{padding:12px;background:#e5e7eb;color:#333;border-radius:4px;cursor:pointer;display:block;text-align:center;transition:background .2s}
.file-input-label:hover{background:#d1d5db}
.file-input-container input[type=file]{position:absolute;left:0;top:0;opacity:0;width:100%;height:100%;cursor:pointer}
.file-list-container{margin-top:15px;background:#f9fafb;border-radius:8px;padding:15px;display:none}
.file-list-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;font-weight:600}
.file-list{max-height:300px;overflow-y:auto}
.file-item{display:flex;align-items:center;padding:8px;border-bottom:1px solid #e5e7eb;transition:background .2s}
.file-item:hover{background:#f3f4f6}
.file-item:last-child{border-bottom:none}
.file-checkbox{margin-right:12px;width:18px;height:18px;cursor:pointer}
.file-info{flex:1;display:flex;flex-direction:column}
.file-name{font-weight:500;margin-bottom:2px}
.file-size{font-size:12px;color:#6b7280}
.file-status{margin-left:auto;padding:4px 8px;border-radius:12px;font-size:11px;font-weight:500;text-transform:uppercase}
.status-pending{background:#fef3c7;color:#d97706}
.status-inprogress{background:#dbeafe;color:#2563eb}
.status-sent{background:#dcfce7;color:#16a34a}
.status-error{background:#fee2e2;color:#dc2626}
.batch-controls{display:flex;gap:10px;margin-top:10px}
.select-all-btn,.clear-all-btn{font-size:12px;padding:6px 12px}
.control-switch {
display: flex;
align-items: center;
cursor: pointer;
user-select: none;
margin: 10px 0;
}
.control-switch input[type="checkbox"] {
margin-right: 8px;
width: 16px;
height: 16px;
}
.switch-label {
font-weight: 500;
}
.action-button {
background-color: #16a34a;
width: 100%;
padding: 14px;
font-size: 16px;
}
.action-button:hover {
background-color: #15803d;
}
.alignment-guide {
position: absolute;
border: 3px dashed rgba(59, 130, 246, 0.7);
pointer-events: none;
display: none;
}
#qrDisplay.show-guides .alignment-guide {
display: block;
}
.guide-label {
position: absolute;
background: rgba(0, 0, 0, 0.6);
color: white;
padding: 2px 6px;
border-radius: 4px;
font-size: 12px;
pointer-events: none;
}
.qr-image {
transition: opacity 0.15s ease-out;
}
.preset-selector {
display: flex;
gap: 10px;
margin-bottom: 10px;
flex-wrap: wrap;
}
.preset-button {
padding: 8px 12px;
background: #e5e7eb;
color: #333;
border: 1px solid #d1d5db;
border-radius: 4px;
cursor: pointer;
flex: 1;
min-width: 120px;
text-align: center;
transition: all 0.2s;
}
.preset-button:hover {
background: #d1d5db;
}
.preset-button.active {
background: #2563eb;
color: white;
border-color: #2563eb;
}
.tooltip {
position: relative;
display: inline-block;
margin-left: 5px;
width: 16px;
height: 16px;
background: #e5e7eb;
color: #6b7280;
border-radius: 50%;
text-align: center;
line-height: 16px;
font-size: 11px;
font-weight: bold;
cursor: help;
}
.tooltip:hover::after {
content: attr(data-tooltip);
position: absolute;
top: -5px;
left: 100%;
transform: translateY(-100%);
background: rgba(55, 65, 81, 0.9);
color: white;
padding: 5px 10px;
border-radius: 4px;
width: 200px;
font-weight: normal;
font-size: 12px;
z-index: 10;
line-height: 1.4;
}
.handshake-notice {
margin-top: 20px;
padding: 10px;
background: rgba(245, 158, 11, 0.1);
border-left: 3px solid #f59e0b;
border-radius: 3px;
font-size: 13px;
color: #92400e;
}
@media (max-width:768px){
.container{flex-direction:column}
.handshake-notice, .preset-selector {font-size: 11px;}
.preset-button {padding: 6px 8px; min-width: 90px;}
.control-label {font-size: 14px;}
h1 {font-size: 20px; margin: 10px 0;}
.panel {padding: 15px;}
.slider-labels {font-size: 10px;}
.countdown-display {width: 150px; height: 150px; line-height: 150px; font-size: 90px;}
}</style></head><body><h1>QR Code File Encoder</h1><div class="container"><div class="panel control-panel"><div class="control-group"><label class="control-label">Select File</label><div class="file-input-container"><label class="file-input-label"><span id="fileLabel">Choose files</span><input type="file" id="fileInput" multiple></label></div><div id="fileListContainer" class="file-list-container"><div class="file-list-header"><span>Selected Files</span><div class="batch-controls"><button id="selectAllBtn" class="select-all-btn">Select All</button><button id="clearAllBtn" class="clear-all-btn">Clear All</button></div></div><div id="fileList" class="file-list"></div></div></div><div class="control-group"><label class="control-label">Performance Presets</label><div class="preset-selector"><button id="fastPreset" class="preset-button">Fast Transfer</button><button id="reliablePreset" class="preset-button active">Reliable</button><button id="mobilePreset" class="preset-button">Mobile Optimized</button></div><div style="font-size: 12px; color: #6b7280; margin-top: 5px;">
Presets automatically configure optimal settings for your use case
</div></div><div class="control-group"><div class="control-label">
QR Size <span class="value-display" id="sizeValue">800px</span><span class="tooltip" data-tooltip="Size of the QR code in pixels. Larger QR codes are easier to scan but may not fit on screen.">?</span></div><input type="range" id="sizeSlider" min="200" max="800" value="800"><div class="slider-labels"><span>Smaller</span><span>Larger</span></div></div><div class="control-group"><div class="control-label">
Display Speed <span class="value-display" id="speedValue">6 FPS</span><span class="tooltip" data-tooltip="Frames per second. Higher values transfer data faster, but may be harder to scan.">?</span></div><input type="range" id="speedSlider" min="1" max="30" value="6"><div class="slider-labels"><span>Slower</span><span>Faster</span></div></div><div class="control-group"><div class="control-label">
Chunk Size <span class="value-display" id="chunkValue">450 chars</span><span class="tooltip" data-tooltip="Size of each data chunk. Larger chunks transfer faster but may be harder to scan.">?</span></div><input type="range" id="chunkSlider" min="100" max="1000" step="50" value="450"><div class="slider-labels"><span>Smaller chunks</span><span>Larger chunks</span></div></div><div class="control-group"><div class="control-label">
Redundancy <span class="value-display" id="redundancyValue">100%</span><span class="tooltip" data-tooltip="Extra data to ensure successful transfer. Higher values improve reliability but increase transfer time.">?</span></div><input type="range" id="redundancySlider" min="20" max="200" step="10" value="100"><div class="slider-labels"><span>Less</span><span>More</span></div><div style="font-size: 12px; color: #6b7280; margin-top: 5px;">
For 30% missed frames, use 60-70% redundancy<br>
For 50% missed frames, use 100-120% redundancy
</div></div><div class="control-group"><div class="control-label">
Error Correction Level
<span class="tooltip" data-tooltip="QR code error correction level. Higher levels are more reliable but create larger, more complex QR codes.">?</span></div><div style="display: flex; justify-content: space-between; margin-top: 5px;"><select id="errorCorrectionSelect" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #d1d5db;"><option value="H">High (30% recovery)</option><option value="M">Medium (15% recovery)</option><option value="L">Low (7% recovery)</option></select></div><div style="font-size: 12px; color: #6b7280; margin-top: 5px;">
Higher correction = more reliable but larger QR codes
</div></div><div class="control-group"><div class="control-label">
Max Combined Chunks <span class="value-display" id="maxDegreeValue">2</span><span class="tooltip" data-tooltip="Maximum number of chunks to combine in a single QR code. Lower is safer for reliable scanning.">?</span></div><input type="range" id="maxDegreeSlider" min="1" max="4" step="1" value="2"><div class="slider-labels"><span>Safer (1)</span><span>Denser (4)</span></div><div style="font-size: 12px; color: #6b7280; margin-top: 5px;">
Recommend 1-2 for highest reliability; 3-4 only for perfect conditions
</div></div><div class="control-group"><div class="control-label">
Countdown Before Start <span class="value-display" id="countdownValue">10s</span><span class="tooltip" data-tooltip="Time to prepare before QR codes start displaying.">?</span></div><input type="range" id="countdownSlider" min="0" max="30" value="10"><div class="slider-labels"><span>None</span><span>30s</span></div></div><div class="control-group"><label class="control-switch"><input type="checkbox" id="fullscreenCheckbox" checked><span class="switch-label">Start in Fullscreen Mode (Recommended)</span></label></div><div class="control-group"><label class="control-switch"><input type="checkbox" id="showGuidesCheckbox"><span class="switch-label">Show Scanner Alignment Guides</span></label></div><div class="control-group"><label class="control-switch"><input type="checkbox" id="enableTransitionsCheckbox" checked><span class="switch-label">Enable Smooth Transitions</span><span class="tooltip" data-tooltip="Enables subtle transitions between QR codes to improve scanning reliability.">?</span></label><div style="font-size: 12px; color: #6b7280; margin-top: 5px; margin-left: 24px;">
Always on for best results; disable only for older devices
</div></div><div class="control-group"><label class="control-switch"><input type="checkbox" id="highDensityCheckbox"><span class="switch-label">High Density Mode</span><span class="tooltip" data-tooltip="Increases QR code data capacity but requires enhanced scanner capabilities.">?</span></label><div style="font-size: 12px; color: #6b7280; margin-top: 5px; margin-left: 24px;">
WARNING: Only enable if using the enhanced parallel processing decoder
</div></div><div class="control-group"><button id="generateAndStartBtn" class="action-button" disabled>Generate & Start Display</button><div style="display: flex; gap: 10px; margin-top: 5px;"><button id="generateBtn" disabled>Generate QR Codes</button><button id="stopBtn" disabled style="flex: 1; background: #dc2626;">Stop</button></div><div style="display: flex; gap: 10px; margin-top: 5px;"><button id="startBtn" disabled style="flex: 1;">Start Display</button><button id="fullscreenBtn" disabled style="flex: 1; background: #4b5563;">Fullscreen</button></div></div><div class="handshake-notice"><strong>Handshake Mode</strong>: The first frame contains special setup data that helps the decoder optimize for your specific transfer. Make sure to scan this frame.
</div></div><div class="panel"><div class="display-container"><div id="frameCounter" style="margin-bottom: 10px; font-weight: bold;">Frame: 0 / 0</div><div id="qrDisplay" style="width: 800px; height: 800px; display: flex; align-items: center; justify-content: center;"><div class="alignment-guide" style="width: 90%; height: 90%; top: 5%; left: 5%;"></div><div class="alignment-guide" style="width: 70%; height: 70%; top: 15%; left: 15%;"></div><div class="guide-label" style="top: 2%; left: 50%; transform: translateX(-50%);">Keep QR code within this area</div><div style="color: #6b7280;">QR code will appear here</div><div id="countdownDisplay" class="countdown-display"></div></div><div class="progress-container"><div class="progress-bar" id="progressBar"></div></div></div><div id="fileInfo" class="file-info" style="display: none;"><h3 style="margin-bottom: 10px;">File Information</h3><div class="info-row"><div class="info-label">File Name:</div><div id="fileName">-</div></div><div class="info-row"><div class="info-label">File Size:</div><div id="fileSize">-</div></div><div class="info-row"><div class="info-label">Chunks:</div><div id="chunksCount">-</div></div><div class="info-row"><div class="info-label">Packets:</div><div id="packetsCount">-</div></div><div class="info-row"><div class="info-label">Redundancy Level:</div><div id="redundancyLevel">-</div></div><div class="info-row"><div class="info-label">Transfer Time:</div><div id="transferTime">-</div></div><div class="info-row"><div class="info-label">Optimal Distance:</div><div id="optimalDistance">-</div></div><div class="info-row high-density-indicator" style="display: none;"><div class="info-label" style="color: #b91c1c;">High Density Mode:</div><div style="color: #b91c1c; font-weight: bold;">Active</div></div></div><div id="metadataInfo" class="metadata-info" style="display: none;"><h3 style="margin-bottom: 10px;">Transmission Details</h3><div id="qrCodeInfo" style="margin-bottom: 10px;"><div style="font-weight: bold; color: #1e40af;">Current Frame Type:</div><div id="frameType">-</div></div><div id="currentChunkInfo" style="margin-bottom: 10px; display: none;"><div style="font-weight: bold; color: #1e40af;">Current Chunk:</div><div id="chunkId">-</div></div><div id="transmissionStats" style="margin-top: 10px;"><div style="font-weight: bold; color: #1e40af;">Transmission Stats:</div><div>Elapsed Time: <span id="elapsedTime">0s</span></div><div>Avg Speed: <span id="transmissionSpeed">-</span></div></div></div></div></div><div id="fullscreenDisplay" class="fullscreen" style="display: none;"><div class="qr-container"><img id="fullscreenQR" class="fullscreen-qr" src="" alt="QR Code"><div id="fsCountdownDisplay" class="countdown-display"></div></div><div class="fullscreen-counter" id="fullscreenCounter">Frame: 0 / 0</div><div class="fullscreen-progress progress-container"><div class="progress-bar" id="fullscreenProgressBar"></div></div><button class="exit-button" id="exitFullscreenBtn">&times;</button></div><script>const DEFAULT_QR_CONTENT_SIZE = 3500;
const HIGH_DENSITY_QR_CONTENT_SIZE = 5000;
let MAX_QR_CONTENT_SIZE = DEFAULT_QR_CONTENT_SIZE;
const fileInput = document.getElementById('fileInput');
const fileLabel = document.getElementById('fileLabel');
const speedSlider = document.getElementById('speedSlider');
const sizeSlider = document.getElementById('sizeSlider');
const chunkSlider = document.getElementById('chunkSlider');
const redundancySlider = document.getElementById('redundancySlider');
const countdownSlider = document.getElementById('countdownSlider');
const maxDegreeSlider = document.getElementById('maxDegreeSlider');
const speedValue = document.getElementById('speedValue');
const sizeValue = document.getElementById('sizeValue');
const chunkValue = document.getElementById('chunkValue');
const redundancyValue = document.getElementById('redundancyValue');
const maxDegreeValue = document.getElementById('maxDegreeValue');
const countdownValue = document.getElementById('countdownValue');
const errorCorrectionSelect = document.getElementById('errorCorrectionSelect');
const fullscreenCheckbox = document.getElementById('fullscreenCheckbox');
const showGuidesCheckbox = document.getElementById('showGuidesCheckbox');
const enableTransitionsCheckbox = document.getElementById('enableTransitionsCheckbox');
const highDensityCheckbox = document.getElementById('highDensityCheckbox');
const generateAndStartBtn = document.getElementById('generateAndStartBtn');
const generateBtn = document.getElementById('generateBtn');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const fullscreenBtn = document.getElementById('fullscreenBtn');
const qrDisplay = document.getElementById('qrDisplay');
const progressBar = document.getElementById('progressBar');
const frameCounter = document.getElementById('frameCounter');
const fileInfo = document.getElementById('fileInfo');
const metadataInfo = document.getElementById('metadataInfo');
const frameType = document.getElementById('frameType');
const chunkId = document.getElementById('chunkId');
const currentChunkInfo = document.getElementById('currentChunkInfo');
const elapsedTime = document.getElementById('elapsedTime');
const transmissionSpeed = document.getElementById('transmissionSpeed');
const fileName = document.getElementById('fileName');
const fileSize = document.getElementById('fileSize');
const chunksCount = document.getElementById('chunksCount');
const packetsCount = document.getElementById('packetsCount');
const redundancyLevel = document.getElementById('redundancyLevel');
const transferTime = document.getElementById('transferTime');
const optimalDistance = document.getElementById('optimalDistance');
const fullscreenDisplay = document.getElementById('fullscreenDisplay');
const fullscreenQR = document.getElementById('fullscreenQR');
const fullscreenCounter = document.getElementById('fullscreenCounter');
const fullscreenProgressBar = document.getElementById('fullscreenProgressBar');
const exitFullscreenBtn = document.getElementById('exitFullscreenBtn');
const countdownDisplay = document.getElementById('countdownDisplay');
const fsCountdownDisplay = document.getElementById('fsCountdownDisplay');
const fastPreset = document.getElementById('fastPreset');
const reliablePreset = document.getElementById('reliablePreset');
const mobilePreset = document.getElementById('mobilePreset');
let fileContent = null;
let fileNameText = '';
let fileSizeBytes = 0;
let chunks = [];
let fountainPackets = [];
let displayInterval = null;
let currentFrame = 0;
let totalFrames = 0;
let isPlaying = false;
let isFullscreen = false;
let qrSize = 800;
let startTime = null;
let transmissionTimer = null;
let countdownTimer = null;
let countdownSeconds = 10;
let wakeLock = null;
let debugMode = false;
speedSlider.addEventListener('input', () => {
const fps = speedSlider.value;
speedValue.textContent = `${fps} FPS`;
});
sizeSlider.addEventListener('input', () => {
qrSize = parseInt(sizeSlider.value);
sizeValue.textContent = `${qrSize}px`;
qrDisplay.style.width = `${qrSize}px`;
qrDisplay.style.height = `${qrSize}px`;
});
chunkSlider.addEventListener('input', () => {
const size = chunkSlider.value;
chunkValue.textContent = `${size} chars`;
});
redundancySlider.addEventListener('input', () => {
const redundancy = redundancySlider.value;
redundancyValue.textContent = `${redundancy}%`;
});
countdownSlider.addEventListener('input', () => {
countdownSeconds = parseInt(countdownSlider.value);
countdownValue.textContent = countdownSeconds > 0 ? `${countdownSeconds}s` : 'None';
});
maxDegreeSlider.addEventListener('input', () => {
const maxDegree = maxDegreeSlider.value;
maxDegreeValue.textContent = maxDegree;
});
showGuidesCheckbox.addEventListener('change', () => {
if (showGuidesCheckbox.checked) {
qrDisplay.classList.add('show-guides');
} else {
qrDisplay.classList.remove('show-guides');
}
});
highDensityCheckbox.addEventListener('change', () => {
if (highDensityCheckbox.checked) {
MAX_QR_CONTENT_SIZE = HIGH_DENSITY_QR_CONTENT_SIZE;
document.querySelectorAll('.high-density-indicator').forEach(el => {
el.style.display = 'block';
});
} else {
MAX_QR_CONTENT_SIZE = DEFAULT_QR_CONTENT_SIZE;
document.querySelectorAll('.high-density-indicator').forEach(el => {
el.style.display = 'none';
});
}
if (chunks && chunks.length > 0) {
generateBtn.disabled = false;
}
});
fastPreset.addEventListener('click', () => {
applyPreset('fast');
});
reliablePreset.addEventListener('click', () => {
applyPreset('reliable');
});
mobilePreset.addEventListener('click', () => {
applyPreset('mobile');
});
function applyPreset(type) {
fastPreset.classList.remove('active');
reliablePreset.classList.remove('active');
mobilePreset.classList.remove('active');
switch (type) {
case 'fast':
fastPreset.classList.add('active');
speedSlider.value = 12;
chunkSlider.value = 600;
redundancySlider.value = 50;
maxDegreeSlider.value = 2;
errorCorrectionSelect.value = 'M';
enableTransitionsCheckbox.checked = true;
break;
case 'reliable':
reliablePreset.classList.add('active');
speedSlider.value = 6;
chunkSlider.value = 450;
redundancySlider.value = 100;
maxDegreeSlider.value = 2;
errorCorrectionSelect.value = 'H';
sizeSlider.value = 800;
qrSize = 800;
qrDisplay.style.width = `${qrSize}px`;
qrDisplay.style.height = `${qrSize}px`;
sizeValue.textContent = `${qrSize}px`;
enableTransitionsCheckbox.checked = true;
break;
case 'mobile':
mobilePreset.classList.add('active');
speedSlider.value = 8;
chunkSlider.value = 400;
redundancySlider.value = 100;
maxDegreeSlider.value = 1;
errorCorrectionSelect.value = 'H';
sizeSlider.value = 600;
qrSize = 600;
qrDisplay.style.width = `${qrSize}px`;
qrDisplay.style.height = `${qrSize}px`;
sizeValue.textContent = `${qrSize}px`;
enableTransitionsCheckbox.checked = true;
break;
}
speedValue.textContent = `${speedSlider.value} FPS`;
chunkValue.textContent = `${chunkSlider.value} chars`;
redundancyValue.textContent = `${redundancySlider.value}%`;
maxDegreeValue.textContent = maxDegreeSlider.value;
}
let fileList = [];
let currentProcessingIndex = 0;
fileInput.addEventListener('change', () => {
if (fileInput.files.length > 0) {
fileList = [];
Array.from(fileInput.files).forEach((file, index) => {
fileList.push({
id: Date.now() + index,
file: file,
name: file.name,
size: file.size,
selected: true,
status: 'pending'
});
});
updateFileListDisplay();
updateFileLabel();
generateBtn.disabled = false;
generateAndStartBtn.disabled = false;
if (displayInterval) {
clearInterval(displayInterval);
displayInterval = null;
}
isPlaying = false;
startBtn.disabled = true;
stopBtn.disabled = true;
fullscreenBtn.disabled = true;
applyOptimalSettings();
}
});
function calculateOptimalSettings(fileSize) {
return {
fps: 6,
chunkSize: 450,
redundancy: 100,
distance: "25-30cm",
preset: "reliable"
};
}
function updateFileLabel() {
const selectedCount = fileList.filter(f => f.selected).length;
const totalCount = fileList.length;
if (totalCount === 0) {
fileLabel.textContent = 'Choose files';
} else if (totalCount === 1) {
fileLabel.textContent = fileList[0].name;
} else {
fileLabel.textContent = `${selectedCount}/${totalCount} files selected`;
}
}
function updateFileListDisplay() {
const container = document.getElementById('fileListContainer');
const listElement = document.getElementById('fileList');
if (fileList.length === 0) {
container.style.display = 'none';
return;
}
container.style.display = 'block';
listElement.innerHTML = '';
fileList.forEach((fileItem, index) => {
const itemElement = document.createElement('div');
itemElement.className = 'file-item';
itemElement.innerHTML = `
<input type="checkbox" class="file-checkbox" id="file-${fileItem.id}"
${fileItem.selected ? 'checked' : ''}
onchange="toggleFileSelection(${fileItem.id})"><div class="file-info"><div class="file-name">${fileItem.name}</div><div class="file-size">${formatFileSize(fileItem.size)}</div></div><div class="file-status status-${fileItem.status}">${fileItem.status}</div>
`;
listElement.appendChild(itemElement);
});
}
function toggleFileSelection(fileId) {
const fileItem = fileList.find(f => f.id === fileId);
if (fileItem) {
fileItem.selected = !fileItem.selected;
updateFileLabel();
}
}
function updateFileStatus(fileId, status) {
const fileItem = fileList.find(f => f.id === fileId);
if (fileItem) {
fileItem.status = status;
updateFileListDisplay();
}
}
function formatFileSize(bytes) {
if (bytes === 0) return '0 Bytes';
const k = 1024;
const sizes = ['Bytes', 'KB', 'MB', 'GB'];
const i = Math.floor(Math.log(bytes) / Math.log(k));
return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
document.getElementById('selectAllBtn').addEventListener('click', () => {
fileList.forEach(f => f.selected = true);
updateFileListDisplay();
updateFileLabel();
});
document.getElementById('clearAllBtn').addEventListener('click', () => {
fileList.forEach(f => f.selected = false);
updateFileListDisplay();
updateFileLabel();
});
async function processBatchFiles(selectedFiles, autoStart = false) {
currentProcessingIndex = 0;
for (let i = 0; i < selectedFiles.length; i++) {
const fileItem = selectedFiles[i];
currentProcessingIndex = i;
try {
updateFileStatus(fileItem.id, 'inprogress');
fileNameText = fileItem.name;
fileSizeBytes = fileItem.size;
await generateQRCodesForFile(fileItem.file);
if (autoStart) {
if (fullscreenCheckbox.checked) {
enterFullscreenMode();
await startPlayingAndWait();
} else {
await startPlayingAndWait();
}
}
updateFileStatus(fileItem.id, 'sent');
fileItem.selected = false;
updateFileListDisplay();
updateFileLabel();
} catch (error) {
console.error(`Error processing file ${fileItem.name}:`, error);
updateFileStatus(fileItem.id, 'error');
}
}
}
async function generateQRCodesForFile(file) {
return new Promise((resolve, reject) => {
const fileReader = new FileReader();
fileReader.onload = async () => {
try {
fileName.textContent = file.name;
const arrayBuffer = fileReader.result;
const encoder = new QRFileEncoder(
new Uint8Array(arrayBuffer),
file.name,
file.type,
{
chunkSize: parseInt(chunkSlider.value),
redundancyPercent: parseInt(redundancySlider.value),
fps: parseInt(speedSlider.value),
maxDegree: parseInt(maxDegreeSlider.value),
qrSize: parseInt(sizeSlider.value)
}
);
allPackets = encoder.encode();
totalPackets = allPackets.length;
updatePacketInfo();
showMetadata();
resolve();
} catch (error) {
reject(error);
}
};
fileReader.onerror = reject;
fileReader.readAsArrayBuffer(file);
});
}
async function startPlayingAndWait() {
return new Promise((resolve) => {
startPlaying();
const checkCompletion = setInterval(() => {
if (!displayInterval) {
clearInterval(checkCompletion);
resolve();
}
}, 1000);
});
}
function applyOptimalSettings() {
if (!fileInput.files.length) return;
const optimal = calculateOptimalSettings(fileSizeBytes);
speedSlider.value = optimal.fps;
speedValue.textContent = `${optimal.fps} FPS`;
chunkSlider.value = optimal.chunkSize;
chunkValue.textContent = `${optimal.chunkSize} chars`;
redundancySlider.value = optimal.redundancy;
redundancyValue.textContent = `${optimal.redundancy}%`;
optimalDistance.textContent = optimal.distance;
applyPreset(optimal.preset);
}
generateAndStartBtn.addEventListener('click', async () => {
const selectedFiles = fileList.filter(f => f.selected);
if (selectedFiles.length === 0) return;
generateAndStartBtn.disabled = true;
generateAndStartBtn.textContent = 'Generating...';
try {
await generateQRCodes();
if (fullscreenCheckbox.checked) {
enterFullscreenMode();
startPlaying();
} else {
startPlaying();
}
} catch (error) {
alert('Error: ' + error.message);
} finally {
generateAndStartBtn.textContent = 'Generate & Start Display';
generateAndStartBtn.disabled = false;
}
});
generateBtn.addEventListener('click', async () => {
if (!fileInput.files.length) return;
generateBtn.disabled = true;
generateBtn.textContent = 'Generating...';
try {
await generateQRCodes();
startBtn.disabled = false;
fullscreenBtn.disabled = false;
} catch (error) {
alert('Error generating QR codes: ' + error.message);
} finally {
generateBtn.textContent = 'Generate QR Codes';
generateBtn.disabled = false;
}
});
async function generateQRCodes() {
if (!fileInput.files.length) return;
const file = fileInput.files[0];
const chunkSize = parseInt(chunkSlider.value);
const redundancyPercent = parseInt(redundancySlider.value);
const fileData = await readFileAsBinary(file);
fileContent = fileData;
chunks = chunkFileBinary(fileContent, chunkSize);
if (debugMode) {
console.log(`🔍 ENCODER DEBUG - File reading:`);
console.log(` File size: ${fileData.length} bytes`);
console.log(` File type: ${fileData.constructor.name}`);
console.log(` File first 4 bytes: [${Array.from(fileData.slice(0, 4)).join(', ')}]`);
console.log(` Chunk size: ${chunkSize} bytes`);
console.log(` Created ${chunks.length} chunks`);
console.log(` First chunk: ${chunks[0].length} bytes, type: ${chunks[0].constructor.name}`);
console.log(` First chunk first 4 bytes: [${Array.from(chunks[0].slice(0, 4)).join(', ')}]`);
console.log(` Last chunk: ${chunks[chunks.length-1].length} bytes`);
}
const ltEncoder = new SystematicLTEncoder(chunks);
ltEncoder.maxSafeDegree = parseInt(maxDegreeSlider.value);
fountainPackets = [ltEncoder.generateMetadataPacket()];
const totalPackets = ltEncoder.calculateTotalPackets();
for (let i = 1; i < totalPackets; i++) {
fountainPackets.push(ltEncoder.generatePacket());
}
if (chunks.length > 0) {
const redundantChunk0 = ltEncoder.createSystematicPacket(0);
redundantChunk0.p = ltEncoder.packetCounter;
fountainPackets.push(redundantChunk0);
}
const generatedLTPackets = fountainPackets.filter(p => p.systematic === false && p.metaString === undefined).length;
const systematicPhasePackets = fountainPackets.filter(p => p.systematic === true).length;
const targetLTPackets = Math.ceil(chunks.length * (redundancyPercent / 100));
if (generatedLTPackets < targetLTPackets) {
const additionalPacketsNeeded = targetLTPackets - generatedLTPackets;
for (let i = 0; i < additionalPacketsNeeded; i++) {
ltEncoder.systematicPhase = false;
fountainPackets.push(ltEncoder.createLTPacket());
}
}
totalFrames = fountainPackets.length;
frameCounter.textContent = `Frame: 0 / ${totalFrames}`;
fileName.textContent = fileNameText;
fileSize.textContent = formatFileSize(fileSizeBytes);
chunksCount.textContent = chunks.length;
packetsCount.textContent = fountainPackets.length;
redundancyLevel.textContent = `${redundancyPercent}% (${Math.round((fountainPackets.length / chunks.length - 1) * 100)}% effective)`;
transferTime.textContent = `~${Math.ceil(totalFrames / parseInt(speedSlider.value))} seconds`;
optimalDistance.textContent = calculateOptimalSettings(fileSizeBytes).distance;
const systematicCount = systematicPhasePackets;
const fountainCount = generatedLTPackets + (fountainPackets.length - systematicCount - generatedLTPackets - 1);
if (!document.getElementById('phaseInfo')) {
const phaseInfo = document.createElement('div');
phaseInfo.id = 'phaseInfo';
phaseInfo.className = 'info-row';
phaseInfo.innerHTML = `
<div class="info-label">Encoding Phases:</div><div id="phaseDetails"><div>Systematic: ${systematicCount} packets</div><div>Fountain: ${fountainCount} packets</div></div>
`;
document.getElementById('fileInfo').appendChild(phaseInfo);
} else {
document.getElementById('phaseDetails').innerHTML = `
<div>Systematic: ${systematicCount} packets</div><div>Fountain: ${fountainCount} packets</div>
`;
}
if (!document.getElementById('ltParams') && fountainPackets.length > 0) {
const ltParams = document.createElement('div');
ltParams.id = 'ltParams';
ltParams.className = 'info-row';
ltParams.innerHTML = `
<div class="info-label">LT Parameters:</div><div id="ltDetails"><div>c: ${ltEncoder.c.toFixed(2)}</div><div>δ: ${ltEncoder.delta.toFixed(2)}</div></div>
`;
document.getElementById('fileInfo').appendChild(ltParams);
}
fileInfo.style.display = 'block';
if (fountainPackets.length > 0) {
await generateQRCodeForFrame(0);
currentFrame = 0;
}
return true;
}
startBtn.addEventListener('click', () => {
if (fountainPackets.length === 0) return;
if (countdownSeconds > 0) {
startCountdown();
} else {
startPlaying();
}
});
function startCountdown() {
let countdown = countdownSeconds;
countdownDisplay.textContent = countdown;
countdownDisplay.style.display = 'block';
fsCountdownDisplay.textContent = countdown;
fsCountdownDisplay.style.display = isFullscreen ? 'block' : 'none';
if (qrDisplay.querySelector('.countdown-display') === null) {
qrDisplay.appendChild(countdownDisplay);
}
startBtn.disabled = true;
countdownTimer = setInterval(() => {
countdown--;
if (countdown <= 0) {
clearInterval(countdownTimer);
countdownDisplay.style.display = 'none';
fsCountdownDisplay.style.display = 'none';
startPlaying();
} else {
countdownDisplay.textContent = countdown;
fsCountdownDisplay.textContent = countdown;
}
}, 1000);
}
async function requestWakeLock() {
try {
if ('wakeLock' in navigator) {
wakeLock = await navigator.wakeLock.request('screen');
console.log('Screen wake lock activated');
wakeLock.addEventListener('release', () => {
console.log('Screen wake lock released');
});
}
} catch (err) {
console.log('Wake lock failed:', err.message);
}
}
function releaseWakeLock() {
if (wakeLock) {
wakeLock.release();
wakeLock = null;
console.log('Screen wake lock released manually');
}
}
function startPlaying() {
isPlaying = true;
startBtn.disabled = true;
stopBtn.disabled = false;
currentFrame = 0;
requestWakeLock();
startTime = Date.now();
metadataInfo.style.display = 'block';
transmissionTimer = setInterval(updateTransmissionStats, 1000);
const interval = 1000 / parseInt(speedSlider.value);
displayInterval = setInterval(async () => {
currentFrame = (currentFrame + 1) % totalFrames;
await generateQRCodeForFrame(currentFrame);
updateProgress();
if (enableTransitionsCheckbox.checked) {
const regularQRImage = qrDisplay.querySelector('img');
if (regularQRImage) {
regularQRImage.classList.add('qr-image');
}
if (isFullscreen && fullscreenQR) {
fullscreenQR.classList.add('qr-image');
}
}
}, interval);
}
stopBtn.addEventListener('click', () => {
stopPlaying();
});
function stopPlaying() {
if (countdownTimer) {
clearInterval(countdownTimer);
countdownTimer = null;
countdownDisplay.style.display = 'none';
if (isFullscreen) {
fsCountdownDisplay.style.display = 'none';
}
}
if (displayInterval) {
clearInterval(displayInterval);
displayInterval = null;
}
if (transmissionTimer) {
clearInterval(transmissionTimer);
transmissionTimer = null;
}
releaseWakeLock();
isPlaying = false;
startBtn.disabled = false;
stopBtn.disabled = true;
}
fullscreenBtn.addEventListener('click', () => {
enterFullscreenMode();
if (countdownSeconds > 0) {
startCountdown();
} else {
startPlaying();
}
});
function enterFullscreenMode() {
isFullscreen = true;
fullscreenDisplay.style.display = 'flex';
if (isPlaying) {
stopPlaying();
}
setTimeout(() => {
if (currentFrame >= 0 && fountainPackets.length > 0) {
generateQRCodeForFrame(currentFrame, true);
}
}, 100);
}
exitFullscreenBtn.addEventListener('click', () => {
isFullscreen = false;
fullscreenDisplay.style.display = 'none';
stopPlaying();
});
window.addEventListener('resize', () => {
if (isFullscreen && currentFrame >= 0 && fountainPackets.length > 0) {
setTimeout(() => {
generateQRCodeForFrame(currentFrame, true);
}, 100);
}
});
function updateTransmissionStats() {
if (!isPlaying || !startTime) return;
const elapsed = (Date.now() - startTime) / 1000;
const elapsedFormatted = formatTime(elapsed);
elapsedTime.textContent = elapsedFormatted;
const totalBytes = fileSizeBytes;
const progress = Math.min(currentFrame / totalFrames, 1);
const bytesTransferred = totalBytes * progress;
const bytesPerSecond = bytesTransferred / elapsed;
transmissionSpeed.textContent = `${formatFileSize(bytesPerSecond)}/s`;
}
function formatTime(seconds) {
const mins = Math.floor(seconds / 60);
const secs = Math.floor(seconds % 60);
return `${mins}:${secs.toString().padStart(2, '0')}`;
}
function calculateFullscreenQRSize() {
const viewportWidth = window.innerWidth;
const viewportHeight = window.innerHeight;
const topReserved = 80;
const bottomReserved = 100;
const sideMargin = 40;
const availableWidth = viewportWidth - (sideMargin * 2);
const availableHeight = viewportHeight - topReserved - bottomReserved;
const maxSize = Math.min(availableWidth, availableHeight);
return Math.floor(maxSize * 0.9);
}
async function generateQRCodeForFrame(frameIndex, forFullscreen = false) {
try {
if (!fountainPackets[frameIndex]) return;
const packet = fountainPackets[frameIndex];
let packetData;
if (frameIndex === 0 && packet.metaString) {
packetData = packet.metaString;
} else if (packet.dataString) {
packetData = packet.dataString;
}
const options = {
errorCorrectionLevel: errorCorrectionSelect.value,
margin: 1,
width: forFullscreen ? calculateFullscreenQRSize() : qrSize,
color: {
dark: '#000000',
light: '#FFFFFF'
}
};
const qrCodeDataUrl = await new Promise((resolve, reject) => {
QRCode.toDataURL(packetData, options, (error, url) => {
if (error) reject(error);
else resolve(url);
});
});
if (forFullscreen || isFullscreen) {
fullscreenQR.src = qrCodeDataUrl;
fullscreenCounter.textContent = `Frame: ${frameIndex + 1} / ${totalFrames}`;
if (enableTransitionsCheckbox.checked) {
fullscreenQR.classList.add('qr-image');
}
if (countdownDisplay.style.display === 'block') {
fsCountdownDisplay.style.display = 'block';
fsCountdownDisplay.textContent = countdownDisplay.textContent;
} else {
fsCountdownDisplay.style.display = 'none';
}
}
qrDisplay.innerHTML = `<img src="${qrCodeDataUrl}" alt="QR Code" style="max-width: 100%; max-height: 100%;">`;
if (enableTransitionsCheckbox.checked) {
const newImage = qrDisplay.querySelector('img');
if (newImage) {
newImage.classList.add('qr-image');
}
}
if (showGuidesCheckbox.checked) {
const alignmentGuide1 = document.createElement('div');
alignmentGuide1.className = 'alignment-guide';
alignmentGuide1.style = 'width: 90%; height: 90%; top: 5%; left: 5%;';
const alignmentGuide2 = document.createElement('div');
alignmentGuide2.className = 'alignment-guide';
alignmentGuide2.style = 'width: 70%; height: 70%; top: 15%; left: 15%;';
const guideLabel = document.createElement('div');
guideLabel.className = 'guide-label';
guideLabel.style = 'top: 2%; left: 50%; transform: translateX(-50%);';
guideLabel.textContent = 'Keep QR code within this area';
qrDisplay.appendChild(alignmentGuide1);
qrDisplay.appendChild(alignmentGuide2);
qrDisplay.appendChild(guideLabel);
if (showGuidesCheckbox.checked) {
qrDisplay.classList.add('show-guides');
}
}
if (countdownDisplay.style.display === 'block') {
qrDisplay.appendChild(countdownDisplay);
}
frameCounter.textContent = `Frame: ${frameIndex + 1} / ${totalFrames}`;
updateFrameMetadata(frameIndex);
const progress = ((frameIndex + 1) / totalFrames) * 100;
progressBar.style.width = `${progress}%`;
fullscreenProgressBar.style.width = `${progress}%`;
} catch (error) {
console.error('Error generating QR code:', error);
}
}
function updateFrameMetadata(frameIndex) {
const packet = fountainPackets[frameIndex];
if (!packet) return;
let frameTypeText;
let packetSizeInfo = '';
if (frameIndex === 0) {
frameTypeText = 'Handshake (Setup Data)';
currentChunkInfo.style.display = 'none';
if (packet.metaString) {
const metaSize = packet.metaString.length;
packetSizeInfo = ` (${metaSize} bytes)`;
}
} else {
const parts = packet.dataString.split(':');
if (parts.length >= 6) {
const packetId = parts[1];
const degree = parts[5];
frameTypeText = `Data Packet (Degree: ${degree})`;
currentChunkInfo.style.display = 'block';
chunkId.textContent = `${packetId} (contains ${degree} chunk${degree > 1 ? 's' : ''})`;
packetSizeInfo = ` (${packet.dataString.length} bytes)`;
}
}
frameType.textContent = frameTypeText + packetSizeInfo;
}
function updateProgress() {
const progress = ((currentFrame + 1) / totalFrames) * 100;
progressBar.style.width = `${progress}%`;
if (isFullscreen) {
fullscreenProgressBar.style.width = `${progress}%`;
}
}
function readFileAsBinary(file) {
return new Promise((resolve, reject) => {
const reader = new FileReader();
reader.onload = () => {
const arrayBuffer = reader.result;
resolve(new Uint8Array(arrayBuffer));
};
reader.onerror = reject;
reader.readAsArrayBuffer(file);
});
}
function chunkFileBinary(data, chunkSize) {
const chunks = [];
for (let i = 0; i < data.length; i += chunkSize) {
const chunk = data.slice(i, i + chunkSize);
chunks.push(chunk);
}
return chunks;
}
function readFileAsBase64(file) {
return new Promise((resolve, reject) => {
const reader = new FileReader();
reader.onload = () => resolve(reader.result);
reader.onerror = reject;
reader.readAsDataURL(file);
});
}
function chunkFile(data, chunkSize) {
const chunks = [];
for (let i = 0; i < data.length; i += chunkSize) {
chunks.push(data.slice(i, i + chunkSize));
}
return chunks;
}
function formatFileSize(bytes) {
if (bytes < 1024) return bytes + ' bytes';
else if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
else return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}
class SystematicLTEncoder {
constructor(originalChunks, seedBase = Date.now()) {
this.originalChunks = originalChunks;
this.numChunks = originalChunks.length;
this.seedBase = seedBase;
this.packetCounter = 0;
this.avgChunkSize = this.calculateAverageChunkSize();
this.systematicPhase = true;
this.currentSystematicIndex = 0;
this.maxSafeDegree = this.calculateMaxSafeDegree();
this.c = 0.03;
this.delta = 0.5;
}
calculateAverageChunkSize() {
let sum = 0;
const sampleSize = Math.min(10, this.numChunks);
for (let i = 0; i < sampleSize; i++) {
sum += this.originalChunks[i].length;
}
return Math.ceil(sum / sampleSize);
}
calculateMaxSafeDegree() {
if (maxDegreeSlider) {
const userMaxDegree = parseInt(maxDegreeSlider.value);
if (!isNaN(userMaxDegree) && userMaxDegree > 0) {
return userMaxDegree;
}
}
const packetOverhead = 150;
const delimiterOverhead = 5;
const safeQrSize = Math.floor(MAX_QR_CONTENT_SIZE * 0.9);
const charsAvailableForData = safeQrSize - packetOverhead;
const maxDegree = Math.floor(charsAvailableForData / (this.avgChunkSize + delimiterOverhead));
const ltRecommendedMax = Math.min(
Math.max(8, Math.ceil(Math.sqrt(this.numChunks))),
this.numChunks
);
return Math.max(1, Math.min(maxDegree, ltRecommendedMax, 20));
}
calculateTotalPackets() {
let systematicPackets;
if (this.maxSafeDegree >= 2) {
systematicPackets = Math.ceil(this.numChunks / 2);
} else {
systematicPackets = this.numChunks;
}
const redundancyPercent = parseInt(document.getElementById('redundancySlider').value);
const redundancyFactor = redundancyPercent / 100;
const additionalPackets = Math.ceil(this.numChunks * redundancyFactor);
const extraPackets = this.maxSafeDegree >= 2 ? Math.ceil(this.numChunks * 0.1) : 0;
return systematicPackets + additionalPackets + extraPackets;
}
generatePacket() {
if (this.systematicPhase) {
const maxQRSize = document.getElementById('highDensityCheckbox').checked ?
HIGH_DENSITY_QR_CONTENT_SIZE : DEFAULT_QR_CONTENT_SIZE;
if (this.maxSafeDegree >= 2 &&
this.currentSystematicIndex < this.numChunks &&
this.numChunks - 1 - this.currentSystematicIndex >= 0) {
const packet = this.createDualSystematicPacket(
this.currentSystematicIndex,
this.numChunks - 1 - this.currentSystematicIndex
);
this.currentSystematicIndex++;
if (this.currentSystematicIndex >= this.numChunks) {
this.systematicPhase = false;
}
return packet;
} else {
const packet = this.createSystematicPacket(this.currentSystematicIndex);
this.currentSystematicIndex++;
if (this.currentSystematicIndex >= this.numChunks) {
this.systematicPhase = false;
}
return packet;
}
}
return this.createLTPacket();
}
createSystematicPacket(chunkIndex) {
const chunkData = this.originalChunks[chunkIndex];
const seed = this.seedBase + this.packetCounter;
const chunkBase64 = this.arrayBufferToBase64(chunkData);
const combinedData = `${chunkIndex}:${chunkBase64}`;
const dataString = `D:${this.packetCounter}:${seed}:${this.seedBase}:${this.numChunks}:1:${combinedData}`;
if (debugMode) {
console.log(`🔍 ENCODER DEBUG - Single systematic packet ${this.packetCounter}:`);
console.log(` Chunk ${chunkIndex}: ${chunkData.length} bytes`);
console.log(` Chunk type: ${chunkData.constructor.name}`);
console.log(` First 4 bytes: [${Array.from(chunkData.slice(0, 4)).join(', ')}]`);
console.log(` Base64 length: ${chunkBase64.length} chars`);
console.log(` Base64 preview: ${chunkBase64.substring(0, 20)}...`);
console.log(` Base64 valid: ${/^[A-Za-z0-9+/]*={0,2}$/.test(chunkBase64)}`);
console.log(` Combined data length: ${combinedData.length} chars`);
console.log(` Combined preview: ${combinedData.substring(0, 30)}...`);
console.log(` Final packet length: ${dataString.length} chars`);
console.log(` Final packet preview: ${dataString.substring(0, 80)}...`);
}
const packet = {
format: "compact",
dataString: dataString,
s: seed,
d: 1,
p: this.packetCounter++,
n: this.numChunks,
b: this.seedBase,
systematic: true
};
this.checkAndHandlePacketSize(packet);
return packet;
}
createDualSystematicPacket(firstChunkIndex, secondChunkIndex) {
const firstChunkData = this.originalChunks[firstChunkIndex];
const secondChunkData = this.originalChunks[secondChunkIndex];
if (debugMode) {
console.log(`🔍 ENCODER DEBUG - Dual systematic packet ${this.packetCounter}:`);
console.log(` Chunk ${firstChunkIndex}: ${firstChunkData.length} bytes, type: ${firstChunkData.constructor.name}`);
console.log(` Chunk ${secondChunkIndex}: ${secondChunkData.length} bytes, type: ${secondChunkData.constructor.name}`);
console.log(` First chunk first 4 bytes: [${Array.from(firstChunkData.slice(0, 4)).join(', ')}]`);
console.log(` Second chunk first 4 bytes: [${Array.from(secondChunkData.slice(0, 4)).join(', ')}]`);
}
const seed = this.seedBase + this.packetCounter;
const firstChunkBase64 = this.arrayBufferToBase64(firstChunkData);
const secondChunkBase64 = this.arrayBufferToBase64(secondChunkData);
const combinedData = `${firstChunkIndex}:${firstChunkBase64}|${secondChunkIndex}:${secondChunkBase64}`;
const dataString = `D:${this.packetCounter}:${seed}:${this.seedBase}:${this.numChunks}:2:${combinedData}`;
if (debugMode) {
console.log(` First base64: ${firstChunkBase64.length} chars, preview: ${firstChunkBase64.substring(0, 20)}...`);
console.log(` First base64 valid: ${/^[A-Za-z0-9+/]*={0,2}$/.test(firstChunkBase64)}`);
console.log(` Second base64: ${secondChunkBase64.length} chars, preview: ${secondChunkBase64.substring(0, 20)}...`);
console.log(` Second base64 valid: ${/^[A-Za-z0-9+/]*={0,2}$/.test(secondChunkBase64)}`);
console.log(` Combined data length: ${combinedData.length} chars`);
console.log(` Combined preview: ${combinedData.substring(0, 50)}...`);
console.log(` Contains invalid chars: ${/[^A-Za-z0-9+/=:|]/.test(combinedData)}`);
console.log(` Final packet length: ${dataString.length} chars`);
console.log(` Final packet preview: ${dataString.substring(0, 100)}...`);
}
const packet = {
format: "compact",
dataString: dataString,
s: seed,
d: 2,
p: this.packetCounter++,
n: this.numChunks,
b: this.seedBase,
systematic: true
};
this.checkAndHandlePacketSize(packet);
return packet;
}
createLTPacket() {
const seed = this.seedBase + this.packetCounter;
const rng = this.createPRNG(seed);
const degree = this.getRobustSolitonDegree(rng);
const selectedIndices = this.selectChunksLT(degree, rng);
const fountainData = this.xorChunks(selectedIndices);
const indicesStr = selectedIndices.join(',');
const base64Data = this.arrayBufferToBase64(fountainData);
const dataString = `D:${this.packetCounter}:${seed}:${this.seedBase}:${this.numChunks}:1:${indicesStr}:${base64Data}`;
const packet = {
format: "enhanced",
dataString: dataString,
s: seed,
d: degree,
p: this.packetCounter++,
n: this.numChunks,
b: this.seedBase,
systematic: false,
sourceIndices: selectedIndices,
fountainData: fountainData
};
this.checkAndHandlePacketSize(packet);
return packet;
}
checkAndHandlePacketSize(packet) {
const maxQRSize = document.getElementById('highDensityCheckbox').checked ?
HIGH_DENSITY_QR_CONTENT_SIZE : DEFAULT_QR_CONTENT_SIZE;
const packetSize = packet.dataString.length;
if (packetSize > maxQRSize * 0.9) {
this.truncatePacket(packet, maxQRSize * 0.9);
}
}
truncatePacket(packet, maxSize) {
const parts = packet.dataString.split(":", 6);
const header = parts.slice(0, 6).join(":");
const headerSize = header.length + 1;
const availableSize = maxSize - headerSize;
const originalData = packet.dataString.substring(headerSize);
const originalLength = originalData.length;
const truncatedData = originalData.substring(0, availableSize);
packet.dataString = `${header}:${truncatedData}`;
packet.truncated = true;
packet.dataString = `${packet.dataString}:t:${originalLength}`;
}
createPRNG(seed) {
let s = seed;
return function() {
s = Math.sin(s) * 10000;
return s - Math.floor(s);
};
}
getRobustSolitonDegree(rng) {
if (this.numChunks <= 1) return 1;
const c = this.c;
const delta = this.delta;
const R = c * Math.log(this.numChunks / delta) * Math.sqrt(this.numChunks);
const maxDegree = Math.min(this.maxSafeDegree, this.numChunks);
const r = rng();
let cdf = 0;
const p1 = (1.0 / this.numChunks) + (R / this.numChunks);
cdf += p1;
if (r < cdf) return 1;
for (let d = 2; d <= maxDegree; d++) {
let p_std = 1.0 / (d * (d - 1));
let p_robust = 0;
if (d <= Math.floor(this.numChunks / R)) {
p_robust = R / (d * this.numChunks);
} else if (d === Math.floor(this.numChunks / R)) {
p_robust = (R * Math.log(R / delta)) / this.numChunks;
}
cdf += p_std + p_robust;
if (r < cdf) return d;
}
return maxDegree;
}
selectChunksLT(degree, rng) {
const indices = [];
const actualDegree = Math.min(degree, this.numChunks);
while (indices.length < actualDegree) {
const index = Math.floor(rng() * this.numChunks);
if (!indices.includes(index)) {
indices.push(index);
}
}
return indices;
}
combineChunks(indices) {
if (indices.length === 0) return "";
const stringFormat = indices.map(index => {
return `${index}:${this.originalChunks[index]}`;
}).join("|");
const fountainData = this.xorChunks(indices);
return stringFormat;
}
xorChunks(indices) {
if (indices.length === 0) return new Uint8Array(0);
const firstChunk = this.ensureUint8Array(this.originalChunks[indices[0]]);
if (indices.length === 1) return firstChunk;
let maxLength = firstChunk.length;
for (let i = 1; i < indices.length; i++) {
const chunkData = this.ensureUint8Array(this.originalChunks[indices[i]]);
maxLength = Math.max(maxLength, chunkData.length);
}
const result = new Uint8Array(maxLength);
result.set(firstChunk);
for (let i = 1; i < indices.length; i++) {
const chunkIndex = indices[i];
const chunkData = this.ensureUint8Array(this.originalChunks[chunkIndex]);
for (let j = 0; j < Math.min(result.length, chunkData.length); j++) {
result[j] ^= chunkData[j];
}
}
return result;
}
stringToUint8Array(str) {
const arr = new Uint8Array(str.length);
for (let i = 0; i < str.length; i++) {
arr[i] = str.charCodeAt(i);
}
return arr;
}
ensureUint8Array(data) {
if (data instanceof Uint8Array) {
return data;
}
if (typeof data === 'string') {
return this.stringToUint8Array(data);
}
return new Uint8Array(data);
}
arrayBufferToBase64(buffer) {
let binary = '';
const bytes = new Uint8Array(buffer);
for (let i = 0; i < bytes.length; i++) {
binary += String.fromCharCode(bytes[i]);
}
return btoa(binary);
}
generateMetadataPacket() {
const fileNameText = document.getElementById('fileName').textContent;
const fileSizeBytes = fileInput.files[0].size;
const fileType = fileInput.files[0].type;
const fps = parseInt(document.getElementById('speedSlider').value);
const maxDegree = parseInt(document.getElementById('maxDegreeSlider').value);
const chunkSize = parseInt(document.getElementById('chunkSlider').value);
const redundancy = parseInt(document.getElementById('redundancySlider').value);
const highDensityMode = document.getElementById('highDensityCheckbox').checked ? 1 : 0;
const ecLevel = document.getElementById('errorCorrectionSelect').value;
const fileChecksum = this.calculateFileChecksum(fileContent);
const checksumData = `${fileNameText}:${fileSizeBytes}:${this.numChunks}`;
const metaChecksum = this.simpleChecksum(checksumData);
const ltParams = `${this.c}:${this.delta}`;
const metadataString = `M:3.0:${encodeURIComponent(fileNameText)}:${encodeURIComponent(fileType)}:${fileSizeBytes}:${this.numChunks}:${this.calculateTotalPackets()}:${maxDegree}:${highDensityMode}:${fps}:${chunkSize}:${redundancy}:${ecLevel}:${metaChecksum}:${fileChecksum}:${ltParams}`;
const packet = {
format: "compact",
metaString: metadataString,
s: this.seedBase,
p: this.packetCounter++,
n: this.numChunks,
b: this.seedBase
};
return packet;
}
calculateFileChecksum(binaryData) {
let hash = 0;
for (let i = 0; i < binaryData.length; i++) {
hash = ((hash << 5) - hash) + binaryData[i];
hash = hash & hash;
}
return Math.abs(hash).toString(36).substring(0, 8);
}
simpleChecksum(str) {
let hash = 0;
for (let i = 0; i < str.length; i++) {
hash = ((hash << 5) - hash) + str.charCodeAt(i);
hash = hash & hash;
}
return Math.abs(hash).toString(36).substring(0, 6);
}
}</script></body></html>