<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QR Code File Decoder</title>
  <style>
    /* Base styles */
    :root {
      --primary: #2563eb;
      --secondary: #1d4ed8;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --text: #1f2937;
      --bg: #f9fafb;
      --panel: #ffffff;
      --border: #e5e7eb;
    }

    * {box-sizing: border-box; margin: 0; padding: 0;}

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      line-height: 1.5;
      color: var(--text);
      background-color: var(--bg);
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }

    h1, h2 {margin-bottom: 1rem;}

    button {
      background-color: var(--primary);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: background-color 0.2s;
    }

    button:hover {background-color: var(--secondary);}
    button:disabled {background-color: #9ca3af; cursor: not-allowed;}
    input[type="file"] {margin-right: 10px;}

    /* Panels */
    .control-panel, .video-container, .chunks-container, 
    .file-info-container, .debug-container {
      background-color: var(--panel);
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }

    .control-panel {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .controls {display: flex; gap: 10px;}

    /* Video elements */
    .video-container {position: relative;}

    video {
      width: 100%;
      max-height: 400px;
      background-color: #000;
      border-radius: 4px;
    }

    canvas {
      position: absolute;
      top: 15px;
      left: 15px;
      pointer-events: none;
    }

    .progress-container {margin-top: 10px;}

    .progress-bar {
      height: 10px;
      background-color: var(--primary);
      width: 0%;
      border-radius: 5px;
      transition: width 0.3s ease;
    }

    .progress-text {
      font-size: 14px;
      margin-top: 5px;
      text-align: right;
    }

    /* Chunks visualization */
    .chunks-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(20px, 1fr));
      gap: 4px;
      margin-top: 10px;
    }

    .chunk {
      height: 20px;
      background-color: rgba(229, 231, 235, 0.5);
      border: 1px solid var(--border);
      border-radius: 2px;
      transition: background-color 0.3s;
    }

    .chunk.pending {background-color: rgba(229, 231, 235, 0.5);}

    .chunk.received {
      background-color: rgba(16, 185, 129, 0.2);
      border-color: var(--success);
    }

    .chunk.blinking {animation: blink 0.5s;}

    @keyframes blink {
      0% {background-color: rgba(245, 158, 11, 0.5);}
      100% {background-color: rgba(16, 185, 129, 0.2);}
    }

    /* Download button */
    #downloadContainer {margin-top: 15px;}
    #downloadBtn {background-color: var(--success);}
    #downloadBtn:hover {background-color: #0d9668;}

    /* Debug log */
    .log-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }

    .log-filter {
      background-color: #e5e7eb;
      color: var(--text);
      font-size: 12px;
      padding: 4px 8px;
    }

    .log-filter.active {
      background-color: var(--primary);
      color: white;
    }

    .log-window {
      height: 200px;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 10px;
      font-family: monospace;
      font-size: 13px;
      background-color: #f1f5f9;
    }

    .log-entry {
      margin-bottom: 4px;
      border-bottom: 1px solid rgba(229, 231, 235, 0.5);
      padding-bottom: 4px;
    }

    .log-debug {color: #6b7280;}
    .log-info {color: #1d4ed8;}
    .log-warn {color: #b45309;}
    .log-error {color: #b91c1c;}

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
    }

    .modal-content {
      background-color: var(--panel);
      margin: 10% auto;
      padding: 20px;
      border-radius: 8px;
      max-width: 500px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      position: relative;
    }

    .close {
      position: absolute;
      right: 15px;
      top: 10px;
      font-size: 24px;
      cursor: pointer;
    }

    .settings-group {margin-bottom: 15px;}
    .settings-group label {display: block; margin-bottom: 5px;}

    .settings-group input {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--border);
      border-radius: 4px;
    }

    #saveSettingsBtn {margin-top: 10px;}

    /* Error message */
    .error-message {
      background-color: #fef2f2;
      border-left: 4px solid var(--error);
      padding: 15px;
      margin-bottom: 20px;
      color: #b91c1c;
      display: none;
    }

    /* Button styling */
    #resetBtn {background-color: var(--warning);}
    #resetBtn:hover {background-color: #e08c00;}

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .control-panel {
        flex-direction: column;
        align-items: flex-start;
      }

      .controls {
        margin-top: 10px;
        width: 100%;
        flex-wrap: wrap;
      }

      video {max-height: 300px;}
      
      .chunks-grid {grid-template-columns: repeat(auto-fill, minmax(15px, 1fr));}
      .chunk {height: 15px;}
    }
  </style>
</head>

<body>
  <!-- Error message container -->
  <div id="errorMessage" class="error-message"></div>

  <!-- 1. Header with controls -->
  <header class="control-panel">
    <h1>QR Code File Decoder</h1>
    <div class="controls">
      <input type="file" id="videoInput" accept="video/*">
      <button id="startScanBtn" disabled>Start Scan</button>
      <button id="stopScanBtn" disabled>Stop Scan</button>
      <button id="resetBtn">Reset Contents</button>
      <button id="settingsBtn">Settings</button>
    </div>
  </header>

  <!-- 2. Video playback and overlay -->
  <div class="video-container">
    <video id="videoPreview" controls></video>
    <canvas id="overlayCanvas"></canvas>
    <div class="progress-container">
      <div class="progress-bar" id="scanProgressBar"></div>
      <div class="progress-text" id="scanProgressText">Frames: 0/0 | Time Remaining: --:--</div>
    </div>
  </div>

  <!-- 3. Chunk progress visualization -->
  <div class="chunks-container">
    <h2>Chunk Recovery Progress</h2>
    <div class="chunks-grid" id="chunksGrid"></div>
  </div>

  <!-- 4. File information -->
  <div class="file-info-container">
    <h2>File Information</h2>
    <div id="fileInfo">No file detected yet</div>
    <div id="missingChunks">Waiting for metadata...</div>
    <div id="downloadContainer" style="display: none;">
      <button id="downloadBtn">Download Recovered File</button>
    </div>
  </div>

  <!-- 5. Debug log window -->
  <div class="debug-container">
    <h2>Debug Log</h2>
    <div class="log-controls">
      <button class="log-filter active" data-level="all">All</button>
      <button class="log-filter" data-level="debug">Debug</button>
      <button class="log-filter" data-level="info">Info</button>
      <button class="log-filter" data-level="warn">Warnings</button>
      <button class="log-filter" data-level="error">Errors</button>
      <button id="clearLogBtn">Clear Log</button>
    </div>
    <div class="log-window" id="logWindow"></div>
  </div>

  <!-- Settings modal -->
  <div id="settingsModal" class="modal">
    <div class="modal-content">
      <span class="close">&times;</span>
      <h2>Settings</h2>
      <div class="settings-group">
        <label for="frameInterval">Frame Processing Interval (ms):</label>
        <input type="number" id="frameInterval" min="0" max="1000" value="20">
      </div>
      <div class="settings-group">
        <label for="qrDetectionConfidence">QR Detection Confidence (0-1):</label>
        <input type="number" id="qrDetectionConfidence" min="0" max="1" step="0.1" value="0.5">
      </div>
      <button id="saveSettingsBtn">Save Settings</button>
    </div>
  </div>

  <!-- Html5QRCode library -->
  <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>

  <!-- Main script -->
  <script>
    // Optimized Logger implementation
    class Logger {
      constructor(logElementId) {
        this.logElement = document.getElementById(logElementId);
        this.filter = 'all';
        this.maxEntries = 200;
        this.entries = [];
      }

      // Shorthand methods
      debug(message) { this.log('debug', message); }
      info(message) { this.log('info', message); }
      warn(message) { this.log('warn', message); }
      error(message) { this.log('error', message); }

      log(level, message) {
        // Create entry object with timestamp and level
        const entry = {
          timestamp: new Date(),
          level,
          message
        };

        // Add to entries array and trim if needed
        this.entries.push(entry);
        if (this.entries.length > this.maxEntries) {
          this.entries.shift();
        }

        // Create log entry element
        const entryElement = document.createElement('div');
        entryElement.className = `log-entry log-${level}`;
        
        const timestamp = entry.timestamp.toLocaleTimeString();
        entryElement.innerHTML = `[${timestamp}] [${level.toUpperCase()}] ${message}`;

        // Apply filter and add to log window
        if (this.filter !== 'all' && this.filter !== level) {
          entryElement.style.display = 'none';
        }
        
        this.logElement.appendChild(entryElement);
        this.logElement.scrollTop = this.logElement.scrollHeight;
      }

      clear() {
        this.logElement.innerHTML = '';
        this.entries = [];
      }

      setFilter(filter) {
        this.filter = filter;
        
        // Apply filter to existing entries
        const entries = this.logElement.querySelectorAll('.log-entry');
        entries.forEach(entry => {
          if (filter === 'all') {
            entry.style.display = '';
          } else {
            const entryLevel = entry.className.match(/log-(debug|info|warn|error)/)[1];
            entry.style.display = entryLevel === filter ? '' : 'none';
          }
        });
      }
    }

    // Optimized UI management class
    class UI {
      constructor(logger) {
        this.logger = logger;
        this.overlayCanvas = document.getElementById('overlayCanvas');
        this.overlayCtx = this.overlayCanvas.getContext('2d');
        
        // Cache DOM elements
        this.elements = {
          chunksGrid: document.getElementById('chunksGrid'),
          progressBar: document.getElementById('scanProgressBar'),
          progressText: document.getElementById('scanProgressText'),
          fileInfo: document.getElementById('fileInfo'),
          downloadContainer: document.getElementById('downloadContainer'),
          errorMessage: document.getElementById('errorMessage'),
          settingsModal: document.getElementById('settingsModal'),
          video: document.getElementById('videoPreview')
        };
      }

      // Reset and initialize functions
      resetChunkGrid() {
        this.elements.chunksGrid.innerHTML = '';
        this.elements.progressBar.style.width = '0%';
        this.elements.progressText.textContent = 'Frames: 0/0 | Time Remaining: --:--';
        this.elements.downloadContainer.style.display = 'none';
      }

      initializeChunkGrid(chunksCount) {
        this.elements.chunksGrid.innerHTML = '';
        
        // Create chunk elements efficiently
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < chunksCount; i++) {
          const chunkElement = document.createElement('div');
          chunkElement.className = 'chunk pending';
          chunkElement.dataset.index = i;
          fragment.appendChild(chunkElement);
        }
        this.elements.chunksGrid.appendChild(fragment);
      }

      // Progress tracking functions
      updateProgress(progress, currentFrame, totalFrames, remainingTime) {
        this.elements.progressBar.style.width = `${progress * 100}%`;
        
        const remainingMinutes = Math.floor(remainingTime / 60);
        const remainingSeconds = Math.floor(remainingTime % 60);
        const timeString = `${remainingMinutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        
        this.elements.progressText.textContent = 
          `Frames: ${currentFrame}/${totalFrames} | Time Remaining: ${timeString}`;
      }

      // Chunk management functions
      blinkChunk(chunkIndex) {
        const chunkElement = document.querySelector(`.chunk[data-index="${chunkIndex}"]`);
        if (chunkElement) {
          chunkElement.classList.remove('blinking');
          // Force reflow
          void chunkElement.offsetWidth;
          chunkElement.classList.add('blinking');
        }
      }

      markChunkAsRecovered(chunkIndex) {
        const chunkElement = document.querySelector(`.chunk[data-index="${chunkIndex}"]`);
        if (chunkElement) {
          chunkElement.classList.replace('pending', 'received');
        }
      }

      // UI content update functions
      updateFileInfo(htmlContent) {
        this.elements.fileInfo.innerHTML = htmlContent;
      }
      
      // Modal management
      showSettingsModal() {
        this.elements.settingsModal.style.display = 'block';
      }

      hideSettingsModal() {
        this.elements.settingsModal.style.display = 'none';
      }

      // Error handling
      showErrorMessage(message) {
        this.elements.errorMessage.textContent = message;
        this.elements.errorMessage.style.display = 'block';
      }

      hideErrorMessage() {
        this.elements.errorMessage.style.display = 'none';
      }

      // Log filter UI update
      updateLogFilterButtons(activeButton) {
        document.querySelectorAll('.log-filter').forEach(btn => {
          btn.classList.remove('active');
        });
        activeButton.classList.add('active');
      }

      // QR highlighting
      drawQRHighlight(x, y, width, height, padding = 10) {
        const video = this.elements.video;
        
        // Resize canvas to match video dimensions
        if (this.overlayCanvas.width !== video.clientWidth ||
            this.overlayCanvas.height !== video.clientHeight) {
          this.overlayCanvas.width = video.clientWidth;
          this.overlayCanvas.height = video.clientHeight;
        }

        // Clear previous drawings
        this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);

        // Calculate scale factors and adjusted coordinates
        const scaleX = video.clientWidth / video.videoWidth;
        const scaleY = video.clientHeight / video.videoHeight;
        const verticalOffset = 30;
        
        // Scale coordinates
        const scaledX = (x - padding) * scaleX;
        const scaledY = (y - padding - verticalOffset) * scaleY;
        const scaledSize = Math.max((width + padding * 2) * scaleX, (height + padding * 2) * scaleY);
        
        // Draw rectangle
        this.overlayCtx.strokeStyle = '#10b981';
        this.overlayCtx.lineWidth = 3;
        this.overlayCtx.strokeRect(scaledX, 0, scaledSize, scaledSize);
        
        // Draw corner markers
        this.overlayCtx.fillStyle = '#10b981';
        const markerSize = 15;
        const halfMarker = markerSize / 2;
        
        // Draw markers at corners
        const corners = [
          [scaledX - halfMarker, scaledY - halfMarker],
          [scaledX + scaledSize - halfMarker, scaledY - halfMarker],
          [scaledX - halfMarker, scaledY + scaledSize - halfMarker],
          [scaledX + scaledSize - halfMarker, scaledY + scaledSize - halfMarker]
        ];
        
        for (const [x, y] of corners) {
          this.overlayCtx.fillRect(x, y, markerSize, markerSize);
        }
      }

      clearQRHighlight() {
        if (this.overlayCtx) {
          this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
        }
      }
    }

    // Optimized PacketProcessor
    class PacketProcessor {
      constructor() {
        // No initialization needed
      }

      processQRData(qrData, frameIndex) {
        try {
          // Detect packet type based on prefix
          if (qrData.startsWith('M:')) {
            return this.processMetadataPacket(qrData, frameIndex);
          } else if (qrData.startsWith('D:')) {
            return this.processDataPacket(qrData, frameIndex);
          } else {
            throw new Error(`Unknown packet format: ${qrData.substring(0, 10)}...`);
          }
        } catch (error) {
          return {
            success: false,
            error: error.message,
            frameIndex
          };
        }
      }

      processMetadataPacket(metaString, frameIndex) {
        const parts = metaString.split(':');
        
        if (parts.length < 10) {
          throw new Error(`Invalid metadata packet format: ${metaString.substring(0, 30)}...`);
        }

        // Parse file size with error handling
        let fileSize = -1;
        try {
          fileSize = parseInt(parts[4]);
        } catch (e) {
          console.error(`Invalid file size: ${parts[4]}`);
        }

        // Create metadata object with parsed values
        const metadata = {
          protocolVersion: parts[1],
          fileName: this.decodeURIComponentSafe(parts[2]),
          fileType: this.decodeURIComponentSafe(parts[3]),
          fileSize: fileSize,
          chunksCount: parseInt(parts[5]),
          packetCount: parseInt(parts[6]),
          maxDegree: parseInt(parts[7]),
          density: parseFloat(parts[8]),
          fps: parts[9],
          chunkSize: parseInt(parts[10] || '1024'),
          redundancy: parseInt(parts[11] || '0'),
          ecl: parts[12] || 'L',
          checksum: parts[13] || '',
          ltParams: parts.slice(14).join(':')
        };

        // Validate critical metadata fields
        if (isNaN(metadata.chunksCount) || metadata.chunksCount <= 0) {
          throw new Error(`Invalid chunk count: ${parts[5]}`);
        }

        return {
          success: true,
          packetType: 'metadata',
          packetData: metadata,
          frameIndex
        };
      }

      processDataPacket(dataString, frameIndex) {
        const parts = dataString.split(':');
        
        if (parts.length < 7) {
          throw new Error(`Invalid data packet format: ${dataString.substring(0, 30)}...`);
        }

        // Extract packet parameters
        const packetId = parseInt(parts[1]);
        const seed = parseInt(parts[2]);
        const seedBase = parseInt(parts[3]);
        const numChunks = parseInt(parts[4]);
        const degree = parseInt(parts[5]);
        const allDataPart = parts.slice(6).join(':');

        // Initialize data structures
        let sourceChunks = [];
        let systematicDataChunks = [];
        let fountainData = null;

        // Process based on degree (packet type)
        if (degree === 1) {
          // Systematic packet - parse individual chunks
          const chunksData = allDataPart.split('|');
          
          for (let i = 0; i < chunksData.length; i++) {
            const chunkParts = chunksData[i].split(':', 2);
            if (chunkParts.length === 2) {
              const chunkIndex = parseInt(chunkParts[0]);
              const chunkData = chunkParts[1];
              
              if (chunkIndex >= 0 && chunkIndex < numChunks) {
                sourceChunks.push(chunkIndex);
                systematicDataChunks.push({ chunkIndex, chunkData });
              }
            }
          }
        } else {
          // Fountain packet - generate source chunks from seed
          const rng = this.createPRNG(seed);
          sourceChunks = this.selectChunksLT(rng, degree, numChunks);
          fountainData = this.stringToUint8Array(allDataPart);
        }

        // Check for truncated data
        let isTruncated = false;
        let originalLength = 0;
        
        const truncatedIndex = allDataPart.indexOf(':t:');
        if (truncatedIndex > 0) {
          isTruncated = true;
          const truncatedParts = allDataPart.substring(truncatedIndex + 3).split(':');
          originalLength = parseInt(truncatedParts[0] || '0');
        }

        return {
          success: true,
          packetType: 'data',
          packetData: {
            packetId,
            seed,
            seedBase,
            degree,
            fountainData,
            systematicDataChunks,
            sourceChunks,
            isDegreeOne: degree === 1,
            isTruncated,
            originalLength
          },
          frameIndex
        };
      }

      // Helper methods
      decodeURIComponentSafe(str) {
        try {
          return decodeURIComponent(str);
        } catch (e) {
          return str;
        }
      }

      createPRNG(seed) {
        let s = seed;
        return function() {
          s = Math.sin(s) * 10000;
          return s - Math.floor(s);
        };
      }

      selectChunksLT(rng, degree, numChunks) {
        const indices = [];
        const actualDegree = Math.min(degree, numChunks);
        
        // Select chunks uniformly at random without replacement
        while (indices.length < actualDegree) {
          const index = Math.floor(rng() * numChunks);
          if (!indices.includes(index)) {
            indices.push(index);
          }
        }
        
        return indices;
      }

      stringToUint8Array(str) {
        const arr = new Uint8Array(str.length);
        for (let i = 0; i < str.length; i++) {
          arr[i] = str.charCodeAt(i);
        }
        return arr;
      }
    }

    // Optimized EnhancedFountainDecoder implementation
    class EnhancedFountainDecoder {
      constructor() {
        this.reset();
      }
      
      reset() {
        this.initialized = false;
        this.metaData = null;
        this.totalChunks = 0;
        this.sourceChunks = {};
        this.recoveredChunkCount = 0;
        this.codedPackets = [];
        this.completeCallback = null;
        this.newlyRecoveredChunks = [];
        this.packetStats = {
          total: 0,
          degree1: 0,
          degreeN: 0,
          usefulPackets: 0
        };
      }

      initialize(metadata) {
        this.reset();
        this.metaData = metadata;
        this.totalChunks = metadata.chunksCount;
        this.initialized = true;
        
        console.log(`Fountain decoder initialized with ${metadata.chunksCount} chunks, file size: ${metadata.fileSize} bytes`);
      }

      setCompleteCallback(callback) {
        this.completeCallback = callback;
      }

      // Main method to add a packet for decoding
      addPacket(packet) {
        if (!this.initialized) {
          throw new Error("Fountain decoder not initialized");
        }

        this.packetStats.total++;

        // Handle systematic (degree 1) packets
        if (packet.isDegreeOne) {
          return this.processSystematicPacket(packet);
        }
        
        // Handle fountain packets (degree > 1)
        return this.processFountainPacket(packet);
      }
      
      processSystematicPacket(packet) {
        this.packetStats.degree1++;
        let anyNewChunks = false;

        packet.systematicDataChunks.forEach(chunk => {
          const chunkIndex = chunk.chunkIndex;
          if (!this.sourceChunks[chunkIndex]) {
            // Convert string data to Uint8Array
            const chunkData = this.stringToUint8Array(chunk.chunkData);
            this.storeSourceChunk(chunkIndex, chunkData);
            this.newlyRecoveredChunks.push(chunkIndex);
            anyNewChunks = true;
          }
        });

        if (anyNewChunks) {
          this.packetStats.usefulPackets++;
          this.propagateAndDecode();
          return true;
        }
        return false;
      }
      
      processFountainPacket(packet) {
        this.packetStats.degreeN++;

        // Check if all source chunks are already recovered
        const missingChunks = packet.sourceChunks.filter(
          chunkIndex => !this.sourceChunks[chunkIndex]
        );

        // If we already have all chunks, skip this packet
        if (missingChunks.length === 0) {
          return false;
        }

        // If we're missing just one chunk, recover it immediately
        if (missingChunks.length === 1) {
          return this.recoverSingleMissingChunk(packet, missingChunks[0]);
        }

        // Otherwise, store the fountain packet for later processing
        this.codedPackets.push(packet);
        return true;
      }
      
      recoverSingleMissingChunk(packet, missingChunkIndex) {
        // Create a copy of the fountain data
        const resultData = new Uint8Array(packet.fountainData.length);
        resultData.set(packet.fountainData);

        // XOR with all the chunks we already have to get the missing one
        for (const chunkIndex of packet.sourceChunks) {
          if (chunkIndex !== missingChunkIndex && this.sourceChunks[chunkIndex]) {
            this.xorData(resultData, this.sourceChunks[chunkIndex]);
          }
        }

        // Store the recovered chunk
        this.storeSourceChunk(missingChunkIndex, resultData);
        this.newlyRecoveredChunks.push(missingChunkIndex);
        this.packetStats.usefulPackets++;
        
        // Check if this was the last chunk we needed
        if (this.recoveredChunkCount === this.totalChunks) {
          console.log("Recovered final chunk directly! Finalizing file...");
          this.finalizeFile();
        } else {
          // Not complete yet, try to recover more through propagation
          this.propagateAndDecode();
        }
        
        return true;
      }

      // Process stored coded packets when new chunks are available
      propagateAndDecode() {
        let progress = true;
        let iterationCount = 0;
        const MAX_ITERATIONS = 1000; // Safety limit to prevent infinite loops

        while (progress && iterationCount < MAX_ITERATIONS) {
          progress = false;
          iterationCount++;

          // Try to decode more chunks using the coded packets
          for (let i = this.codedPackets.length - 1; i >= 0; i--) {
            const packet = this.codedPackets[i];

            // Count missing chunks in this packet
            const missingChunks = packet.sourceChunks.filter(
              chunkIndex => !this.sourceChunks[chunkIndex]
            );

            if (missingChunks.length === 0) {
              // All chunks in this packet are recovered, remove it
              this.codedPackets.splice(i, 1);
              continue;
            }

            if (missingChunks.length === 1) {
              // We can recover one chunk
              const missingChunkIndex = missingChunks[0];
              
              // Create a copy of the fountain data
              const resultData = new Uint8Array(packet.fountainData.length);
              resultData.set(packet.fountainData);

              // XOR with all the chunks we already have
              for (const chunkIndex of packet.sourceChunks) {
                if (chunkIndex !== missingChunkIndex && this.sourceChunks[chunkIndex]) {
                  this.xorData(resultData, this.sourceChunks[chunkIndex]);
                }
              }

              // Store the recovered chunk
              this.storeSourceChunk(missingChunkIndex, resultData);
              this.newlyRecoveredChunks.push(missingChunkIndex);
              this.packetStats.usefulPackets++;

              // Remove this packet
              this.codedPackets.splice(i, 1);
              progress = true;
            }
          }
        }

        if (iterationCount >= MAX_ITERATIONS) {
          console.warn("Reached maximum propagation iterations, may have infinite loop");
        }

        // Explicitly check if all chunks are recovered
        let allChunksRecovered = true;
        for (let i = 0; i < this.totalChunks; i++) {
          if (!this.sourceChunks[i]) {
            allChunksRecovered = false;
            break;
          }
        }

        // Make sure our counter is accurate
        if (allChunksRecovered && this.recoveredChunkCount !== this.totalChunks) {
          console.log(`Correcting recovered chunk count from ${this.recoveredChunkCount} to ${this.totalChunks}`);
          this.recoveredChunkCount = this.totalChunks;
        }

        // Check if all chunks are recovered
        if (allChunksRecovered) {
          console.log("All chunks recovered! Finalizing file...");
          this.finalizeFile();
        }
      }

      // Store a source chunk in our decoded data
      storeSourceChunk(index, data) {
        if (!this.sourceChunks[index]) {
          // Ensure data is a Uint8Array
          if (!(data instanceof Uint8Array)) {
            data = this.ensureUint8Array(data);
          }

          this.sourceChunks[index] = data;
          this.recoveredChunkCount++;
        }
      }

      // Helper to ensure data is a Uint8Array
      ensureUint8Array(data) {
        if (data instanceof Uint8Array) {
          return data;
        }

        if (typeof data === 'string') {
          return this.stringToUint8Array(data);
        }

        // If it's an array-like object, convert it
        if (Array.isArray(data) || ArrayBuffer.isView(data)) {
          return new Uint8Array(data);
        }

        console.error("Unknown data type, cannot convert to Uint8Array:", typeof data);
        return new Uint8Array(0);
      }

      // Convert string to Uint8Array
      stringToUint8Array(str) {
        const arr = new Uint8Array(str.length);
        for (let i = 0; i < str.length; i++) {
          arr[i] = str.charCodeAt(i);
        }
        return arr;
      }

      // XOR two binary arrays
      xorData(target, source) {
        const minLength = Math.min(target.length, source.length);
        for (let i = 0; i < minLength; i++) {
          target[i] ^= source[i];
        }
      }

      // Get the list of newly recovered chunks since the last check
      getNewlyRecoveredChunks() {
        const chunks = [...this.newlyRecoveredChunks];
        this.newlyRecoveredChunks = [];
        return chunks;
      }

      // Get the current recovery progress
      getRecoveryProgress() {
        return {
          recovered: this.recoveredChunkCount,
          total: this.totalChunks,
          percentage: Math.round((this.recoveredChunkCount / this.totalChunks) * 100),
          packetStats: this.packetStats
        };
      }

      // Final step: reconstruct the file from decoded chunks
      finalizeFile() {
        console.log(`Recovery stats: ${this.recoveredChunkCount}/${this.totalChunks} chunks`);
        
        try {
          // Verify all chunks exist
          let missingChunks = [];
          for (let i = 0; i < this.totalChunks; i++) {
            if (!this.sourceChunks[i]) {
              missingChunks.push(i);
            }
          }
          
          if (missingChunks.length > 0) {
            console.error(`Missing ${missingChunks.length} chunks during file reconstruction, cannot finalize yet`);
            return;
          }

          // Double check recovery count matches total chunks
          if (this.recoveredChunkCount !== this.totalChunks) {
            console.error(`Recovered chunk count (${this.recoveredChunkCount}) doesn't match total chunks (${this.totalChunks})`);
            this.recoveredChunkCount = this.totalChunks; // Force correction
          }

          // Get or calculate file size
          let fileSize = this.metaData.fileSize;
          if (isNaN(fileSize) || fileSize <= 0) {
            fileSize = 0;
            for (let i = 0; i < this.totalChunks; i++) {
              fileSize += this.sourceChunks[i].length;
            }
          }

          // Create final file data buffer
          const fileData = new Uint8Array(fileSize);
          let offset = 0;
          
          // Combine all chunks in order
          for (let i = 0; i < this.totalChunks; i++) {
            const chunk = this.sourceChunks[i];
            if (!chunk || !(chunk instanceof Uint8Array)) {
              console.error(`Invalid chunk at index ${i}`);
              continue;
            }
            
            // Calculate how much to copy (handle last chunk)
            const bytesToCopy = Math.min(chunk.length, fileData.length - offset);
            fileData.set(chunk.subarray(0, bytesToCopy), offset);
            offset += bytesToCopy;
            
            if (offset >= fileData.length) break;
          }

          console.log(`File reconstruction complete. Total size: ${fileData.length} bytes`);

          // Handle base64 decoding if needed
          let finalData = fileData;
          try {
            // Only try base64 decoding if it looks like base64
            const sampleText = this.arrayBufferToString(fileData.slice(0, 100));
            if (/^[A-Za-z0-9+/=]+$/.test(sampleText)) {
              console.log("Detected base64 content, attempting decoding");
              const base64String = this.arrayBufferToString(fileData);
              finalData = this.base64ToArrayBuffer(base64String);
              console.log(`Base64 decoded size: ${finalData.length} bytes`);
            } else {
              console.log("Content doesn't appear to be base64, using raw data");
            }
          } catch (e) {
            console.warn("Base64 decoding failed, using original data");
            finalData = fileData;
          }

          // Notify completion
          if (this.completeCallback) {
            this.completeCallback(finalData);
          }
        } catch (error) {
          console.error("Error finalizing file:", error);
        }
      }

      arrayBufferToString(buffer) {
        const decoder = new TextDecoder('utf-8');
        return decoder.decode(buffer);
      }

      base64ToArrayBuffer(base64) {
        try {
          const binary = atob(base64);
          const bytes = new Uint8Array(binary.length);
          for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
          }
          return bytes;
        } catch (e) {
          console.error("Base64 decoding error:", e);
          throw e;
        }
      }
    }

    // Optimized video processor
    class EnhancedVideoProcessor {
      constructor(options) {
        this.frameCallback = options.frameCallback;
        this.progressCallback = options.progressCallback;
        this.errorCallback = options.errorCallback;
        this.frameInterval = options.frameInterval || 20;

        this.videoElement = document.getElementById('videoPreview');
        this.videoFile = null;
        this.processedFrames = 0;
        this.totalFrames = 0;
        this.startTime = 0;
        this.isProcessing = false;
        this.processTimer = null;

        // Canvas for frame processing
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });

        // Frame processing stats
        this.frameStats = {
          processed: 0,
          processingTimes: []
        };
      }

      static isWebCodecsSupported() {
        return typeof window.VideoDecoder === 'function' &&
               typeof window.VideoEncoder === 'function' &&
               typeof window.EncodedVideoChunk === 'function';
      }

      async initialize(videoFile) {
        this.videoFile = videoFile;
        this.processedFrames = 0;
        this.frameStats = {
          processed: 0,
          processingTimes: []
        };

        try {
          // Create video URL and set video element source
          const videoUrl = URL.createObjectURL(videoFile);
          this.videoElement.src = videoUrl;

          // Wait for video metadata to load
          await new Promise((resolve) => {
            this.videoElement.onloadedmetadata = () => resolve();
          });

          // Get video metadata and estimate frames
          this.totalFrames = Math.ceil(this.videoElement.duration * 30);

          // Set canvas dimensions
          this.canvas.width = this.videoElement.videoWidth;
          this.canvas.height = this.videoElement.videoHeight;

          console.log(`Video initialized: ${this.videoElement.videoWidth}x${this.videoElement.videoHeight}, duration: ${this.videoElement.duration}s, frames: ${this.totalFrames}`);
          return true;
        } catch (error) {
          if (this.errorCallback) {
            this.errorCallback(error);
          }
          throw error;
        }
      }

      startProcessing() {
        if (this.isProcessing) return;

        this.isProcessing = true;
        this.startTime = performance.now();

        // Start playing the video
        this.videoElement.currentTime = 0;
        this.videoElement.play();

        // Use requestVideoFrameCallback if available
        if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
          this.processWithVideoFrameCallback();
        } else {
          // Fallback to setInterval
          this.processTimer = setInterval(() => {
            this.processCurrentFrame();
          }, this.frameInterval);
        }
      }

      processWithVideoFrameCallback() {
        const processFrame = () => {
          if (!this.isProcessing) return;

          this.processCurrentFrame();

          // Request next frame if still processing
          if (this.isProcessing && !this.videoElement.paused && !this.videoElement.ended) {
            this.videoElement.requestVideoFrameCallback(processFrame);
          } else {
            this.completed();
          }
        };

        this.videoElement.requestVideoFrameCallback(processFrame);
      }

      processCurrentFrame() {
        if (!this.isProcessing) return;

        // Check if video is playing
        if (this.videoElement.paused || this.videoElement.ended) {
          this.completed();
          return;
        }

        const processingStart = performance.now();

        // Count this frame
        this.processedFrames++;
        this.frameStats.processed++;

        try {
          // Draw current frame to canvas
          this.ctx.drawImage(this.videoElement, 0, 0, this.canvas.width, this.canvas.height);

          // Get frame data
          const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);

          // Calculate progress
          const progress = Math.min(this.videoElement.currentTime / this.videoElement.duration, 1);
          const elapsedTime = (performance.now() - this.startTime) / 1000;
          const estimatedTotalTime = progress > 0 ? elapsedTime / progress : 0;
          const remainingTime = Math.max(0, estimatedTotalTime - elapsedTime);

          // Call progress callback
          if (this.progressCallback) {
            this.progressCallback(progress, this.processedFrames, this.totalFrames, remainingTime);
          }

          // Call frame callback
          if (this.frameCallback) {
            this.frameCallback(imageData, this.videoElement.currentTime, this.processedFrames);
          }

          // Track processing time
          const processingTime = performance.now() - processingStart;
          this.frameStats.processingTimes.push(processingTime);

          // Adjust frame interval periodically
          if (this.frameStats.processed % 30 === 0) {
            this.adjustFrameInterval();
          }
        } catch (error) {
          console.error('Error processing frame:', error);
          if (this.errorCallback) {
            this.errorCallback(error);
          }
        }
      }

      adjustFrameInterval() {
        // Calculate average processing time
        const times = this.frameStats.processingTimes;
        const avgTime = times.reduce((sum, time) => sum + time, 0) / times.length;
        
        // Reset timing array to avoid memory growth
        this.frameStats.processingTimes = [];

        // If processing is taking too long, increase interval
        if (avgTime > this.frameInterval * 1.5) {
          const newInterval = Math.min(Math.ceil(avgTime * 1.2), 100);
          this.frameInterval = newInterval;

          // Update timer if using setInterval
          if (this.processTimer) {
            clearInterval(this.processTimer);
            this.processTimer = setInterval(() => {
              this.processCurrentFrame();
            }, this.frameInterval);
          }
        }
      }

      stopProcessing() {
        this.isProcessing = false;

        // Pause video
        if (!this.videoElement.paused) {
          this.videoElement.pause();
        }

        // Clear timer if using interval
        if (this.processTimer) {
          clearInterval(this.processTimer);
          this.processTimer = null;
        }

        this.completed();
      }

      completed() {
        this.isProcessing = false;
      }
    }

    // Optimized QR processor
    class EnhancedQRProcessor {
      constructor(options) {
        this.onQrDetected = options.onQrDetected;
        this.onError = options.onError;
        this.detectionConfidence = options.detectionConfidence || 0.5;

        // Create canvas for frame processing
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });

        // Initialize HTML5QRCode instance
        this.html5QrCode = null;
        this.isReady = false;

        // Stats
        this.detectionStats = {
          attempts: 0,
          successes: 0,
          failures: 0,
          duplicates: 0
        };

        // Cache of recently seen QR codes to detect duplicates
        this.recentlySeenQRs = new Map();
        this.maxCacheSize = 30;

        // Create a hidden element for the QR code reader
        this.qrElement = document.createElement('div');
        this.qrElement.id = 'qr-reader-hidden';
        this.qrElement.style.display = 'none';
        document.body.appendChild(this.qrElement);
      }

      async initialize() {
        try {
          // Initialize HTML5QRCode with only necessary formats
          this.html5QrCode = new Html5Qrcode('qr-reader-hidden', {
            formatsToSupport: [
              Html5QrcodeSupportedFormats.QR_CODE,
              Html5QrcodeSupportedFormats.DATA_MATRIX
            ]
          });

          this.isReady = true;
          return true;
        } catch (error) {
          if (this.onError) {
            this.onError(error);
          }
          console.error("Failed to initialize HTML5QRCode", error);
          throw error;
        }
      }

      processFrame(imageData, frameIndex) {
        if (!this.isReady) {
          throw new Error("QR processor not initialized");
        }

        this.detectionStats.attempts++;

        return new Promise((resolve) => {
          try {
            // Adjust canvas size if needed
            if (this.canvas.width !== imageData.width || this.canvas.height !== imageData.height) {
              this.canvas.width = imageData.width;
              this.canvas.height = imageData.height;
            }

            // Draw image data to canvas
            this.ctx.putImageData(imageData, 0, 0);

            // Convert to data URL
            const dataUrl = this.canvas.toDataURL('image/jpeg', 0.7);

            // Use HTML5QRCode to scan the image
            this.html5QrCode.scanFile(
              this.dataURLtoFile(dataUrl, 'frame.jpg'),
              false 
            )
            .then(decodedText => {
              // QR code found
              this.detectionStats.successes++;

              // Check if this is a duplicate
              if (this.checkDuplicate(decodedText, frameIndex)) {
                this.detectionStats.duplicates++;
                resolve({
                  success: false,
                  isDuplicate: true,
                  frameIndex
                });
                return;
              }
              
              // Not a duplicate, track it
              this.addToRecentlySeen(decodedText, frameIndex);

              // Get location data if available
              const lastResult = this.html5QrCode._lastScanResult || null;

              resolve({
                success: true,
                qrData: decodedText,
                frameIndex,
                bounds: this.estimateBounds(lastResult, imageData)
              });
            })
            .catch(() => {
              // No QR code found
              this.detectionStats.failures++;
              resolve({
                success: false,
                frameIndex
              });
            });
          } catch (error) {
            // Error during processing
            this.detectionStats.failures++;
            if (this.onError) {
              this.onError(error);
            }
            resolve({
              success: false,
              frameIndex
            });
          }
        });
      }

      // Check if a QR code is a duplicate
      checkDuplicate(qrData, frameIndex) {
        if (this.recentlySeenQRs.has(qrData)) {
          const lastSeenFrame = this.recentlySeenQRs.get(qrData);
          return (frameIndex - lastSeenFrame) < 5;
        }
        return false;
      }

      // Add a QR code to the recently seen cache
      addToRecentlySeen(qrData, frameIndex) {
        this.recentlySeenQRs.set(qrData, frameIndex);
        
        // Trim cache if too large
        if (this.recentlySeenQRs.size > this.maxCacheSize) {
          // Remove oldest entries (first 20%)
          const entries = Array.from(this.recentlySeenQRs.entries())
            .sort((a, b) => a[1] - b[1])
            .slice(0, Math.ceil(this.maxCacheSize * 0.2));
            
          entries.forEach(([key]) => this.recentlySeenQRs.delete(key));
        }
      }

      // Estimate QR code bounds
      estimateBounds(decodedResult, imageData) {
        // If we have location info from the decoder, use it
        if (decodedResult && decodedResult.location) {
          const loc = decodedResult.location;
          
          // Calculate bounds from QR code points
          const xValues = [loc.topLeft.x, loc.topRight.x, loc.bottomLeft.x, loc.bottomRight.x];
          const yValues = [loc.topLeft.y, loc.topRight.y, loc.bottomLeft.y, loc.bottomRight.y];
          
          const minX = Math.min(...xValues);
          const maxX = Math.max(...xValues);
          const minY = Math.min(...yValues);
          const maxY = Math.max(...yValues);
          
          // Use the larger dimension for a square
          const size = Math.max(maxX - minX, maxY - minY);
          const centerX = (minX + maxX) / 2;
          const centerY = (minY + maxY) / 2;
          
          return {
            x: centerX - size / 2,
            y: centerY - size / 2,
            width: size,
            height: size
          };
        }
        
        // Fallback to a square centered estimation
        const width = imageData.width || 300;
        const height = imageData.height || 300;
        const size = Math.min(width, height) / 2.5;
        
        return {
          x: width / 2 - size / 2,
          y: 0,
          width: size,
          height: size
        };
      }

      // Convert data URL to File object
      dataURLtoFile(dataurl, filename) {
        const arr = dataurl.split(',');
        const mime = arr[0].match(/:(.*?);/)[1];
        const bstr = atob(arr[1]);
        const u8arr = new Uint8Array(bstr.length);
        
        for (let i = 0; i < bstr.length; i++) {
          u8arr[i] = bstr.charCodeAt(i);
        }
        
        return new File([u8arr], filename, { type: mime });
      }

      // Cleanup resources
      dispose() {
        if (this.html5QrCode) {
          try {
            this.html5QrCode.clear();
          } catch (error) {
            console.error("Error clearing HTML5QRCode", error);
          }
        }

        if (this.qrElement && this.qrElement.parentNode) {
          this.qrElement.parentNode.removeChild(this.qrElement);
        }
      }
    }

    // Main QR File Decoder Class
    class QRFileDecoder {
      constructor() {
        this.logger = new Logger('logWindow');
        this.ui = new UI(this.logger);

        // Initialize components
        this.videoProcessor = null;
        this.qrProcessor = null;
        this.packetProcessor = null;
        this.fountainDecoder = null;

        // Application state
        this.isProcessing = false;
        this.videoFile = null;
        this.metadataReceived = false;
        this.fileMetadata = null;
        this.recoveredChunks = new Map();
        this.missingChunks = new Set();
        this.settings = {
          frameInterval: 20,
          qrDetectionConfidence: 0.5
        };

        // Counters
        this.qrCodesDetected = 0;
        this.packetsProcessed = 0;
        this.recoveredFileData = null;

        // Initialize
        this.checkCompatibility();
        this.initEventListeners();

        this.logger.info("QR File Decoder initialized");
      }

      checkCompatibility() {
        // Check for WebCodecs support
        const isWebCodecsSupported = EnhancedVideoProcessor.isWebCodecsSupported();

        if (!isWebCodecsSupported) {
          this.ui.showErrorMessage("WebCodecs API is not supported in your browser. Please use Chrome 94+, Edge 94+, or another compatible browser.");
          document.getElementById('startScanBtn').disabled = true;
        }

        // Check for HTML5QRCode library
        if (typeof Html5Qrcode === 'undefined') {
          this.ui.showErrorMessage("HTML5QRCode library is not available. Please check your internet connection and reload the page.");
          document.getElementById('startScanBtn').disabled = true;
        }
      }

      resetContents() {
        if (this.isProcessing) {
          this.stopProcessing();
        }

        // Reset application state
        this.metadataReceived = false;
        this.fileMetadata = null;
        this.recoveredChunks = new Map();
        this.missingChunks = new Set();
        this.qrCodesDetected = 0;
        this.packetsProcessed = 0;
        this.recoveredFileData = null;

        // Reset UI elements
        this.ui.resetChunkGrid();
        this.ui.updateFileInfo("No file detected yet");
        document.getElementById('missingChunks').textContent = "Waiting for metadata...";
        document.getElementById('downloadContainer').style.display = 'none';
        this.ui.clearQRHighlight();
        this.ui.hideErrorMessage();

        // Keep the video input if the user wants to try scanning again
        document.getElementById('startScanBtn').disabled = this.videoFile ? false : true;

        this.logger.info("Contents reset, ready for new scan");
      }

      initEventListeners() {
        // Video input change
        document.getElementById('videoInput').addEventListener('change', this.handleVideoInput.bind(this));

        // Button clicks
        document.getElementById('startScanBtn').addEventListener('click', this.startProcessing.bind(this));
        document.getElementById('stopScanBtn').addEventListener('click', this.stopProcessing.bind(this));
        document.getElementById('downloadBtn').addEventListener('click', this.downloadFile.bind(this));
        document.getElementById('settingsBtn').addEventListener('click', this.ui.showSettingsModal.bind(this.ui));
        document.getElementById('saveSettingsBtn').addEventListener('click', this.saveSettings.bind(this));
        document.getElementById('clearLogBtn').addEventListener('click', this.logger.clear.bind(this.logger));
        document.getElementById('resetBtn').addEventListener('click', this.resetContents.bind(this));

        // Log filters
        document.querySelectorAll('.log-filter').forEach(btn => {
          btn.addEventListener('click', (e) => {
            this.logger.setFilter(e.target.dataset.level);
            this.ui.updateLogFilterButtons(e.target);
          });
        });

        // Settings modal close
        document.querySelector('.modal .close').addEventListener('click', this.ui.hideSettingsModal.bind(this.ui));
      }

      async handleVideoInput(event) {
        if (!event.target.files || event.target.files.length === 0) {
          return;
        }

        this.videoFile = event.target.files[0];
        this.logger.info(`Video file selected: ${this.videoFile.name} (${this.formatFileSize(this.videoFile.size)})`);

        try {
          // Create a URL for the video
          const videoUrl = URL.createObjectURL(this.videoFile);
          const videoElement = document.getElementById('videoPreview');
          videoElement.src = videoUrl;

          // Enable start button once video is loaded
          videoElement.onloadedmetadata = () => {
            document.getElementById('startScanBtn').disabled = false;
            this.logger.info(`Video duration: ${videoElement.duration.toFixed(2)} seconds`);
          };
        } catch (error) {
          this.logger.error(`Error loading video: ${error.message}`);
          this.ui.showErrorMessage(`Error loading video: ${error.message}`);
        }
      }

      async startProcessing() {
        if (!this.videoFile) {
          this.logger.warn("No video file selected");
          return;
        }

        if (this.isProcessing) {
          this.logger.warn("Processing already in progress");
          return;
        }

        this.isProcessing = true;
        this.metadataReceived = false;
        this.recoveredChunks.clear();
        this.missingChunks.clear();
        this.qrCodesDetected = 0;
        this.packetsProcessed = 0;
        this.recoveredFileData = null;

        // Update UI
        document.getElementById('startScanBtn').disabled = true;
        document.getElementById('stopScanBtn').disabled = false;
        document.getElementById('downloadContainer').style.display = 'none';
        this.ui.resetChunkGrid();
        this.ui.updateFileInfo("Processing video...");
        this.ui.clearQRHighlight();
        this.ui.hideErrorMessage();
        this.logger.info("Starting video processing");

        try {
          // Initialize components
          await this.initializeComponents();

          // Start processing
          await this.videoProcessor.initialize(this.videoFile);
          this.videoProcessor.startProcessing();

          this.logger.info("Processing started");
        } catch (error) {
          this.logger.error(`Failed to start processing: ${error.message}`);
          this.ui.showErrorMessage(`Failed to start processing: ${error.message}`);
          this.stopProcessing();
        }
      }

      async initializeComponents() {
        // Initialize QR processor
        this.qrProcessor = new EnhancedQRProcessor({
          onQrDetected: this.handleQRCodeResult.bind(this),
          onError: (error) => this.logger.error(`QR processing error: ${error.message}`),
          detectionConfidence: this.settings.qrDetectionConfidence
        });

        await this.qrProcessor.initialize();

        // Initialize packet processor
        this.packetProcessor = new PacketProcessor();

        // Initialize fountain decoder
        this.fountainDecoder = new EnhancedFountainDecoder();
        this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this));

        // Initialize video processor
        this.videoProcessor = new EnhancedVideoProcessor({
          frameCallback: this.handleVideoFrame.bind(this),
          progressCallback: this.ui.updateProgress.bind(this.ui),
          errorCallback: (error) => this.logger.error(`Video processing error: ${error.message}`),
          frameInterval: this.settings.frameInterval
        });
      }

      stopProcessing() {
        if (!this.isProcessing) return;

        this.isProcessing = false;

        // Stop video processing
        if (this.videoProcessor) {
          this.videoProcessor.stopProcessing();
        }

        // Clean up QR processor
        if (this.qrProcessor) {
          this.qrProcessor.dispose();
        }

        // Clear QR highlight
        this.ui.clearQRHighlight();

        // Update UI
        document.getElementById('startScanBtn').disabled = false;
        document.getElementById('stopScanBtn').disabled = true;
        this.logger.info("Processing stopped");

        // Show stats
        this.logger.info(`Processing summary: Detected ${this.qrCodesDetected} QR codes, processed ${this.packetsProcessed} packets`);

        if (this.metadataReceived) {
          const progress = this.fountainDecoder.getRecoveryProgress();
          this.logger.info(`File recovery progress: ${progress.recovered}/${progress.total} chunks (${progress.percentage}%)`);
        }
      }

      async handleVideoFrame(imageData, timestamp, frameIndex) {
        if (!this.isProcessing) return;

        try {
          // Process frame for QR codes
          const result = await this.qrProcessor.processFrame(imageData, frameIndex);

          if (result.success) {
            this.qrCodesDetected++;

            // Draw QR highlight if bounds are available
            if (result.bounds) {
              this.ui.drawQRHighlight(
                result.bounds.x,
                result.bounds.y,
                result.bounds.width,
                result.bounds.height
              );
              this.logger.debug(`QR code detected in frame ${frameIndex}`);
            }

            // Process QR data
            this.handleQRCodeResult(result);
          } else if (!result.isDuplicate) {
            // Clear QR highlight if no QR code detected
            this.ui.clearQRHighlight();
          }
        } catch (error) {
          this.logger.error(`Error processing frame ${frameIndex}: ${error.message}`);
        }
      }

      handleQRCodeResult(result) {
        if (!result.success) return;

        const { qrData, frameIndex } = result;

        // Process the QR data
        const packetResult = this.packetProcessor.processQRData(qrData, frameIndex);

        if (packetResult.success) {
          this.handlePacketResult(packetResult);
        } else {
          this.logger.warn(`Failed to process QR data: ${packetResult.error}`);
        }
      }

      handlePacketResult(result) {
        if (!result.success) {
          this.logger.warn(`Failed to process packet: ${result.error}`);
          return;
        }

        this.packetsProcessed++;
        const { packetType, packetData } = result;

        if (packetType === 'metadata') {
          this.handleMetadataPacket(packetData);
        } else if (packetType === 'data') {
          this.handleDataPacket(packetData);
        }
      }

      handleMetadataPacket(metadata) {
        // Check if we already have metadata and if it matches
        if (this.metadataReceived) {
          // Compare key properties to see if this is the same file
          if (metadata.fileName === this.fileMetadata.fileName &&
              metadata.fileSize === this.fileMetadata.fileSize &&
              metadata.chunksCount === this.fileMetadata.chunksCount) {
            // Same file, just log and return
            this.logger.debug("Received duplicate metadata packet");
            return;
          } else {
            // Different file, but we're already processing one
            // Ignore this metadata packet - only reset on explicit user command
            this.logger.warn("Received metadata for a different file, ignoring");
            return;
          }
        }

        this.metadataReceived = true;
        this.fileMetadata = metadata;

        // Initialize UI with metadata
        this.ui.initializeChunkGrid(metadata.chunksCount);
        this.ui.updateFileInfo(`
          <div><strong>File Name:</strong> ${metadata.fileName}</div>
          <div><strong>File Type:</strong> ${metadata.fileType}</div>
          <div><strong>File Size:</strong> ${this.formatFileSize(metadata.fileSize)}</div>
          <div><strong>Chunks:</strong> ${metadata.chunksCount}</div>
        `);

        // Initialize fountain decoder with metadata
        this.fountainDecoder.initialize(metadata);

        // Initialize missing chunks set
        for (let i = 0; i < metadata.chunksCount; i++) {
          this.missingChunks.add(i);
        }

        this.updateMissingChunksUI();

        this.logger.info(`Metadata received: ${metadata.fileName} (${this.formatFileSize(metadata.fileSize)}), ${metadata.chunksCount} chunks`);
      }

      handleDataPacket(packet) {
        // Skip if metadata hasn't been received
        if (!this.metadataReceived) {
          this.logger.warn("Received data packet before metadata, ignoring");
          return;
        }

        // Blink source chunks to show detection
        if (packet.sourceChunks) {
          packet.sourceChunks.forEach(chunkIndex => {
            this.ui.blinkChunk(chunkIndex);
          });
        }

        // Add packet to fountain decoder
        const wasAdded = this.fountainDecoder.addPacket(packet);

        if (wasAdded) {
          // Update recovered chunks
          const newlyRecovered = this.fountainDecoder.getNewlyRecoveredChunks();
          if (newlyRecovered.length > 0) {
            newlyRecovered.forEach(chunkIndex => {
              this.recoveredChunks.set(chunkIndex, true);
              this.missingChunks.delete(chunkIndex);
              this.ui.markChunkAsRecovered(chunkIndex);
            });

            this.updateMissingChunksUI();
            this.logger.info(`Recovered ${newlyRecovered.length} new chunks, total: ${this.recoveredChunks.size}/${this.fileMetadata.chunksCount}`);
            
            // Check if we've reached completion
            if (this.missingChunks.size === 0) {
              this.logger.info("All chunks have been recovered!");
              
              // Force check completion in case finalizeFile wasn't triggered elsewhere
              if (this.recoveredChunks.size === this.fileMetadata.chunksCount && 
                  !this.recoveredFileData) {
                setTimeout(() => {
                  if (!this.recoveredFileData) {
                    this.logger.warn("Possible missed completion - forcing finalization check");
                    this.fountainDecoder.finalizeFile();
                  }
                }, 500);
              }
            }
          }
        }
      }

      updateMissingChunksUI() {
        const missingCount = this.missingChunks.size;
        const totalCount = this.fileMetadata.chunksCount;
        const recoveredCount = totalCount - missingCount;
        const percentage = Math.round(recoveredCount / totalCount * 100);

        document.getElementById('missingChunks').innerHTML = `
          <div>Recovered chunks: ${recoveredCount}/${totalCount} (${percentage}%)</div>
          <div>Missing chunks: ${missingCount}</div>
        `;
      }

      handleFileComplete(fileData) {
        this.logger.info("File recovery complete!");

        // Store the recovered file data
        this.recoveredFileData = fileData;

        // Show download button
        document.getElementById('downloadContainer').style.display = 'block';

        // Update file info with success message
        const fileInfo = document.getElementById('fileInfo').innerHTML;
        document.getElementById('fileInfo').innerHTML = fileInfo + `
          <div style="margin-top: 10px; color: var(--success);">
            <strong>File Successfully Recovered!</strong>
          </div>
        `;

        // Stop processing if still running
        if (this.isProcessing) {
          this.stopProcessing();
        }
        
        // Automatically trigger the download
        this.downloadFile();
      }

      downloadFile() {
        if (!this.recoveredFileData || !this.fileMetadata) {
          this.logger.warn("No recovered file data available");
          return;
        }

        try {
          // Create blob from recovered data
          const blob = new Blob([this.recoveredFileData], { 
            type: this.fileMetadata.fileType || 'application/octet-stream' 
          });

          // Create download link
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = this.fileMetadata.fileName;
          document.body.appendChild(a);
          a.click();

          // Clean up
          setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          }, 100);

          this.logger.info(`File "${this.fileMetadata.fileName}" downloaded (${this.formatFileSize(this.recoveredFileData.byteLength)})`);
        } catch (error) {
          this.logger.error(`Error downloading file: ${error.message}`);
          this.ui.showErrorMessage(`Error downloading file: ${error.message}`);
        }
      }

      saveSettings() {
        // Get values from settings form
        const frameInterval = parseInt(document.getElementById('frameInterval').value);
        const qrDetectionConfidence = parseFloat(document.getElementById('qrDetectionConfidence').value);

        // Validate and update settings
        this.settings = {
          frameInterval: isNaN(frameInterval) ? 20 : Math.min(Math.max(frameInterval, 0), 1000),
          qrDetectionConfidence: isNaN(qrDetectionConfidence) ? 0.5 : Math.min(Math.max(qrDetectionConfidence, 0), 1)
        };

        this.logger.info(`Settings updated: ${JSON.stringify(this.settings)}`);
        this.ui.hideSettingsModal();
      }

      formatFileSize(bytes) {
        if (bytes < 1024) return `${bytes} bytes`;
        if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB`;
        return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
      }
    }

    // Initialize when the document is loaded
    document.addEventListener('DOMContentLoaded', () => {
      window.qrFileDecoder = new QRFileDecoder();
    });
  </script>
</body>

</html>