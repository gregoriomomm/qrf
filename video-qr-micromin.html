<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>QR</title>
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
<style>*{margin:0;padding:0;box-sizing:border-box}
html,body{height:100%;width:100%;overflow:hidden;font-family:sans-serif}
body{display:flex;flex-direction:column;height:100%}
.h{padding:5px;background:#222;color:#fff;display:flex;justify-content:space-between;z-index:100}
.m{flex:1;position:relative;background:#000;overflow:hidden}
#c{position:absolute;top:0;left:0;width:100%;height:100%;z-index:1}
#v{width:100%;height:100%;display:block;background:#000}
#b{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:200px;height:200px;border:3px solid red;z-index:10;pointer-events:none}
.f{padding:5px;background:#222;z-index:100}
button{padding:5px 10px;background:#07f;color:#fff;border:none;border-radius:3px;margin-right:5px;cursor:pointer}
button:disabled{background:#555}
.t{display:flex}
.a{padding:5px 10px;background:#444;color:#fff;cursor:pointer;margin-left:5px}
.a.active{background:#07f}
#p{position:absolute;top:0;left:0;width:100%;height:100%;background:#111;display:none;flex-direction:column;z-index:5}
#i{flex:1;display:flex;justify-content:center;align-items:center}
#e{max-width:100%;max-height:100%}
.g{height:5px;width:100%;background:#333}
.r{height:100%;width:0%;background:#07f;display:flex;align-items:center;justify-content:center;overflow:hidden}
.s{display:flex;justify-content:space-around;background:#222;color:#fff;padding:2px 0}
#l{position:fixed;bottom:40px;left:0;right:0;padding:5px;background:rgba(0,0,0,.8);color:#fff;max-height:100px;overflow-y:auto;z-index:1000;display:none}
#z{position:absolute;top:5px;right:5px;background:rgba(0,0,0,.5);color:red;padding:5px;border-radius:3px;z-index:10;display:none}
canvas{display:none}
</style>
</head>
<body>
<div class="h">
  <span>QR</span>
  <div class="t">
    <div class="a active" data-tab="1">Cam</div>
    <div class="a" data-tab="2">Proc</div>
  </div>
</div>

<div class="m">
  <div id="c">
    <video id="v" autoplay playsinline></video>
    <div id="b"></div>
    <div id="z">00:00</div>
  </div>
  
  <div id="p">
    <div id="i">
      <img id="e" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
    </div>
    <div class="g">
      <div class="r" id="o"></div>
    </div>
    <div class="s">
      <div>F:<span id="fc">0</span></div>
      <div>Q:<span id="qc">0</span></div>
      <div>C:<span id="cc">0</span></div>
    </div>
  </div>
</div>

<div class="f" id="d1">
  <button id="A">Cam</button>
  <button id="B" disabled>Stop</button>
  <button id="C" disabled>Rec</button>
  <button id="D" disabled>Stop</button>
  <button id="E" disabled>Save</button>
</div>

<div class="f" id="d2" style="display:none">
  <button id="F">Load</button>
  <button id="G">URL</button>
  <button id="H" disabled>Proc</button>
  <button id="I" disabled>Pause</button>
  <button id="J" disabled>Save</button>
</div>

<input type="file" id="f" accept="video/*" style="display:none">
<input type="text" id="u" placeholder="URL" style="display:none;width:100%;padding:5px;margin-top:5px">
<div id="l"></div>
<canvas id="k"></canvas>
<canvas id="w"></canvas>

<script>
// DOM elements
const $=id=>document.getElementById(id),
c=$('c'),p=$('p'),v=$('v'),k=$('k'),w=$('w'),e=$('e'),o=$('o'),
fc=$('fc'),qc=$('qc'),cc=$('cc'),d1=$('d1'),d2=$('d2'),
z=$('z'),l=$('l'),f=$('f'),u=$('u'),ctx=k.getContext('2d'),
wctx=w.getContext('2d'),A=$('A'),B=$('B'),C=$('C'),D=$('D'),
E=$('E'),F=$('F'),G=$('G'),H=$('H'),I=$('I'),J=$('J');

// State
let S=null,R=null,Q=[],T=0,N=null,V=null,U=null,
P=!1,M=!1,X=null,Y=null,Z=null,K={},L={},a=0,b=0,d=0;

// Tab switching
document.querySelectorAll('.a').forEach(t=>{
  t.addEventListener('click',()=>{
    const isCam=t.dataset.tab==='1';
    document.querySelectorAll('.a').forEach(x=>x.classList.remove('active'));
    t.classList.add('active');
    c.style.zIndex=isCam?10:1;
    p.style.display=isCam?'none':'flex';
    d1.style.display=isCam?'block':'none';
    d2.style.display=isCam?'none':'block';
    if(!isCam&&S)stopCam();
    if(isCam&&P){M=!0;if(X)X.pause();clean();}
  });
});

// Utils
function log(m){
  const t=new Date().toLocaleTimeString();
  l.innerHTML+=`[${t}] ${m}<br>`;
  l.scrollTop=l.scrollHeight;
  l.style.display='block';
  setTimeout(()=>l.style.display='none',3000);
  console.log(m);
}

function fmt(ms){
  const s=Math.floor(ms/1000),m=Math.floor(s/60);
  return`${m.toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`;
}

function upd(c,t){
  const p=Math.min(100,(c/t*100)||0);
  o.style.width=`${p}%`;
  o.textContent=`${Math.round(p)}%`;
  o.style.textAlign='center';
  o.style.color='#fff';
  o.style.fontSize='10px';
}

function clean(){
  if(X){X.pause();X.removeAttribute('src');X.load();X=null;}
  ctx.clearRect(0,0,k.width,k.height);
  wctx.clearRect(0,0,w.width,w.height);
  e.src='data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
}

// Camera
async function startCam(){
  try{
    A.disabled=true;
    if(S)S.getTracks().forEach(t=>t.stop());
    S=await navigator.mediaDevices.getUserMedia({
      video:{facingMode:'environment',width:{ideal:1280},height:{ideal:720}}
    });
    v.srcObject=S;
    
    try{
      await v.play();
      log('Video playing');
    }catch(err){
      log('Tap to play: '+err.message);
      v.addEventListener('click',()=>v.play().catch(e=>{}));
      document.body.addEventListener('click',()=>{
        if(v.paused&&S)v.play().catch(e=>{});
      },{once:true});
    }
    
    A.disabled=true;
    B.disabled=false;
    C.disabled=false;
    
    v.onloadeddata=()=>log(`Video: ${v.videoWidth}x${v.videoHeight}`);
  }catch(e){log('Camera error: '+e.message);A.disabled=false;}
}

function stopCam(){
  if(!S)return;
  S.getTracks().forEach(t=>t.stop());
  v.srcObject=null;
  S=null;
  A.disabled=false;
  B.disabled=true;
  C.disabled=true;
  log('Camera stopped');
}

// Recording
function startRec(){
  if(!S)return;
  try{
    const opt={};
    if(MediaRecorder.isTypeSupported('video/webm;codecs=vp9'))
      opt.mimeType='video/webm;codecs=vp9';
    else if(MediaRecorder.isTypeSupported('video/webm'))
      opt.mimeType='video/webm';
    
    R=new MediaRecorder(S,opt);
    Q=[];
    
    R.ondataavailable=e=>{if(e.data.size>0)Q.push(e.data);};
    R.onstop=()=>{
      V=new Blob(Q,{type:R.mimeType||'video/webm'});
      E.disabled=false;
      clearInterval(N);
      log(`Recording: ${(V.size/1024/1024).toFixed(1)}MB`);
    };
    
    R.start(1000);
    T=Date.now();
    z.style.display='block';
    
    N=setInterval(()=>{z.textContent=fmt(Date.now()-T);},1000);
    C.disabled=true;
    D.disabled=false;
  }catch(e){log('Recording error: '+e.message);}
}

function stopRec(){
  if(R&&R.state!=='inactive'){
    R.stop();
    C.disabled=false;
    D.disabled=true;
    z.style.display='none';
    if(N){clearInterval(N);N=null;}
  }
}

function saveRec(){
  if(!V)return;
  const url=URL.createObjectURL(V);
  const a=document.createElement('a');
  a.href=url;
  a.download=`qr-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.webm`;
  a.click();
  setTimeout(()=>URL.revokeObjectURL(url),100);
}

// Processing
function loadFile(file){
  if(!file)return;
  if(U)URL.revokeObjectURL(U);
  V=file;
  U=URL.createObjectURL(V);
  log(`Video: ${file.name}`);
  H.disabled=false;
  reset();
}

function toggleUrl(){
  u.style.display=u.style.display==='block'?'none':'block';
  if(u.style.display==='block')u.focus();
}

async function fetchUrl(){
  const url=u.value.trim();
  if(!url)return;
  try{
    log(`Fetching: ${url}`);
    G.disabled=true;
    const r=await fetch(url);
    if(!r.ok)throw Error(`Failed: ${r.status}`);
    const b=await r.blob();
    if(U)URL.revokeObjectURL(U);
    V=b;
    U=URL.createObjectURL(V);
    log('URL loaded');
    H.disabled=false;
    u.style.display='none';
    reset();
  }catch(e){log(`Error: ${e.message}`);}
  finally{G.disabled=false;}
}

function reset(){
  Z=null;K={};L={};a=0;b=0;d=0;
  fc.textContent='0';qc.textContent='0';cc.textContent='0';
  o.style.width='0';
}

// Smart search variables
let useSmartSearch = false;
let foundTimeRanges = [];

function startProc(){
  if(!U||P)return;
  P=true;
  M=false;
  
  H.disabled=true;
  I.disabled=false;
  I.textContent='Pause';
  
  log('Processing...');
  if(X)X.remove();
  X=document.createElement('video');
  X.src=U;
  X.muted=true;
  
  // Reset state and tracking
  reset();
  foundTimeRanges = [];
  
  X.onloadedmetadata=()=>{
    const max=1280,s=Math.min(1,max/Math.max(X.videoWidth,X.videoHeight));
    k.width=X.videoWidth*s;
    k.height=X.videoHeight*s;
    w.width=k.width;
    w.height=k.height;
    
    X.play();
    
    const du=X.duration;
    
    // Determine if we should use smart search (for videos > 30 seconds)
    useSmartSearch = du > 30 && isFinite(du);
    
    // Handle Infinity duration specially
    if (!isFinite(du) || du <= 0) {
      log("Video has Infinity duration. Using time-based processing.");
      // Set up special time-based processing for videos with Infinity duration
      useSmartSearch = false;
      
      // Add time display to UI
      const timeDisplay = document.createElement('div');
      timeDisplay.id = 'timeDisplay';
      timeDisplay.style.position = 'absolute';
      timeDisplay.style.top = '10px';
      timeDisplay.style.left = '10px';
      timeDisplay.style.background = 'rgba(0,0,0,0.7)';
      timeDisplay.style.color = 'lime';
      timeDisplay.style.padding = '5px 10px';
      timeDisplay.style.borderRadius = '3px';
      timeDisplay.style.zIndex = '100';
      timeDisplay.textContent = '0.0s';
      p.appendChild(timeDisplay);
      
      // Update time display when video plays
      X.addEventListener('timeupdate', () => {
        timeDisplay.textContent = X.currentTime.toFixed(1) + 's';
      });
    }
    
    if (useSmartSearch) {
        log(`Using smart search for ${du.toFixed(1)}s video`);
        
        // First do sparse sampling (check every n seconds based on video length)
        const interval = du > 300 ? 10 : du > 120 ? 7 : 5;
        const samples = [];
        let t = 0;
        
        // Limit total samples to prevent memory issues
        const MAX_SAMPLES = 500;
        const adjustedInterval = Math.max(interval, du / MAX_SAMPLES);
        
        while (t < du && samples.length < MAX_SAMPLES) {
          samples.push(t);
          t += adjustedInterval;
        }
      
        // Add end frame if not included
        if (samples.length > 0 && samples.length < MAX_SAMPLES && samples[samples.length-1] < du - 1) {
          samples.push(du - 1);
        }
        
        const sampleCount = samples.length;
        log(`Initial scan: ${sampleCount} samples`);
        upd(0, sampleCount);
        
        // Process sparse samples first
        processSmartSamples(samples, 0, du);
      }
    } 
    
    if (!useSmartSearch) {
      // Regular sequential processing for shorter videos
      const fps=du>180?3:du>60?5:10,
      tf=Math.floor(du*fps),
      fi=du*1000/tf,
      bs=Math.min(100,tf);
      
      log(`${tf} frames @ ${fps}fps`);
      upd(0,tf);
      
      // Track seeking status
      let isWaitingForSeek = false;
      let lastSeekTime = 0;
    
      function batch(s,end){
        let i=s;
        Y=setInterval(()=>{
          if(M)return;
          if(i>=end||i>=tf||X.currentTime>=du){
            clearInterval(Y);
            if(i<tf&&X.currentTime<du){
              setTimeout(()=>{batch(i,Math.min(i+bs,tf));},300);
            }else{finishProc();}
            return;
          }
          
          // Add random jitter to avoid getting stuck on the same frame
          const jitter = Math.random() * 0.05;
          const t=(i*du)/tf + jitter;
          
          if(isFinite(t) && t>=0 && t<=du) {
            isWaitingForSeek = true;
            lastSeekTime = Date.now();
            X.currentTime=t;
            
            // Safety check for seek timeout
            setTimeout(() => {
              if (isWaitingForSeek && Date.now() - lastSeekTime > 2000) {
                console.warn(`Seek timeout at frame ${i}, forcing continue`);
                isWaitingForSeek = false;
                i++; // Force to next frame
              }
            }, 2000);
            
            setTimeout(()=>{
              isWaitingForSeek = false;
              proc(i,tf);
              i++;
            },100);
          } else {
            console.warn(`Bad time: ${t}, using 0`);
            X.currentTime=0;
            setTimeout(()=>{proc(i,tf);i++;},100);
          }
        },fi);
      }
      
      batch(0,bs);
    }
  };
  
  X.onerror=()=>{
    log('Video error');
    if(Y)clearInterval(Y);
    P=false;
    H.disabled=false;
    I.disabled=true;
  };
}

function processSmartSamples(samples, startIndex, totalDuration) {
  if (startIndex >= samples.length || !P) {
    // Done with sparse samples, decide next steps
    analyzeSmartResults(totalDuration);
    return;
  }
  
  const currentTime = samples[startIndex];
  X.currentTime = currentTime;
  
  X.onseeked = () => {
    // Process this frame
    processSmartFrame(currentTime);
    
    // Update progress
    upd(startIndex + 1, samples.length);
    
    // Move to next sample
    setTimeout(() => {
      processSmartSamples(samples, startIndex + 1, totalDuration);
    }, 50);
  };
}

function processSmartFrame(timePosition) {
  try {
    ctx.drawImage(X, 0, 0, k.width, k.height);
    const img = ctx.getImageData(0, 0, k.width, k.height);
    
    // Update preview
    e.src = k.toDataURL('image/jpeg', 0.7);
    
    // Process for QR code
    const q = jsQR(img.data, k.width, k.height, {inversionAttempts: "dontInvert"});
    
    if (q) {
      // Track this time position
      foundTimeRanges.push({
        time: timePosition,
        hasMetadata: false
      });
      
      // Draw marker and update visuals
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = k.width;
      tempCanvas.height = k.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(X, 0, 0, k.width, k.height);
      
      tempCtx.strokeStyle = 'lime';
      tempCtx.lineWidth = 3;
      tempCtx.beginPath();
      tempCtx.moveTo(q.location.topLeftCorner.x, q.location.topLeftCorner.y);
      tempCtx.lineTo(q.location.topRightCorner.x, q.location.topRightCorner.y);
      tempCtx.lineTo(q.location.bottomRightCorner.x, q.location.bottomRightCorner.y);
      tempCtx.lineTo(q.location.bottomLeftCorner.x, q.location.bottomLeftCorner.y);
      tempCtx.lineTo(q.location.topLeftCorner.x, q.location.topLeftCorner.y);
      tempCtx.stroke();
      
      e.src = tempCanvas.toDataURL('image/jpeg', 0.7);
      
      // Process QR data
      pQR(q.data);
      b++;
      qc.textContent = b;
      
      // Check if this is a metadata QR
      try {
        const json = JSON.parse(q.data);
        if (json.type === "metadata" || json.marker === "###QRSTART###") {
          // Mark this as containing metadata
          foundTimeRanges[foundTimeRanges.length - 1].hasMetadata = true;
        }
      } catch (e) {}
    }
    
    // Increment frame counter
    a++;
    fc.textContent = a;
  } catch (err) {
    console.error("Frame processing error:", err);
  }
}

function analyzeSmartResults(duration) {
  // If we've found metadata and chunks, focus on those areas
  if (Z && Object.keys(K).length > 0) {
    log(`Found metadata and ${Object.keys(K).length} chunks during initial scan`);
    processFocusedAreas(duration);
    return;
  }
  
  // If we've found QR codes but no metadata yet
  if (foundTimeRanges.length > 0) {
    const metadataRanges = foundTimeRanges.filter(r => r.hasMetadata);
    
    if (metadataRanges.length > 0) {
      log(`Found ${metadataRanges.length} metadata QR codes`);
      processFocusedAreas(duration);
    } else {
      log(`Found ${foundTimeRanges.length} QR codes, searching for metadata...`);
      // Search around found QR codes with higher density
      processAroundFoundCodes(duration);
    }
  } else {
    // No QR codes found in sparse sampling, fallback to full scan
    log("No QR codes found in sparse sampling, switching to full scan");
    processFullScan(duration);
  }
}

function processFocusedAreas(duration) {
  // Create time ranges from found QR positions
  if (foundTimeRanges.length === 0) {
    processFullScan(duration);
    return;
  }
  
  // Sort by time
  foundTimeRanges.sort((a, b) => a.time - b.time);
  
  // Create merged ranges with buffers
  const mergedRanges = [];
  let currentRange = {
    start: Math.max(0, foundTimeRanges[0].time - 5),
    end: Math.min(duration, foundTimeRanges[0].time + 5)
  };
  
  for (let i = 1; i < foundTimeRanges.length; i++) {
    const currentTime = foundTimeRanges[i].time;
    
    // If this time is within or close to current range, extend it
    if (currentTime <= currentRange.end + 10) { // 10 second merge buffer
      currentRange.end = Math.min(duration, currentTime + 5);
    } else {
      // Save current range and start a new one
      mergedRanges.push(currentRange);
      currentRange = {
        start: Math.max(0, currentTime - 5),
        end: Math.min(duration, currentTime + 5)
      };
    }
  }
  
  // Add the last range
  mergedRanges.push(currentRange);
  
  log(`Processing ${mergedRanges.length} focused time ranges`);
  
  // Process these ranges with higher framerate
  processFocusedRanges(mergedRanges, duration);
}

function processFocusedRanges(ranges, duration) {
  if (!ranges || ranges.length === 0) {
    processFullScan(duration);
    return;
  }
  
  // Process each range sequentially
  const range = ranges.shift();
  const rangeDuration = range.end - range.start;
  
  // Use higher framerate for focused areas
  const fps = 15; 
  const frames = Math.ceil(rangeDuration * fps);
  const timeStep = rangeDuration / frames;
  
  log(`Processing range ${range.start.toFixed(1)}s - ${range.end.toFixed(1)}s (${frames} frames)`);
  
  const timePoints = [];
  for (let i = 0; i < frames; i++) {
    timePoints.push(range.start + i * timeStep);
  }
  
  // Define a function to process each point
  let currentIndex = 0;
  
  function processNextPoint() {
    if (currentIndex >= timePoints.length || !P) {
      // Done with this range
      if (ranges.length > 0) {
        // Process next range
        processFocusedRanges(ranges, duration);
      } else {
        // Check if we've found all chunks
        const tc = Z ? Z.total_chunks || 0 : 0;
        const rc = Object.keys(K).length;
        
        if (Z && rc === tc) {
          log(`All ${tc} chunks found! Processing complete.`);
          finishProc();
        } else {
          log(`Found ${rc}/${tc || '?'} chunks. Proceeding to full scan.`);
          processFullScan(duration);
        }
      }
      return;
    }
    
    // Process this time point
    X.currentTime = timePoints[currentIndex];
    
    X.onseeked = () => {
      // Process this frame
      processSmartFrame(timePoints[currentIndex]);
      
      // Update progress (scale to show overall progress through the ranges)
      const rangeProgress = (currentIndex / timePoints.length) * 100;
      const overallProgress = Math.min(75, 50 + (rangeProgress / 100) * 25); // 50-75%
      o.style.width = `${overallProgress}%`;
      o.textContent = `${Math.round(overallProgress)}%`;
      
      // Move to next point
      currentIndex++;
      setTimeout(processNextPoint, 30);
    };
  }
  
  // Start processing
  processNextPoint();
}

function processAroundFoundCodes(duration) {
  // Expand areas around found QR codes to look for metadata
  if (foundTimeRanges.length === 0) {
    processFullScan(duration);
    return;
  }
  
  // Create expanded ranges - look before each QR code as metadata often comes first
  const expandedRanges = foundTimeRanges.map(r => ({
    start: Math.max(0, r.time - 15), // Look 15 seconds before
    end: Math.min(duration, r.time + 5)  // And 5 seconds after
  }));
  
  log(`Searching around ${expandedRanges.length} QR codes for metadata`);
  processFocusedRanges(expandedRanges, duration);
}

function processFullScan(duration) {
  // Final fallback - scan the entire video
  const fps = duration > 180 ? 3 : duration > 60 ? 5 : 10;
  const tf = Math.floor(duration * fps);
  const fi = duration * 1000 / tf;
  const bs = Math.min(100, tf);
  
  log(`Full scan: ${tf} frames @ ${fps}fps`);
  
  // Set up regular batch processing
  X.play();
  
  // Track seeking status
  let isWaitingForSeek = false;
  let lastSeekTime = 0;
  
  function batch(s, end) {
    let i = s;
    Y = setInterval(() => {
      if (M) return;
      if (i >= end || i >= tf || X.currentTime >= duration) {
        clearInterval(Y);
        if (i < tf && X.currentTime < duration) {
          setTimeout(() => { batch(i, Math.min(i + bs, tf)); }, 300);
        } else {
          finishProc();
        }
        return;
      }
      
      // Add random jitter to avoid getting stuck
      const jitter = Math.random() * 0.05;
      const t = (i * duration / tf) + jitter;
      
      if (isFinite(t) && t >= 0 && t <= duration) {
        isWaitingForSeek = true;
        lastSeekTime = Date.now();
        X.currentTime = t;
        
        // Safety check for seek timeout
        setTimeout(() => {
          if (isWaitingForSeek && Date.now() - lastSeekTime > 2000) {
            console.warn(`Seek timeout at frame ${i}, forcing continue`);
            isWaitingForSeek = false;
            i++; // Force to next frame
          }
        }, 2000);
        
        setTimeout(() => {
          isWaitingForSeek = false;
          proc(i, tf);
          i++;
        }, 100);
      } else {
        console.warn(`Bad time: ${t}, using 0`);
        X.currentTime = 0;
        setTimeout(() => { proc(i, tf); i++; }, 100);
      }
    }, fi);
  }
  
  batch(0, bs);
}

function proc(i,t){
  try {
    ctx.drawImage(X,0,0,k.width,k.height);
    const img=ctx.getImageData(0,0,k.width,k.height);
    
    // Always update preview frame for better visibility
    e.src=k.toDataURL('image/jpeg',0.7);
    
    // Draw a crosshair on the preview to help identify QR codes
    const img2 = new Image();
    img2.onload = function() {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = k.width;
      tempCanvas.height = k.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(img2, 0, 0);
      
      // Attempt QR detection
      try{
        const q=jsQR(img.data,k.width,k.height,{inversionAttempts:"dontInvert"});
        if(q){
          // Draw marker if QR found
          tempCtx.strokeStyle = 'lime';
          tempCtx.lineWidth = 3;
          tempCtx.beginPath();
          tempCtx.moveTo(q.location.topLeftCorner.x, q.location.topLeftCorner.y);
          tempCtx.lineTo(q.location.topRightCorner.x, q.location.topRightCorner.y);
          tempCtx.lineTo(q.location.bottomRightCorner.x, q.location.bottomRightCorner.y);
          tempCtx.lineTo(q.location.bottomLeftCorner.x, q.location.bottomLeftCorner.y);
          tempCtx.lineTo(q.location.topLeftCorner.x, q.location.topLeftCorner.y);
          tempCtx.stroke();
          
          // Process QR data
          pQR(q.data);
          b++;
          qc.textContent=b;
          
          // Update preview with QR marker
          e.src = tempCanvas.toDataURL('image/jpeg', 0.7);
        }
      }catch(err){}
    };
    img2.src = e.src;
  } catch(err) {
    console.error("Frame processing error:", err);
  }
  
  a++;fc.textContent=a;upd(a,t);
}

function pQR(data){
  try{
    const j=JSON.parse(data);
    
    if(j.type==="metadata"){
      Z=j;
      log(`File: ${j.file_name}`);
      J.disabled=true;
    }
    else if(j.type==="set_header"){
      if(!L[j.set_index]){
        L[j.set_index]={
          chunks_expected:j.chunks_in_set,
          chunks_received:0,
          chunks:{}
        };
      }
    }
    else if(j.type==="chunk"){
      if(!Z)return;
      
      const si=j.set_index,ci=j.chunk_index,ck=`${si}_${ci}`;
      
      if(K[ck])return;
      
      K[ck]=j.data;
      d++;
      cc.textContent=d;
      
      if(!L[si]){
        L[si]={
          chunks_expected:Z.chunks_per_set||0,
          chunks_received:0,
          chunks:{}
        };
      }
      
      L[si].chunks[ci]=1;
      L[si].chunks_received=Object.keys(L[si].chunks).length;
      
      checkDone();
    }
  }catch(e){}
}

function checkDone(){
  if(!Z)return;
  
  const tc=Z.total_chunks||Object.keys(L).reduce((a,k)=>a+L[k].chunks_expected,0),
  rc=Object.keys(K).length;
  
  if(rc>0){
    J.disabled=false;
    
    // Log progress every 5 chunks or when we reach multiples of 25%
    if(rc % 5 === 0 || rc/tc >= 0.25 && rc/tc <= 0.26 || rc/tc >= 0.5 && rc/tc <= 0.51 || 
       rc/tc >= 0.75 && rc/tc <= 0.76 || rc/tc === 1) {
      log(`Progress: ${rc}/${tc} chunks (${Math.round(rc/tc*100)}%)`);
    }
  }
  
  if(rc===tc){
    log('All chunks received!');
    if(Y){
      clearInterval(Y);
      P=false;
      H.disabled=!U;
      I.disabled=true;
    }
  }
}

function togglePause(){
  M=!M;
  I.textContent=M?'Resume':'Pause';
}

function finishProc(){
  if(Y){clearInterval(Y);Y=null;}
  P=false;
  log('Processing done');
  H.disabled=!U;
  I.disabled=true;
  
  const tc=Z?Z.total_chunks:0,
  rc=Object.keys(K).length;
  
  if(rc>0){
    log(`Processed ${a} frames, found ${b} QR codes`);
    log(`Got ${rc}/${tc} chunks (${Math.round(rc/tc*100)}%)`);
    J.disabled=false;
    
    // If we didn't get all chunks and have a file to process, offer to continue
    if(rc < tc && U) {
      log(`Missing ${tc-rc} chunks. Try different sections of the video.`);
      setTimeout(() => {
        if(confirm(`Missing ${tc-rc} chunks. Continue processing?`)) {
          startProc();
        }
      }, 500);
    }
  }
  
  clean();
}

function saveFile(){
  if(!Z||!Object.keys(K).length)return;
  
  try{
    const sc=[];
    
    for(let si=1;si<=Z.total_sets;si++){
      const s=L[si];
      if(!s)continue;
      
      for(let ci=1;ci<=s.chunks_expected;ci++){
        const ck=`${si}_${ci}`;
        K[ck]&&sc.push(K[ck]);
      }
    }
    
    const b64=sc.join(''),
    bin=atob(b64),
    ua=new Uint8Array(bin.length);
    
    for(let i=0;i<bin.length;i++)ua[i]=bin.charCodeAt(i);
    
    const b=new Blob([ua],{type:'application/octet-stream'}),
    url=URL.createObjectURL(b),
    a=document.createElement('a');
    
    a.href=url;
    a.download=Z.file_name;
    a.click();
    
    setTimeout(()=>URL.revokeObjectURL(url),100);
    log(`File saved: ${Z.file_name}`);
  }catch(e){log(`Save error: ${e.message}`);}
}

// Tap to play
v.addEventListener('click',()=>{
  if(v.paused&&S)v.play().catch(()=>{});
});

// Event listeners
A.addEventListener('click',startCam);
B.addEventListener('click',stopCam);
C.addEventListener('click',startRec);
D.addEventListener('click',stopRec);
E.addEventListener('click',saveRec);
F.addEventListener('click',()=>f.click());
G.addEventListener('click',toggleUrl);
f.addEventListener('change',e=>loadFile(e.target.files[0]));
u.addEventListener('keypress',e=>{e.key==='Enter'&&fetchUrl();});
u.addEventListener('blur',()=>{u.value.trim()===''&&(u.style.display='none');});
H.addEventListener('click',startProc);
I.addEventListener('click',togglePause);
J.addEventListener('click',saveFile);

log('Ready - Click "Cam"');
</script>
</body>
</html>