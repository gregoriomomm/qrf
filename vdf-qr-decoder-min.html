<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>QR Code File Decoder</title><style>:root {
--primary-color: #2563eb;
--secondary-color: #1d4ed8;
--success-color: #10b981;
--warning-color: #f59e0b;
--error-color: #ef4444;
--text-color: #1f2937;
--bg-color: #f9fafb;
--panel-bg: #ffffff;
--border-color: #e5e7eb;
}
* {
box-sizing: border-box;
margin: 0;
padding: 0;
}
body {
font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
line-height: 1.5;
color: var(--text-color);
background-color: var(--bg-color);
padding: 20px;
max-width: 1200px;
margin: 0 auto;
}
h1,
h2 {
margin-bottom: 1rem;
}
button {
background-color: var(--primary-color);
color: white;
border: none;
padding: 8px 16px;
border-radius: 4px;
cursor: pointer;
font-weight: 500;
transition: background-color 0.2s;
}
button:hover {
background-color: var(--secondary-color);
}
button:disabled {
background-color: #9ca3af;
cursor: not-allowed;
}
input[type="file"] {
margin-right: 10px;
}
.control-panel {
display: flex;
justify-content: space-between;
align-items: center;
background-color: var(--panel-bg);
padding: 15px;
border-radius: 8px;
box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
margin-bottom: 20px;
}
.controls {
display: flex;
gap: 10px;
}
.video-container {
position: relative;
background-color: var(--panel-bg);
padding: 15px;
border-radius: 8px;
box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
margin-bottom: 20px;
}
video {
width: 100%;
max-height: 400px;
background-color: #000;
border-radius: 4px;
}
canvas {
position: absolute;
top: 15px;
left: 15px;
pointer-events: none;
}
.progress-container {
margin-top: 10px;
}
.progress-bar {
height: 10px;
background-color: var(--primary-color);
width: 0%;
border-radius: 5px;
transition: width 0.3s ease;
}
.progress-text {
font-size: 14px;
margin-top: 5px;
text-align: right;
}
.chunks-container {
background-color: var(--panel-bg);
padding: 15px;
border-radius: 8px;
box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
margin-bottom: 20px;
}
.chunks-grid {
display: grid;
grid-template-columns: repeat(auto-fill, minmax(20px, 1fr));
gap: 4px;
margin-top: 10px;
}
.chunk {
height: 20px;
background-color: rgba(229, 231, 235, 0.5);
border: 1px solid var(--border-color);
border-radius: 2px;
transition: background-color 0.3s;
}
.chunk.pending {
background-color: rgba(229, 231, 235, 0.5);
}
.chunk.received {
background-color: rgba(16, 185, 129, 0.2);
border-color: var(--success-color);
}
.chunk.blinking {
animation: blink 0.5s;
}
@keyframes blink {
0% {
background-color: rgba(245, 158, 11, 0.5);
}
100% {
background-color: rgba(16, 185, 129, 0.2);
}
}
.file-info-container {
background-color: var(--panel-bg);
padding: 15px;
border-radius: 8px;
box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
margin-bottom: 20px;
}
#downloadContainer {
margin-top: 15px;
}
#downloadBtn {
background-color: var(--success-color);
}
#downloadBtn:hover {
background-color: #0d9668;
}
.debug-container {
background-color: var(--panel-bg);
padding: 15px;
border-radius: 8px;
box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}
.log-controls {
display: flex;
gap: 8px;
margin-bottom: 10px;
}
.log-filter {
background-color: #e5e7eb;
color: var(--text-color);
font-size: 12px;
padding: 4px 8px;
}
.log-filter.active {
background-color: var(--primary-color);
color: white;
}
.log-window {
height: 200px;
overflow-y: auto;
border: 1px solid var(--border-color);
border-radius: 4px;
padding: 10px;
font-family: monospace;
font-size: 13px;
background-color: #f1f5f9;
}
.log-entry {
margin-bottom: 4px;
border-bottom: 1px solid rgba(229, 231, 235, 0.5);
padding-bottom: 4px;
}
.log-debug {
color: #6b7280;
}
.log-info {
color: #1d4ed8;
}
.log-warn {
color: #b45309;
}
.log-error {
color: #b91c1c;
}
.modal {
display: none;
position: fixed;
z-index: 1000;
left: 0;
top: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.5);
}
.modal-content {
background-color: var(--panel-bg);
margin: 10% auto;
padding: 20px;
border-radius: 8px;
max-width: 500px;
box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
position: relative;
}
.close {
position: absolute;
right: 15px;
top: 10px;
font-size: 24px;
cursor: pointer;
}
.settings-group {
margin-bottom: 15px;
}
.settings-group label {
display: block;
margin-bottom: 5px;
}
.settings-group input {
width: 100%;
padding: 8px;
border: 1px solid var(--border-color);
border-radius: 4px;
}
#saveSettingsBtn {
margin-top: 10px;
}
.error-message {
background-color: #fef2f2;
border-left: 4px solid var(--error-color);
padding: 15px;
margin-bottom: 20px;
color: #b91c1c;
display: none;
}
#resetBtn {
background-color: var(--warning-color);
}
#resetBtn:hover {
background-color: #e08c00;
}
.scan-line {
position: absolute;
height: 2px;
background-color: rgba(16, 185, 129, 0.8);
animation: scan-animation 2s infinite;
}
@keyframes scan-animation {
0% {
opacity: 0.5;
}
50% {
opacity: 1;
}
100% {
opacity: 0.5;
}
}
@media (max-width: 768px) {
.control-panel {
flex-direction: column;
align-items: flex-start;
}
.controls {
margin-top: 10px;
width: 100%;
flex-wrap: wrap;
}
video {
max-height: 300px;
}
.chunks-grid {
grid-template-columns: repeat(auto-fill, minmax(15px, 1fr));
}
.chunk {
height: 15px;
}
}</style></head><body><div id="errorMessage" class="error-message"></div><header class="control-panel"><h1>QR Code File Decoder</h1><div class="controls"><input type="file" id="videoInput" accept="video false,
undefined)
.then(decodedText => {
this.detectionStats.successes++;
const isDuplicate = this.checkDuplicate(decodedText, frameIndex);
if (isDuplicate) {
this.detectionStats.duplicates++;
resolve({
success: false,
isDuplicate: true,
frameIndex: frameIndex
});
} else {
this.addToRecentlySeen(decodedText, frameIndex);
this.detectionStats.lastDetectedFrameIndex = frameIndex;
if (this.detectionStats.successes % 10 === 0) {
console.log(`QR detection stats: ${this.detectionStats.successes}/${this.detectionStats.attempts} successful (${this.detectionStats.duplicates} duplicates)`);
}
const lastResult = this.html5QrCode._lastScanResult || null;
resolve({
success: true,
qrData: decodedText,
frameIndex: frameIndex,
bounds: this.estimateBounds({
result: lastResult,
imageData: imageData
})
});
}
})
.catch(error => {
this.detectionStats.failures++;
resolve({
success: false,
frameIndex: frameIndex
});
});
} catch (error) {
this.detectionStats.failures++;
if (this.onError) {
this.onError(error);
}
resolve({
success: false,
frameIndex: frameIndex
});
}
});
}
checkDuplicate(qrData, frameIndex) {
if (this.recentlySeenQRs.has(qrData)) {
const lastSeenFrame = this.recentlySeenQRs.get(qrData);
return (frameIndex - lastSeenFrame) < 5;
}
return false;
}
addToRecentlySeen(qrData, frameIndex) {
this.recentlySeenQRs.set(qrData, frameIndex);
if (this.recentlySeenQRs.size > this.maxCacheSize) {
const entries = Array.from(this.recentlySeenQRs.entries());
entries.sort((a, b) => a[1] - b[1]);
const entriesToRemove = Math.ceil(this.maxCacheSize * 0.2);
for (let i = 0; i < entriesToRemove; i++) {
if (entries[i]) {
this.recentlySeenQRs.delete(entries[i][0]);
}
}
}
}
estimateBounds(decodedResult) {
if (decodedResult && decodedResult.result && decodedResult.result.location) {
const loc = decodedResult.result.location;
const xValues = [loc.topLeft.x, loc.topRight.x, loc.bottomLeft.x, loc.bottomRight.x];
const yValues = [loc.topLeft.y, loc.topRight.y, loc.bottomLeft.y, loc.bottomRight.y];
const minX = Math.min(...xValues);
const maxX = Math.max(...xValues);
const minY = Math.min(...yValues);
const maxY = Math.max(...yValues);
const width = maxX - minX;
const height = maxY - minY;
const size = Math.max(width, height);
const centerX = (minX + maxX) / 2;
const centerY = (minY + maxY) / 2;
return {
x: centerX - size / 2,
y: centerY - size / 2,
width: size,
height: size
};
}
const imageData = decodedResult.imageData || {
width: 300,
height: 300
};
const centerX = imageData.width / 2;
const centerY = imageData.height / 2;
const size = Math.min(imageData.width, imageData.height) / 2.5;
return {
x: centerX - size / 2,
y: 0,
width: size,
height: size
};
}
dataURLtoFile(dataurl, filename) {
const arr = dataurl.split(',');
const mime = arr[0].match(/:(.*?);/)[1];
const bstr = atob(arr[1]);
let n = bstr.length;
const u8arr = new Uint8Array(n);
while (n--) {
u8arr[n] = bstr.charCodeAt(n);
}
return new File([u8arr], filename, { type: mime });
}
dispose() {
if (this.html5QrCode) {
try {
this.html5QrCode.clear();
} catch (error) {
console.error("Error clearing HTML5QRCode", error);
}
}
if (this.qrElement && this.qrElement.parentNode) {
this.qrElement.parentNode.removeChild(this.qrElement);
}
console.log(`QR processor disposed. Final stats: ${JSON.stringify(this.detectionStats)}`);
}
}
class QRFileDecoder {
constructor() {
this.logger = new Logger('logWindow');
this.ui = new UI(this.logger);
this.videoProcessor = null;
this.qrProcessor = null;
this.packetProcessor = null;
this.fountainDecoder = null;
this.isProcessing = false;
this.videoFile = null;
this.metadataReceived = false;
this.fileMetadata = null;
this.recoveredChunks = new Map();
this.missingChunks = new Set();
this.wakeLock = null;
this.settings = {
workerCount: 4,
packetWorkerCount: 2,
frameInterval: 20,
qrDetectionConfidence: 0.5
};
this.discoveryMode = false;
this.discoveredFiles = new Map();
this.currentActiveFile = null;
this.downloadedFiles = new Set();
this.qrCodesDetected = 0;
this.packetsProcessed = 0;
this.recoveredFileData = null;
this.checkCompatibility();
this.initEventListeners();
this.logger.info("QR File Decoder initialized");
}
checkCompatibility() {
const isWebCodecsSupported = EnhancedVideoProcessor.isWebCodecsSupported();
if (!isWebCodecsSupported) {
this.ui.showErrorMessage("WebCodecs API is not supported in your browser. Please use Chrome 94+, Edge 94+, or another compatible browser.");
document.getElementById('startScanBtn').disabled = true;
}
if (typeof Html5Qrcode === 'undefined') {
this.ui.showErrorMessage("HTML5QRCode library is not available. Please check your internet connection and reload the page.");
document.getElementById('startScanBtn').disabled = true;
}
}
resetContents() {
if (this.isProcessing) {
this.stopProcessing();
}
if (this.qrProcessor) {
this.qrProcessor.dispose();
this.qrProcessor = null;
}
if (this.videoProcessor) {
this.videoProcessor.stopProcessing();
this.videoProcessor = null;
}
this.metadataReceived = false;
this.fileMetadata = null;
this.recoveredChunks = new Map();
this.missingChunks = new Set();
this.qrCodesDetected = 0;
this.packetsProcessed = 0;
this.recoveredFileData = null;
this.downloadedFiles = new Set();
this.discoveredFiles = new Map();
this.ui.resetChunkGrid();
this.ui.updateFileInfo("No file detected yet");
document.getElementById('missingChunks').textContent = "Waiting for metadata...";
document.getElementById('scanProgressBar').style.width = '0%';
document.getElementById('scanProgressText').textContent = 'Frames: 0/0 | Time Remaining: --:-- | Loop: 1';
document.getElementById('downloadContainer').style.display = 'none';
document.getElementById('continueBtn').disabled = true;
this.ui.clearQRHighlight();
this.ui.hideErrorMessage();
document.getElementById('startScanBtn').disabled = this.videoFile ? false : true;
document.getElementById('discoverBtn').disabled = this.videoFile ? false : true;
this.logger.info("Contents completely reset, ready for new scan");
}
initEventListeners() {
document.getElementById('videoInput').addEventListener('change', this.handleVideoInput.bind(this));
document.getElementById('startScanBtn').addEventListener('click', this.startScanAndDiscover.bind(this));
document.getElementById('continueBtn').addEventListener('click', this.continueProcessing.bind(this));
document.getElementById('stopScanBtn').addEventListener('click', this.stopProcessing.bind(this));
document.getElementById('downloadBtn').addEventListener('click', this.downloadFile.bind(this));
document.getElementById('settingsBtn').addEventListener('click', this.ui.showSettingsModal.bind(this.ui));
document.getElementById('saveSettingsBtn').addEventListener('click', this.saveSettings.bind(this));
document.getElementById('clearLogBtn').addEventListener('click', this.logger.clear.bind(this.logger));
document.getElementById('copyLogBtn').addEventListener('click', this.copyDebugLog.bind(this));
document.querySelectorAll('.log-filter').forEach(btn => {
btn.addEventListener('click', (e) => {
this.logger.setFilter(e.target.dataset.level);
this.ui.updateLogFilterButtons(e.target);
});
});
document.querySelector('.modal .close').addEventListener('click', this.ui.hideSettingsModal.bind(this.ui));
document.getElementById('resetBtn').addEventListener('click', this.resetContents.bind(this));
}
async handleVideoInput(event) {
if (!event.target.files || event.target.files.length === 0) {
return;
}
this.videoFile = event.target.files[0];
this.logger.info(`Video file selected: ${this.videoFile.name} (${this.formatFileSize(this.videoFile.size)})`);
try {
const videoUrl = URL.createObjectURL(this.videoFile);
const videoElement = document.getElementById('videoPreview');
videoElement.src = videoUrl;
videoElement.onloadedmetadata = () => {
document.getElementById('startScanBtn').disabled = false;
if (this.metadataReceived && this.recoveredChunks.size < this.fileMetadata.chunksCount) {
document.getElementById('continueBtn').disabled = false;
}
this.logger.info(`Video duration: ${videoElement.duration.toFixed(2)} seconds`);
};
} catch (error) {
this.logger.error(`Error loading video: ${error.message}`);
this.ui.showErrorMessage(`Error loading video: ${error.message}`);
}
}
async requestWakeLock() {
try {
if ('wakeLock' in navigator) {
this.wakeLock = await navigator.wakeLock.request('screen');
this.logger.info('Screen wake lock activated - screen will stay awake');
this.wakeLock.addEventListener('release', () => {
this.logger.info('Screen wake lock released');
});
}
} catch (err) {
this.logger.warn(`Wake lock failed: ${err.message}`);
}
}
releaseWakeLock() {
if (this.wakeLock) {
this.wakeLock.release();
this.wakeLock = null;
this.logger.info('Screen wake lock released manually');
}
}
async startProcessing() {
if (!this.videoFile) {
this.logger.warn("No video file selected");
return;
}
if (this.isProcessing) {
this.logger.warn("Processing already in progress");
return;
}
this.isProcessing = true;
await this.requestWakeLock();
this.metadataReceived = false;
this.recoveredChunks.clear();
this.missingChunks.clear();
this.qrCodesDetected = 0;
this.packetsProcessed = 0;
this.recoveredFileData = null;
document.getElementById('startScanBtn').disabled = true;
document.getElementById('continueBtn').disabled = true;
document.getElementById('stopScanBtn').disabled = false;
document.getElementById('downloadContainer').style.display = 'none';
this.ui.resetChunkGrid();
this.ui.updateFileInfo("Processing video...");
this.ui.clearQRHighlight();
this.ui.hideErrorMessage();
this.logger.info("Starting video processing");
try {
await this.initializeComponents();
await this.videoProcessor.initialize(this.videoFile);
this.videoProcessor.startProcessing();
this.logger.info("Processing started");
} catch (error) {
this.logger.error(`Failed to start processing: ${error.message}`);
this.ui.showErrorMessage(`Failed to start processing: ${error.message}`);
this.stopProcessing();
}
}
async initializeComponents() {
this.qrProcessor = new EnhancedQRProcessor({
onQrDetected: this.handleQRCodeResult.bind(this),
onError: (error) => this.logger.error(`QR processing error: ${error.message}`),
detectionConfidence: this.settings.qrDetectionConfidence
});
await this.qrProcessor.initialize();
this.packetProcessor = new PacketProcessor();
this.fountainDecoder = new EnhancedFountainDecoder();
this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this));
this.videoProcessor = new EnhancedVideoProcessor({
frameCallback: this.handleVideoFrame.bind(this),
progressCallback: this.ui.updateProgress.bind(this.ui),
errorCallback: (error) => this.logger.error(`Video processing error: ${error.message}`),
frameInterval: this.settings.frameInterval
});
this.videoProcessor.isFileComplete = () => {
return this.metadataReceived &&
this.fileMetadata &&
this.recoveredChunks.size >= this.fileMetadata.chunksCount;
};
}
async continueProcessing() {
if (this.isProcessing) return;
this.logger.info("Continuing video processing with additional loops...");
if (!this.qrProcessor) {
this.logger.info("Reinitializing QR processor for continue...");
this.qrProcessor = new EnhancedQRProcessor({
onQrDetected: this.handleQRCodeResult.bind(this),
onError: (error) => this.logger.error(`QR processing error: ${error.message}`),
detectionConfidence: this.settings.qrDetectionConfidence
});
await this.qrProcessor.initialize();
}
if (this.videoProcessor && this.videoFile) {
this.isProcessing = true;
this.videoProcessor.loopCount = (this.videoProcessor.loopCount || 1) + 1;
this.videoProcessor.isProcessing = true;
this.videoProcessor.frameInterval = Math.max(this.videoProcessor.frameInterval / 2, 1);
console.log(`🔄 Manual continue: Starting loop ${this.videoProcessor.loopCount} with ${this.videoProcessor.frameInterval}ms interval`);
const loopInfo = document.getElementById('loopInfo');
if (loopInfo) {
loopInfo.textContent = `Status: Manual continue - loop ${this.videoProcessor.loopCount} with faster frame rate...`;
}
this.videoProcessor.videoElement.currentTime = 0;
this.videoProcessor.videoElement.play().then(() => {
console.log(`✅ Manual continue: Video restarted, resuming processing...`);
if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
this.videoProcessor.processWithVideoFrameCallback();
} else {
if (this.videoProcessor.processTimer) {
clearInterval(this.videoProcessor.processTimer);
}
this.videoProcessor.processTimer = setInterval(() => {
this.videoProcessor.processCurrentFrame();
}, this.videoProcessor.frameInterval);
}
}).catch(err => {
console.error('Failed to continue video processing:', err);
this.isProcessing = false;
});
document.getElementById('startScanBtn').disabled = true;
document.getElementById('continueBtn').disabled = true;
document.getElementById('stopScanBtn').disabled = false;
} else {
this.logger.error("Cannot continue - video processor or file not available");
}
}
async startScanAndDiscover() {
if (this.isProcessing) return;
this.logger.info("Starting scan with automatic file discovery...");
this.discoveryMode = true;
this.discoveredFiles.clear();
this.isProcessing = true;
this.ui.resetChunkGrid();
this.ui.updateFileInfo("Scanning video and discovering files...");
document.getElementById('discoveredFilesContainer').style.display = 'none';
document.getElementById('startScanBtn').disabled = true;
document.getElementById('continueBtn').disabled = true;
document.getElementById('stopScanBtn').disabled = false;
try {
await this.initializeComponents();
await this.videoProcessor.initialize(this.videoFile);
this.videoProcessor.discoveryMode = true;
this.videoProcessor.startProcessing();
this.logger.info("First loop started - discovering files and capturing chunks simultaneously");
} catch (error) {
this.logger.error(`Failed to start processing: ${error.message}`);
this.ui.showErrorMessage(`Failed to start processing: ${error.message}`);
this.stopProcessing();
}
}
startFileProcessing(filename, startTime) {
if (this.isProcessing) return;
this.logger.info(`Starting focused processing for file: ${filename} at ${startTime.toFixed(2)}s`);
this.currentActiveFile = filename;
this.metadataReceived = false;
this.fileMetadata = null;
this.recoveredChunks = new Map();
this.missingChunks = new Set();
if (this.fountainDecoder) {
this.fountainDecoder = new EnhancedFountainDecoder();
this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this));
}
if (this.videoProcessor) {
this.videoProcessor.videoElement.currentTime = startTime;
this.videoProcessor.discoveryMode = false;
this.isProcessing = true;
this.videoProcessor.isProcessing = true;
this.videoProcessor.loopCount = 1;
document.getElementById('startScanBtn').disabled = true;
document.getElementById('discoverBtn').disabled = true;
document.getElementById('continueBtn').disabled = true;
document.getElementById('stopScanBtn').disabled = false;
this.ui.updateFileInfo(`Processing file: ${filename}`);
this.ui.resetChunkGrid();
this.videoProcessor.videoElement.play();
}
}
stopProcessing() {
if (!this.isProcessing) return;
console.log(`🛑 Stop button pressed - halting all processing`);
this.isProcessing = false;
this.discoveryMode = false;
this.releaseWakeLock();
if (this.videoProcessor) {
this.videoProcessor.stopProcessing();
this.videoProcessor.discoveryMode = false;
this.videoProcessor.rangeMode = false;
}
this.ui.clearQRHighlight();
document.getElementById('startScanBtn').disabled = false;
document.getElementById('stopScanBtn').disabled = true;
if (this.metadataReceived &&
this.recoveredChunks.size < this.fileMetadata.chunksCount &&
this.videoFile &&
this.videoProcessor) {
document.getElementById('continueBtn').disabled = false;
this.logger.info("Continue button enabled - you can resume processing");
}
if (this.videoFile) {
const discoverBtn = document.getElementById('discoverBtn');
if (discoverBtn) {
discoverBtn.disabled = false;
}
}
this.logger.info("All processing stopped - use Continue to resume or Start Scan & Discover to restart");
this.logger.info(`Processing summary: Detected ${this.qrCodesDetected} QR codes, processed ${this.packetsProcessed} packets`);
if (this.metadataReceived) {
const progress = this.fountainDecoder.getRecoveryProgress();
this.logger.info(`File recovery progress: ${progress.recovered}/${progress.total} chunks (${progress.percentage}%)`);
if (progress.packetStats) {
this.logger.info(`Packet statistics: ${JSON.stringify(progress.packetStats)}`);
}
}
}
async handleVideoFrame(imageData, timestamp, frameIndex) {
if (!this.isProcessing) return;
try {
const result = await this.qrProcessor.processFrame(imageData, frameIndex);
if (result.success) {
this.qrCodesDetected++;
if (result.bounds) {
this.ui.drawQRHighlight(
result.bounds.x,
result.bounds.y,
result.bounds.width,
result.bounds.height
);
this.logger.info(`QR code detected in frame ${frameIndex} at position [${result.bounds.x.toFixed(0)}, ${result.bounds.y.toFixed(0)}]`);
} else {
this.logger.info(`QR code detected in frame ${frameIndex}`);
}
this.handleQRCodeResult(result);
} else if (result.isDuplicate) {
} else {
this.ui.clearQRHighlight();
}
} catch (error) {
this.logger.error(`Error processing frame ${frameIndex}: ${error.message}`);
}
}
handleQRCodeResult(result) {
if (!result.success) {
return;
}
const { qrData, frameIndex } = result;
this.logger.debug(`QR code detected in frame ${frameIndex}: ${qrData.substring(0, 30)}...`);
const packetResult = this.packetProcessor.processQRData(qrData, frameIndex);
if (packetResult.success) {
this.handlePacketResult(packetResult);
} else {
this.logger.warn(`Failed to process QR data: ${packetResult.error}`);
}
}
handlePacketResult(result) {
if (!result.success) {
this.logger.warn(`Failed to process packet: ${result.error}`);
return;
}
this.packetsProcessed++;
const { packetType, packetData } = result;
if (packetType === 'metadata') {
const currentTime = this.videoProcessor ? this.videoProcessor.videoElement.currentTime : 0;
this.handleMetadataPacket(packetData, currentTime);
} else if (packetType === 'data') {
this.handleDataPacket(packetData);
}
}
handleMetadataPacket(metadata, currentTime = 0) {
const fileName = metadata.fileName;
if (this.discoveryMode) {
console.log(`🔍 DISCOVERY: Processing metadata for ${fileName} at ${currentTime.toFixed(2)}s`);
if (!this.discoveredFiles.has(fileName)) {
this.discoveredFiles.set(fileName, {
metadata: metadata,
firstSeenAt: currentTime,
lastSeenAt: currentTime
});
this.logger.info(`📁 DISCOVERY: NEW file found: ${fileName} at ${currentTime.toFixed(2)}s`);
this.switchToFile(metadata, fileName);
} else {
const fileInfo = this.discoveredFiles.get(fileName);
fileInfo.lastSeenAt = currentTime;
this.logger.debug(`📁 DISCOVERY: Existing file ${fileName} seen again at ${currentTime.toFixed(2)}s`);
if (!this.currentActiveFile || this.currentActiveFile !== fileName) {
this.logger.info(`🔄 DISCOVERY: Switching from ${this.currentActiveFile || 'none'} to ${fileName}`);
this.switchToFile(metadata, fileName);
} else {
this.logger.debug(`📁 DISCOVERY: Duplicate metadata for current file ${fileName}`);
return;
}
}
this.updateDiscoveredFilesUI();
return;
}
if (this.metadataReceived) {
if (metadata.fileName === this.fileMetadata.fileName &&
metadata.fileSize === this.fileMetadata.fileSize &&
metadata.chunksCount === this.fileMetadata.chunksCount) {
this.logger.debug("Received duplicate metadata packet");
return;
} else {
this.logger.warn("Received metadata for a different file, reinitializing");
}
}
this.metadataReceived = true;
this.fileMetadata = metadata;
this.ui.initializeChunkGrid(metadata.chunksCount);
this.ui.updateFileInfo(`
<div><strong>File Name:</strong> ${metadata.fileName}</div><div><strong>File Type:</strong> ${metadata.fileType}</div><div><strong>File Size:</strong> ${this.formatFileSize(metadata.fileSize)}</div><div><strong>Chunks:</strong> ${metadata.chunksCount}</div><div><strong>Protocol Version:</strong> ${metadata.protocolVersion}</div>
`);
if (metadata.fileChecksum || metadata.metaChecksum) {
const fileChecksumElement = document.getElementById('fileChecksum');
const metaChecksumElement = document.getElementById('metaChecksum');
const checksumInfoElement = document.getElementById('checksumInfo');
if (fileChecksumElement) fileChecksumElement.textContent = metadata.fileChecksum || '-';
if (metaChecksumElement) metaChecksumElement.textContent = metadata.metaChecksum || '-';
if (checksumInfoElement) checksumInfoElement.style.display = 'block';
}
this.fountainDecoder.initialize(metadata);
for (let i = 0; i < metadata.chunksCount; i++) {
this.missingChunks.add(i);
}
this.updateMissingChunksUI();
this.logger.info(`Metadata received: ${metadata.fileName} (${this.formatFileSize(metadata.fileSize)}), ${metadata.chunksCount} chunks`);
}
handleDataPacket(packet) {
if (!this.metadataReceived) {
this.logger.warn("Received data packet before metadata, ignoring");
return;
}
if (this.discoveryMode) {
this.logger.debug(`📦 DISCOVERY: Processing data packet for ${this.currentActiveFile || 'unknown file'}`);
}
if (packet.sourceChunks) {
packet.sourceChunks.forEach(chunkIndex => {
this.ui.blinkChunk(chunkIndex);
});
}
const wasAdded = this.fountainDecoder.addPacket(packet);
if (wasAdded) {
const newlyRecovered = this.fountainDecoder.getNewlyRecoveredChunks();
if (newlyRecovered.length > 0) {
newlyRecovered.forEach(chunkIndex => {
this.recoveredChunks.set(chunkIndex, true);
this.missingChunks.delete(chunkIndex);
this.ui.markChunkAsRecovered(chunkIndex);
});
this.updateMissingChunksUI();
this.logger.info(`Recovered ${newlyRecovered.length} new chunks, total: ${this.recoveredChunks.size}/${this.fileMetadata.chunksCount}`);
}
}
}
updateMissingChunksUI() {
const missingCount = this.missingChunks.size;
const totalCount = this.fileMetadata.chunksCount;
const recoveredCount = totalCount - missingCount;
document.getElementById('missingChunks').innerHTML = `
<div>Recovered chunks: ${recoveredCount}/${totalCount} (${Math.round(recoveredCount / totalCount * 100)}%)</div><div>Missing chunks: ${missingCount}</div>
`;
if (missingCount === 0 && recoveredCount === totalCount) {
this.logger.info("All chunks recovered, finalizing file...");
}
}
handleFileComplete(fileData) {
this.logger.info("File recovery complete!");
this.releaseWakeLock();
this.recoveredFileData = fileData;
document.getElementById('downloadContainer').style.display = 'block';
const fileInfo = document.getElementById('fileInfo').innerHTML;
document.getElementById('fileInfo').innerHTML = fileInfo + `
<div style="margin-top: 10px; color: var(--success-color);"><strong>File Successfully Recovered!</strong></div>
`;
if (this.discoveryMode) {
console.log(`✅ File ${this.fileMetadata.fileName} COMPLETED during discovery - storing and continuing scan`);
const fileName = this.fileMetadata.fileName;
if (this.discoveredFiles.has(fileName)) {
const fileInfo = this.discoveredFiles.get(fileName);
fileInfo.completed = true;
fileInfo.recoveredData = fileData;
fileInfo.recoveredAt = performance.now();
this.logger.info(`💾 DISCOVERY: Stored completed file: ${fileName} (${fileData.byteLength} bytes)`);
if (!this.downloadedFiles.has(fileName)) {
console.log(`📥 Auto-downloading completed file during discovery: ${fileName}`);
this.downloadCompletedFile(fileName);
console.log(`🔍 DISCOVERY: File ${fileName} downloaded but continuing discovery to find all files in video`);
} else {
console.log(`⏭️ ENTERPRISE: File ${fileName} already downloaded during discovery - skipping duplicate`);
}
}
const totalChunks = this.fileMetadata.chunksCount;
const actualRecoveredChunks = this.fountainDecoder ? this.fountainDecoder.recoveredChunkCount : this.recoveredChunks.size;
console.log(`🔍 ENTERPRISE UI FIX: Using fountain decoder count ${actualRecoveredChunks} instead of stale main decoder count ${this.recoveredChunks.size}`);
document.getElementById('missingChunks').innerHTML = `
<div>Recovered chunks: ${actualRecoveredChunks}/${totalChunks} (100%)</div><div>Missing chunks: 0</div><div style="color: #16a34a; font-weight: bold;">✅ FILE COMPLETE - DOWNLOADED</div>
`;
this.ui.updateFileInfo(`✅ File ${fileName} FULLY COMPLETE (${actualRecoveredChunks}/${totalChunks} chunks)! Downloaded and continuing discovery...`);
const completionInfo = {
fileName: fileName,
totalChunks: totalChunks,
recoveredChunks: actualRecoveredChunks
};
this.logger.info(`🔄 DISCOVERY: Resetting state after ${fileName} completion - ready for next file`);
this.fountainDecoder = new EnhancedFountainDecoder();
this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this));
this.metadataReceived = false;
this.fileMetadata = null;
this.recoveredChunks = new Map();
this.missingChunks = new Set();
this.currentActiveFile = null;
setTimeout(() => {
this.ui.resetChunkGrid();
this.ui.updateFileInfo(`🔍 Discovery continuing after ${completionInfo.fileName} (${completionInfo.recoveredChunks}/${completionInfo.totalChunks}) - scanning for more files...`);
}, 2000);
this.updateDiscoveredFilesUI();
return;
}
if (this.isProcessing) {
try {
this.stopProcessing();
} catch (error) {
console.error('Error during stopProcessing in handleFileComplete:', error);
this.isProcessing = false;
}
}
const fileName = this.fileMetadata.fileName;
if (this.downloadedFiles.has(fileName)) {
console.log(`⏭️ ENTERPRISE: File ${fileName} already downloaded - skipping duplicate download`);
this.logger.info(`File ${fileName} recovery complete (already downloaded)`);
return;
}
console.log(`💾 File ${fileName} complete - triggering automatic download`);
this.downloadFile();
}
downloadFile() {
if (!this.recoveredFileData || !this.fileMetadata) {
this.logger.warn("No recovered file data available");
return;
}
try {
const blob = new Blob([this.recoveredFileData], { type: this.fileMetadata.fileType || 'application/octet-stream' });
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = this.fileMetadata.fileName;
document.body.appendChild(a);
a.click();
setTimeout(() => {
document.body.removeChild(a);
URL.revokeObjectURL(url);
}, 100);
this.downloadedFiles.add(this.fileMetadata.fileName);
this.logger.info(`💾 ENTERPRISE: Auto-downloaded "${this.fileMetadata.fileName}" (${this.formatFileSize(this.recoveredFileData.byteLength)})`);
console.log(`✅ ENTERPRISE SUCCESS: File download completed automatically for user convenience`);
console.log(`📋 ENTERPRISE: Added "${this.fileMetadata.fileName}" to downloaded files list (${this.downloadedFiles.size} total)`);
if (!this.discoveryMode) {
this.checkAndStopIfAllFilesDownloaded();
} else {
console.log(`🔍 DISCOVERY: File downloaded but discovery mode active - continuing to scan entire video`);
}
} catch (error) {
console.error(`❌ ENTERPRISE ERROR: Auto-download failed for ${this.fileMetadata.fileName}:`, error.message);
this.logger.error(`Error downloading file: ${error.message}`);
this.ui.showErrorMessage(`Error downloading file: ${error.message}`);
}
}
saveSettings() {
const workerCount = parseInt(document.getElementById('workerCount').value);
const packetWorkerCount = parseInt(document.getElementById('packetWorkerCount').value);
const frameInterval = parseInt(document.getElementById('frameInterval').value);
const qrDetectionConfidence = parseFloat(document.getElementById('qrDetectionConfidence').value);
this.settings = {
workerCount: isNaN(workerCount) ? 4 : Math.min(Math.max(workerCount, 1), 16),
packetWorkerCount: isNaN(packetWorkerCount) ? 2 : Math.min(Math.max(packetWorkerCount, 1), 8),
frameInterval: isNaN(frameInterval) ? 20 : Math.min(Math.max(frameInterval, 0), 1000),
qrDetectionConfidence: isNaN(qrDetectionConfidence) ? 0.5 : Math.min(Math.max(qrDetectionConfidence, 0), 1)
};
this.logger.info(`Settings updated: ${JSON.stringify(this.settings)}`);
this.ui.hideSettingsModal();
}
switchToFile(metadata, fileName) {
this.logger.info(`🔄 DISCOVERY: Switching to process file: ${fileName}`);
this.currentActiveFile = fileName;
this.fountainDecoder = new EnhancedFountainDecoder();
this.fountainDecoder.initialize(metadata);
this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this));
this.metadataReceived = true;
this.fileMetadata = metadata;
this.recoveredChunks = new Map();
this.missingChunks = new Set();
this.ui.initializeChunkGrid(metadata.chunksCount);
this.ui.updateFileInfo(`
<div><strong>DISCOVERY - Current File:</strong> ${metadata.fileName}</div><div><strong>File Type:</strong> ${metadata.fileType}</div><div><strong>File Size:</strong> ${this.formatFileSize(metadata.fileSize)}</div><div><strong>Chunks:</strong> ${metadata.chunksCount}</div><div><strong>Time:</strong> ${this.videoProcessor ? this.videoProcessor.videoElement.currentTime.toFixed(1) : '?'}s</div>
`);
for (let i = 0; i < metadata.chunksCount; i++) {
this.missingChunks.add(i);
}
this.updateMissingChunksUI();
this.logger.info(`🎯 DISCOVERY: Now actively processing ${fileName} - ready for data packets`);
}
resetForNewFile(metadata, fileName) {
this.logger.info(`🔄 Resetting UI and decoder for new file: ${fileName}`);
this.currentActiveFile = fileName;
this.fountainDecoder = new EnhancedFountainDecoder();
this.fountainDecoder.initialize(metadata);
this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this));
this.metadataReceived = true;
this.fileMetadata = metadata;
this.recoveredChunks = new Map();
this.missingChunks = new Set();
this.ui.initializeChunkGrid(metadata.chunksCount);
this.ui.updateFileInfo(`
<div><strong>Current File:</strong> ${metadata.fileName}</div><div><strong>File Type:</strong> ${metadata.fileType}</div><div><strong>File Size:</strong> ${this.formatFileSize(metadata.fileSize)}</div><div><strong>Chunks:</strong> ${metadata.chunksCount}</div><div><strong>Discovery Mode:</strong> Active</div>
`);
for (let i = 0; i < metadata.chunksCount; i++) {
this.missingChunks.add(i);
}
this.updateMissingChunksUI();
this.logger.info(`🎯 Ready to process ${fileName} during discovery scan`);
}
copyDebugLog() {
try {
const logWindow = document.getElementById('logWindow');
const logEntries = logWindow.querySelectorAll('.log-entry');
let logText = '=== QR File Decoder Debug Log ===\n';
logText += `Generated: ${new Date().toISOString()}\n`;
logText += `Video: ${this.videoFile ? this.videoFile.name : 'None'}\n`;
logText += `Discovered Files: ${this.discoveredFiles.size}\n`;
logText += '=====================================\n\n';
logEntries.forEach(entry => {
logText += entry.textContent + '\n';
});
navigator.clipboard.writeText(logText).then(() => {
this.logger.info('Debug log copied to clipboard');
const copyBtn = document.getElementById('copyLogBtn');
const originalText = copyBtn.textContent;
copyBtn.textContent = 'Copied!';
copyBtn.style.backgroundColor = '#10b981';
setTimeout(() => {
copyBtn.textContent = originalText;
copyBtn.style.backgroundColor = '';
}, 2000);
}).catch(err => {
this.logger.error('Failed to copy log to clipboard: ' + err.message);
});
} catch (error) {
this.logger.error('Error copying debug log: ' + error.message);
}
}
handleDiscoveryComplete() {
this.logger.info(`🎯 Discovery complete! Found ${this.discoveredFiles.size} files in video`);
this.updateDiscoveredFilesUI();
if (this.discoveredFiles.size === 1) {
const [filename, fileInfo] = Array.from(this.discoveredFiles.entries())[0];
this.ui.updateFileInfo(`Found 1 file: ${filename}. Continuing to process with loops...`);
} else if (this.discoveredFiles.size > 1) {
this.checkAndAutoRepeatIncompleteFiles();
} else {
this.ui.updateFileInfo("No file metadata found yet. Continuing scan...");
}
}
updateDiscoveredFilesUI() {
const container = document.getElementById('discoveredFilesContainer');
const filesList = document.getElementById('discoveredFilesList');
if (this.discoveredFiles.size === 0) {
container.style.display = 'none';
return;
}
container.style.display = 'block';
filesList.innerHTML = '';
Array.from(this.discoveredFiles.entries()).forEach(([filename, fileInfo], index) => {
const fileButton = document.createElement('div');
fileButton.style.cssText = 'margin-bottom: 10px; padding: 10px; border: 1px solid #e5e7eb; border-radius: 4px; background: #f9fafb;';
const fileSize = this.formatFileSize(fileInfo.metadata.fileSize);
const timeRange = `${fileInfo.firstSeenAt.toFixed(1)}s - ${fileInfo.lastSeenAt.toFixed(1)}s`;
const isCompleted = fileInfo.completed || false;
const statusBadge = isCompleted ?
'<span style="background: #dcfce7; color: #16a34a; padding: 2px 6px; border-radius: 8px; font-size: 10px; font-weight: bold;">COMPLETED</span>' :
'<span style="background: #fef3c7; color: #d97706; padding: 2px 6px; border-radius: 8px; font-size: 10px; font-weight: bold;">NEEDS PROCESSING</span>';
fileButton.innerHTML = `
<div style="display: flex; justify-content: space-between; align-items: center;"><div><div style="display: flex; align-items: center; gap: 8px;"><span style="font-weight: bold; color: #1f2937;">${filename}</span>
${statusBadge}
</div><div style="font-size: 12px; color: #6b7280;">
Size: ${fileSize} | Chunks: ${fileInfo.metadata.chunksCount} | Time: ${timeRange}
</div></div><div style="display: flex; gap: 5px;"><button onclick="window.qrFileDecoder.startFileProcessing('${filename}', ${fileInfo.firstSeenAt})"
style="padding: 6px 12px; background: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer;">
Decode Full
</button><button onclick="window.qrFileDecoder.repeatFileRange('${filename}', ${fileInfo.firstSeenAt}, ${fileInfo.lastSeenAt})"
style="padding: 6px 12px; background: #f59e0b; color: white; border: none; border-radius: 4px; cursor: pointer;">
Repeat Range
</button>
${isCompleted ? `<button onclick="window.qrFileDecoder.downloadCompletedFile('${filename}')"
style="padding: 6px 12px; background: #16a34a; color: white; border: none; border-radius: 4px; cursor: pointer;">
Download
</button>` : ''}
</div></div>
`;
filesList.appendChild(fileButton);
});
}
repeatFileRange(filename, startTime, endTime) {
if (this.isProcessing) return;
this.logger.info(`Repeating range for ${filename}: ${startTime.toFixed(2)}s - ${endTime.toFixed(2)}s`);
this.currentActiveFile = filename;
this.discoveryMode = false;
const fileInfo = this.discoveredFiles.get(filename);
if (fileInfo && fileInfo.metadata) {
this.fileMetadata = fileInfo.metadata;
this.metadataReceived = true;
this.fountainDecoder = new EnhancedFountainDecoder();
this.fountainDecoder.initialize(fileInfo.metadata);
this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this));
this.ui.initializeChunkGrid(fileInfo.metadata.chunksCount);
}
if (this.videoProcessor) {
this.videoProcessor.videoElement.currentTime = startTime;
this.videoProcessor.discoveryMode = false;
this.videoProcessor.rangeMode = true;
this.videoProcessor.endTime = endTime;
this.isProcessing = true;
this.videoProcessor.isProcessing = true;
this.videoProcessor.loopCount = 1;
document.getElementById('startScanBtn').disabled = true;
document.getElementById('continueBtn').disabled = true;
document.getElementById('stopScanBtn').disabled = false;
this.ui.updateFileInfo(`Repeating range for: ${filename} (${startTime.toFixed(1)}s - ${endTime.toFixed(1)}s)`);
this.videoProcessor.videoElement.play();
}
}
async checkAndAutoRepeatIncompleteFiles() {
this.isProcessing = false;
this.ui.updateFileInfo(`Discovery complete - found ${this.discoveredFiles.size} files. Checking completion status...`);
this.updateDiscoveredFilesUI();
const incompleteFiles = [];
for (const [filename, fileInfo] of this.discoveredFiles.entries()) {
incompleteFiles.push({filename, fileInfo});
}
if (incompleteFiles.length > 0) {
this.logger.info(`🔄 Found ${incompleteFiles.length} files that may need additional processing`);
this.logger.info(`🎯 Starting automatic range repeats (5 loops each) for better completion...`);
for (const {filename, fileInfo} of incompleteFiles) {
await this.autoRepeatFileRange(filename, fileInfo.firstSeenAt, fileInfo.lastSeenAt, 5);
}
this.logger.info(`✅ Automatic range processing complete for all files`);
}
document.getElementById('startScanBtn').disabled = false;
document.getElementById('stopScanBtn').disabled = true;
this.ui.updateFileInfo(`All files processed. Select a file above to decode or retry specific ranges.`);
}
async autoRepeatFileRange(filename, startTime, endTime, maxLoops = 5) {
this.logger.info(`🔄 Auto-repeating ${filename} range ${maxLoops} times: ${startTime.toFixed(2)}s - ${endTime.toFixed(2)}s`);
for (let loop = 1; loop <= maxLoops; loop++) {
this.logger.info(`📹 Auto-repeat loop ${loop}/${maxLoops} for ${filename}`);
this.currentActiveFile = filename;
this.discoveryMode = false;
const fileInfo = this.discoveredFiles.get(filename);
if (fileInfo && fileInfo.metadata) {
this.fileMetadata = fileInfo.metadata;
this.metadataReceived = true;
this.fountainDecoder = new EnhancedFountainDecoder();
this.fountainDecoder.initialize(fileInfo.metadata);
this.fountainDecoder.setCompleteCallback(this.handleFileComplete.bind(this));
this.ui.initializeChunkGrid(fileInfo.metadata.chunksCount);
}
await this.processVideoRange(startTime, endTime, loop);
if (loop < maxLoops) {
await new Promise(resolve => setTimeout(resolve, 1000));
}
}
}
async processVideoRange(startTime, endTime, loopNumber) {
return new Promise((resolve) => {
if (this.videoProcessor) {
this.videoProcessor.videoElement.currentTime = startTime;
this.videoProcessor.discoveryMode = false;
this.videoProcessor.rangeMode = true;
this.videoProcessor.endTime = endTime;
this.videoProcessor.loopCount = loopNumber;
this.ui.updateFileInfo(`Auto-processing ${this.currentActiveFile} - Loop ${loopNumber} (${startTime.toFixed(1)}s - ${endTime.toFixed(1)}s)`);
this.videoProcessor.isProcessing = true;
this.videoProcessor.videoElement.play();
const checkCompletion = setInterval(() => {
if (!this.videoProcessor.isProcessing || this.videoProcessor.videoElement.paused) {
clearInterval(checkCompletion);
resolve();
}
}, 500);
} else {
resolve();
}
});
}
downloadCompletedFile(filename) {
const fileInfo = this.discoveredFiles.get(filename);
if (!fileInfo || !fileInfo.completed || !fileInfo.recoveredData) {
this.logger.warn(`File ${filename} is not available for download`);
return;
}
try {
const blob = new Blob([fileInfo.recoveredData], {
type: fileInfo.metadata.fileType || 'application/octet-stream'
});
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = filename;
document.body.appendChild(a);
a.click();
setTimeout(() => {
document.body.removeChild(a);
URL.revokeObjectURL(url);
}, 100);
this.downloadedFiles.add(filename);
this.logger.info(`📥 ENTERPRISE: Auto-downloaded discovered file: ${filename} (${this.formatFileSize(fileInfo.recoveredData.byteLength)})`);
console.log(`✅ ENTERPRISE SUCCESS: Discovered file "${filename}" automatically downloaded`);
console.log(`📋 ENTERPRISE: Added "${filename}" to downloaded files list (${this.downloadedFiles.size} total)`);
} catch (error) {
console.error(`❌ ENTERPRISE ERROR: Auto-download failed for discovered file ${filename}:`, error.message);
this.logger.error(`Error downloading file ${filename}: ${error.message}`);
}
}
checkAndStopIfAllFilesDownloaded() {
if (this.discoveredFiles.size === 0) return;
const discoveredFileNames = Array.from(this.discoveredFiles.keys());
const downloadedFileNames = Array.from(this.downloadedFiles);
const currentLoop = this.videoProcessor ? (this.videoProcessor.loopCount || 1) : 1;
const allDiscoveredFilesDownloaded = discoveredFileNames.every(filename =>
downloadedFileNames.includes(filename)
);
console.log(`📊 ENTERPRISE SCALE CHECK: ${downloadedFileNames.length}/${discoveredFileNames.length} files downloaded, loop ${currentLoop}`);
if (allDiscoveredFilesDownloaded) {
if (currentLoop === 1) {
console.log(`📊 ENTERPRISE: All ${discoveredFileNames.length} files downloaded in discovery loop - will validate at loop 2`);
} else {
console.log(`✅ ENTERPRISE: All ${discoveredFileNames.length} files confirmed downloaded in loop ${currentLoop}`);
}
} else {
const remainingFiles = discoveredFileNames.filter(name => !downloadedFileNames.includes(name));
console.log(`🔄 ENTERPRISE: ${remainingFiles.length} files still needed: ${remainingFiles.join(', ')}`);
}
}
formatFileSize(bytes) {
if (bytes < 1024) return `${bytes} bytes`;
if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB`;
return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
}
detectDeviceCapabilities() {
const hardwareConcurrency = navigator.hardwareConcurrency || 4;
const memory = navigator.deviceMemory || 4;
let workerCount = Math.min(Math.max(Math.floor(hardwareConcurrency / 2), 1), 4);
let frameInterval = 50;
if (hardwareConcurrency <= 2 || memory <= 2) {
workerCount = 1;
frameInterval = 100;
}
if (hardwareConcurrency >= 8 && memory >= 8) {
workerCount = 8;
frameInterval = 10;
}
return {
workerCount,
packetWorkerCount: Math.max(1, Math.floor(workerCount / 2)),
frameInterval
};
}
}
window.debugTools = {
analyzeDecoderState: function () {
if (!window.qrFileDecoder || !window.qrFileDecoder.fountainDecoder) {
console.error("Decoder not initialized");
return;
}
const decoder = window.qrFileDecoder.fountainDecoder;
const stats = {
initialized: decoder.initialized,
totalChunks: decoder.totalChunks,
recoveredChunks: decoder.recoveredChunkCount,
recoveryPercentage: decoder.recoveredChunkCount / decoder.totalChunks * 100,
waitingPackets: decoder.codedPackets.length,
metadata: decoder.metaData,
packetStats: decoder.packetStats
};
console.log("==== Decoder State Analysis ====");
console.table(stats);
const missingChunks = [];
for (let i = 0; i < decoder.totalChunks; i++) {
if (!decoder.sourceChunks[i]) {
missingChunks.push(i);
}
}
if (missingChunks.length > 0) {
console.log(`Missing chunks (${missingChunks.length}):`, missingChunks);
} else {
console.log("All chunks recovered!");
}
return stats;
},
exportRecoveredData: function () {
if (!window.qrFileDecoder || !window.qrFileDecoder.recoveredFileData) {
console.error("No recovered file data available");
return;
}
const data = window.qrFileDecoder.recoveredFileData;
console.log(`Recovered data length: ${data.byteLength} bytes`);
const preview = new Uint8Array(data.slice(0, 100));
console.log("Data preview (first 100 bytes):", preview);
return {
byteLength: data.byteLength,
preview: Array.from(preview)
};
}
};
function addDebugButton() {
if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
const controlPanel = document.querySelector('.controls');
if (!controlPanel) return;
const debugBtn = document.createElement('button');
debugBtn.id = 'debugToolsBtn';
debugBtn.textContent = 'Debug Tools';
debugBtn.style.backgroundColor = '#6b7280';
debugBtn.addEventListener('click', () => {
console.log("Debug tools accessed. Use window.debugTools in the console to analyze decoder state.");
window.debugTools.analyzeDecoderState();
});
controlPanel.appendChild(debugBtn);
}
}
document.addEventListener('DOMContentLoaded', () => {
window.qrFileDecoder = new QRFileDecoder();
setTimeout(addDebugButton, 500);
});</script></body></html>