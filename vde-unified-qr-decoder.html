<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unified QR Code Decoder</title>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* MODIFICATION: Added styles for slider controls */
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            margin-bottom: 5px;
        }

        input[type=range] {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            appearance: none;
            outline: 0;
        }

        input[type=range]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #6b7280;
            margin-top: 5px;
        }

        .value-display {
            font-weight: 700;
            color: var(--primary-color);
            margin-left: 5px;
        }

        :root {
            --primary-color: #2563eb;
            --secondary-color: #1d4ed8;
            --success-color: #16a34a;
            --warning-color: #f59e0b;
            --danger-color: #dc2626;
            --light-color: #f8fafc;
            --dark-color: #0f172a;
            --gray-color: #64748b;
            --border-color: #e2e8f0;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.5;
            color: var(--dark-color);
            background-color: #f5f5f5;
            overflow-x: hidden;
            max-width: 100%;
        }

        h1,
        h2,
        h3 {
            color: var(--primary-color);
            margin-bottom: 1rem;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            flex: 1;
            min-width: 300px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .video-container {
            position: relative;
            overflow: hidden;
            border-radius: 8px;
            background: #000;
            max-width: 100%;
            height: 400px;
            /* Fixed height for consistent layout */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #video,
        #uploadedVideo {
            position: relative;
            width: 100%;
            height: 100%;
            max-height: 400px;
            object-fit: contain;
            background: #000;
        }

        #canvas,
        #videoCanvas,
        #debugCanvas,
        #videoDebugCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            z-index: 5;
            opacity: 0.8;
            display: none;
        }

        .debug-view {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .debug-view-canvas {
            width: 100%;
            max-height: 300px;
            border: 1px solid #ddd;
            background: #000;
        }

        .debug-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .debug-button {
            padding: 8px;
            font-size: 12px;
            background: #64748b;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #canvas {
            display: none;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: bold;
            color: var(--dark-color);
        }

        select,
        button,
        input {
            padding: 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-size: 14px;
        }

        button {
            background: var(--primary-color);
            color: white;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: var(--secondary-color);
        }

        button:disabled {
            background: var(--gray-color);
            cursor: not-allowed;
        }

        button.danger {
            background: var(--danger-color);
        }

        button.danger:hover {
            background: #b91c1c;
        }

        button.success {
            background: var(--success-color);
        }

        button.success:hover {
            background: #15803d;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .status-badge.active {
            background: var(--success-color);
            color: white;
        }

        .status-badge.inactive {
            background: var(--gray-color);
            color: white;
        }

        .status-badge.warning {
            background: var(--warning-color);
            color: white;
        }

        .status-badge.error {
            background: var(--danger-color);
            color: white;
        }

        .status-badge.systematic-phase {
            background: var(--primary-color);
            color: white;
        }

        .status-badge.fountain-phase {
            background: var(--success-color);
            color: white;
        }

        .chunk.systematic {
            background: var(--primary-color);
        }

        .chunk.fountain {
            background: var(--success-color);
        }

        .info-panel {
            margin-top: 20px;
            padding: 15px;
            background: #f0f9ff;
            border-radius: 8px;
            border-left: 4px solid var(--primary-color);
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .info-label {
            font-weight: bold;
            color: var(--secondary-color);
        }

        .error-stats {
            margin: 10px 0 15px;
            padding: 10px;
            background: rgba(255, 235, 235, 0.5);
            border-radius: 6px;
        }

        .error-stat {
            color: #d32f2f;
        }

        .progress-container {
            width: 100%;
            height: 20px;
            background: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
            position: relative;
            /* Use relative positioning instead of fixed */
            z-index: 1;
            /* Lower z-index to avoid covering everything */
        }

        .progress-bar {
            height: 100%;
            background: var(--primary-color);
            transition: width 0.3s;
            width: 0;
            position: relative;
            /* Ensure proper positioning */
            z-index: 2;
            /* Ensure visible above container */
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(20px, 1fr));
            gap: 4px;
            margin-top: 15px;
        }

        .grid-item {
            aspect-ratio: 1 / 1;
            border-radius: 4px;
            background: #e5e7eb;
            transition: background-color 0.3s ease;
        }

        .grid-item.received {
            background: #bfdbfe;
        }

        .grid-item.processed {
            background: var(--success-color);
        }

        .grid-item.just-read {
            animation: yellowBlink 1.5s ease;
        }

        @keyframes yellowBlink {
            0% {
                background-color: #e5e7eb;
            }

            20% {
                background-color: #facc15;
            }

            /* Bright yellow */
            80% {
                background-color: #facc15;
            }

            100% {
                background-color: #bfdbfe;
            }
        }

        .file-input-container {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input-label {
            padding: 12px;
            background: #e5e7eb;
            color: var(--dark-color);
            border-radius: 4px;
            cursor: pointer;
            display: block;
            text-align: center;
            transition: background 0.2s;
        }

        .file-input-label:hover {
            background: #d1d5db;
        }

        .file-input-container input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .switch-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            overflow: hidden;
        }

        .switch-container input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 46px;
            height: 24px;
            z-index: 3;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
            z-index: 1;
            pointer-events: none;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            z-index: 2;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--primary-color);
        }

        input:checked+.slider:before {
            transform: translateX(22px);
        }

        .label-text {
            font-size: 14px;
        }

        .tooltip {
            position: relative;
            display: inline-block;
            margin-left: 5px;
            width: 16px;
            height: 16px;
            background: #e5e7eb;
            color: var(--gray-color);
            border-radius: 50%;
            text-align: center;
            line-height: 16px;
            font-size: 11px;
            font-weight: bold;
            cursor: help;
        }

        .tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            top: -5px;
            left: 100%;
            transform: translateY(-100%);
            background: rgba(55, 65, 81, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            width: 200px;
            font-weight: normal;
            font-size: 12px;
            z-index: 10;
            line-height: 1.4;
        }

        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 20px;
            background: var(--primary-color);
            color: white;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            max-width: 300px;
            transform: translateY(100px);
            opacity: 0;
            transition: transform 0.3s, opacity 0.3s;
            z-index: 1000;
        }

        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }

        .notification.success {
            background: var(--success-color);
        }

        .notification.error {
            background: var(--danger-color);
        }

        .stats-container {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .error-tracking-container {
            margin-top: 5px;
            border-left: 3px solid var(--danger-color);
            padding-left: 10px;
            background-color: rgba(220, 38, 38, 0.05);
            padding: 10px;
            border-radius: 4px;
        }

        .stat-box {
            flex: 1;
            min-width: 120px;
            background: white;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .error-stat .stat-value {
            color: var(--danger-color);
            font-size: 20px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary-color);
        }

        .stat-label {
            font-size: 12px;
            color: var(--gray-color);
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .video-container {
                aspect-ratio: 4 / 3;
            }

            .panel {
                min-width: 100%;
            }

            .stats-container {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }

            .error-tracking-container {
                padding: 8px;
            }

            .stat-box {
                min-width: 120px;
                padding: 8px;
            }

            .stat-value {
                font-size: 20px;
            }

            .error-stat .stat-value {
                font-size: 18px;
            }

            .tab-content {
                padding: 10px;
            }
        }

        @media (max-width: 480px) {
            .stats-container {
                grid-template-columns: repeat(2, 1fr);
            }

            .stat-box {
                padding: 6px;
            }

            .stat-value {
                font-size: 18px;
            }

            .stat-label {
                font-size: 10px;
            }
        }

        /* Additional responsive improvements */
        @media (max-width: 768px) {
            .stat-box {
                min-width: 120px;
            }

            .stats-container {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }

            .tab-content {
                padding: 10px;
            }
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: none;
        }

        .overlay-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            max-width: 80%;
        }

        .overlay.hidden {
            display: none;
        }

        .tab-container {
            margin-bottom: 20px;
        }

        .tab-buttons {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 15px;
        }

        .tab-button {
            padding: 10px 15px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            color: var(--gray-color);
            cursor: pointer;
            font-weight: bold;
        }

        .tab-button.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }

        .tab-content {
            display: none;
            width: 100%;
            height: auto;
            transition: opacity 0.3s ease;
            opacity: 0;
        }

        .tab-content.active {
            display: block;
            opacity: 1;
        }

        /* Ensure tab content has consistent sizing */
        .tab-content .video-container {
            margin-bottom: 20px;
        }

        /* Spinner */
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        .pulse-animation {
            animation: pulse 1.5s infinite;
        }

        .grid-item.placeholder {
            background: #f0f0f0;
            color: #666;
            font-style: italic;
        }

        .stat-box {
            transition: background-color 0.3s;
        }

        .stat-box.highlight {
            background-color: rgba(37, 99, 235, 0.1);
        }

        /* Debug panel */
        .debug-options {
            margin-top: 15px;
            padding: 15px;
            background: #f8fafe;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        /* Debug console improvements */
        .debug-panel-container {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: #f8f8f8;
            font-family: monospace;
            font-size: 12px;
        }

        .debug-panel-header {
            padding: 10px 12px;
            background-color: #eaeaea;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        @media (max-width: 768px) {
            .debug-panel-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .log-level-controls {
                margin-left: 0;
                width: 100%;
                justify-content: space-between;
            }
        }

        .debug-panel-header h3 {
            margin: 0;
            font-size: 14px;
            color: #333;
        }

        .log-level-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            background: #f0f0f0;
            padding: 8px;
            border-radius: 4px;
            margin-left: 10px;
        }

        .log-level-controls label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            color: #555;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.7);
        }

        .log-level-controls label:hover {
            background: rgba(255, 255, 255, 1);
        }

        .log-level-controls input[type="checkbox"] {
            margin: 0;
            width: 14px;
            height: 14px;
        }

        .log-level-button {
            padding: 5px 10px;
            background: #e5e7eb;
            color: #374151;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
        }

        .log-level-button:hover {
            background: #d1d5db;
        }

        .log-level-button.active {
            background: var(--primary-color);
            color: white;
        }

        #clearLogsBtn {
            background-color: #e0e0e0;
            color: #333;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 2px 8px;
            font-size: 12px;
            cursor: pointer;
        }

        #clearLogsBtn:hover {
            background-color: #d0d0d0;
        }

        .debug-panel {
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            height: auto;
            max-height: none;
            background: #f8f8f8;
        }

        .debug-entry {
            margin-bottom: 5px;
            padding-bottom: 5px;
            border-bottom: 1px dashed #ddd;
        }

        .debug-entry.verbose {
            color: #6b7280;
        }

        .debug-entry.info {
            color: var(--primary-color);
        }

        .debug-entry.error {
            color: var(--danger-color);
        }

        .debug-entry.warning {
            color: var(--warning-color);
        }

        .debug-entry.success {
            color: var(--success-color);
        }

        /* Download button */
        .download-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            padding: 15px;
            margin-top: 20px;
            background: var(--success-color);
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }

        .download-button:hover {
            background: #15803d;
        }

        .download-button:disabled {
            background: var(--gray-color);
            cursor: not-allowed;
        }

        .download-button svg {
            width: 18px;
            height: 18px;
        }

        /* Custom styles for debug options */
        .debug-options {
            margin-top: 15px;
            padding: 12px;
            border-top: 1px solid var(--border-color);
            background-color: #f8fafc;
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .debug-options .control-group {
            margin-bottom: 0;
        }

        .debug-options .debug-button {
            margin-top: 10px;
            background-color: var(--primary-color);
            color: white;
            padding: 8px 12px;
            font-size: 13px;
            transition: background-color 0.2s;
        }

        .debug-options .debug-button:hover {
            background-color: var(--secondary-color);
        }

        /* Prevent slider overflow outside its container */
        span.slider:not(.switch *) {
            display: none !important;
        }
    </style>
</head>

<body>
    <h1>Unified QR Code Decoder</h1>

    <div class="container">
        <div class="panel">
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="camera-tab">Camera</button>
                    <button class="tab-button" data-tab="video-tab">Video Upload</button>
                    <button class="tab-button" data-tab="settings-tab">Settings</button>
                </div>

                <div class="tab-content active" id="camera-tab">
                    <div class="control-group">
                        <label for="cameraSelect">Select Camera</label>
                        <select id="cameraSelect" disabled>
                            <option value="">Loading cameras...</option>
                        </select>
                    </div>

                    <div class="video-container">
                        <video id="video" playsinline autoplay muted></video>
                        <canvas id="canvas"></canvas>
                        <canvas id="debugCanvas"></canvas>
                        <div id="cameraOverlay" class="overlay">
                            <div class="overlay-content">
                                <h3>Camera Inactive</h3>
                                <p>Click "Start Camera" to begin scanning</p>
                            </div>
                        </div>
                    </div>

                    <div class="controls">
                        <button id="startCameraBtn" class="success">Start Camera</button>
                        <button id="fullscreenBtn" class="success">Fullscreen Camera</button>
                        <button id="stopCameraBtn" class="danger" disabled>Stop Camera</button>
                    </div>
                </div>

                <div class="tab-content" id="video-tab">
                    <div class="control-group">
                        <label>Upload Video File</label>
                        <div class="file-input-container">
                            <label class="file-input-label">
                                <span id="videoFileLabel">Choose a video file</span>
                                <input type="file" id="videoFileInput" accept="video/*">
                            </label>
                        </div>
                    </div>

                    <div class="video-container">
                        <video id="uploadedVideo" playsinline controls></video>
                        <canvas id="videoCanvas"></canvas>
                        <canvas id="videoDebugCanvas"></canvas>
                        <div id="videoOverlay" class="overlay">
                            <div class="overlay-content">
                                <h3>No Video Selected</h3>
                                <p>Upload a video file to begin</p>
                            </div>
                        </div>
                    </div>

                    <div class="debug-view" id="debugView" style="display: none;">
                        <h3>Debug View</h3>
                        <canvas id="processedCanvas" class="debug-view-canvas"></canvas>
                        <div class="debug-controls">
                            <button class="debug-button" id="saveFrameBtn">Save Current Frame</button>
                            <button class="debug-button" id="detectMainThreadBtn">Try Detect in Main Thread</button>
                            <button class="debug-button" id="cycleProcessingBtn">Cycle Processing Methods</button>
                        </div>
                    </div>

                    <div class="controls">
                        <button id="startProcessingBtn" disabled>Start Processing</button>
                        <button id="stopProcessingBtn" class="danger" disabled>Stop Processing</button>
                    </div>
                </div>

                <div class="tab-content" id="settings-tab">
                    <div class="control-group">
                        <div class="switch-container">
                            <label class="switch">
                                <input type="checkbox" id="highDensitySwitch" checked>
                                <span class="slider"></span>
                            </label>
                            <span>High Density Mode</span>
                            <span class="tooltip"
                                data-tooltip="Enable for complex QR codes with higher data capacity. May require more processing power.">?</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="switch-container">
                            <label class="switch">
                                <input type="checkbox" id="debugModeSwitch" checked>
                                <span class="slider"></span>
                            </label>
                            <span>Debug Mode</span>
                            <span class="tooltip"
                                data-tooltip="Show additional debugging information and visualizations.">?</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="switch-container">
                            <label class="switch">
                                <input type="checkbox" id="showDebugCanvasSwitch" checked>
                                <span class="slider"></span>
                            </label>
                            <span>Show Debug View</span>
                            <span class="tooltip" data-tooltip="Show processed frames with visual debugging.">?</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="switch-container">
                            <label class="switch">
                                <input type="checkbox" id="showScanOverlaySwitch" checked>
                                <span class="slider"></span>
                            </label>
                            <span>Show Scan Overlay</span>
                            <span class="tooltip"
                                data-tooltip="Highlight detected QR codes in the camera view.">?</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-label">
                            Worker Threads <span class="value-display" id="workerCountValue">4</span>
                            <span class="tooltip"
                                data-tooltip="Number of parallel processing threads. Higher values use more CPU but may improve decoding speed significantly. For modern devices, 8-16 workers can provide the best performance.">?</span>
                        </div>
                        <input type="range" id="workerCountSlider" min="1" max="16" value="4" step="1">
                        <div class="slider-labels">
                            <span>1 (Low CPU)</span>
                            <span>16 (Maximum Performance)</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-label">
                            Scan Rate <span class="value-display" id="scanRateValue">30 FPS</span>
                            <span class="tooltip"
                                data-tooltip="How many frames per second to analyze. Higher values improve detection but increase CPU usage.">?</span>
                        </div>
                        <input type="range" id="scanRateSlider" min="5" max="120" value="30" step="5">
                        <div class="slider-labels">
                            <span>5 FPS (Low CPU)</span>
                            <span>120 FPS (High Performance)</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label for="imageProcessingSelect">Image Processing</label>
                        <select id="imageProcessingSelect">
                            <option value="none">None</option>
                            <option value="contrast">Enhance Contrast</option>
                            <option value="bw">Black & White</option>
                            <option value="invert">Invert Colors</option>
                            <option value="adaptive" selected>Adaptive (Recommended)</option>
                            <option value="aggressive">Aggressive</option>
                        </select>
                        <span class="tooltip"
                            data-tooltip="Apply image processing to improve QR code detection.">?</span>
                    </div>

                    <div class="control-group">
                        <label for="scaleFactorSelect">Scale Factor</label>
                        <select id="scaleFactorSelect">
                            <option value="1" selected>No Scaling</option>
                            <option value="0.75">Downscale to 75%</option>
                            <option value="0.5">Downscale to 50%</option>
                            <option value="0.25">Downscale to 25%</option>
                            <option value="1.25">Upscale to 125%</option>
                            <option value="1.5">Upscale to 150%</option>
                            <option value="2">Upscale to 200%</option>
                        </select>
                        <span class="tooltip"
                            data-tooltip="Scale image before processing: downscale to improve detection of distant QR codes, upscale to enhance small QR codes.">?</span>
                    </div>

                    <div class="control-group">
                        <button id="captureFrameBtn">Capture Current Frame</button>
                    </div>

                    <div class="control-group">
                        <button id="saveChunksBtn">Save Chunks Manifest</button>
                    </div>

                    <div class="control-group">
                        <button id="resetSettingsBtn">Reset to Defaults</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2>Decoding Status</h2>

            <div class="stats-container">
                <div class="stat-box">
                    <div class="stat-value" id="framesProcessed">0</div>
                    <div class="stat-label">Frames Processed:</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="qrCodesDetected">0</div>
                    <div class="stat-label">Unique QR Codes Detected:</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="chunksRecovered">0%</div>
                    <div class="stat-label">Chunks Recovery Progress:</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="successRate">0%</div>
                    <div class="stat-label">QR Code/Frame Rate:</div>
                </div>
            </div>

            <h4>Error Tracking</h4>
            <div class="error-stats">
                <div class="info-row error-stat">
                    <div class="info-label">Not Readable:</div>
                    <div id="notReadableQR">0</div>
                </div>
                <div class="info-row error-stat">
                    <div class="info-label">Invalid Format:</div>
                    <div id="invalidFormatQR">0</div>
                </div>
                <div class="info-row error-stat">
                    <div class="info-label">Failed Integrity:</div>
                    <div id="failedIntegrityQR">0</div>
                </div>
            </div>

            <div id="decodingProgress" class="progress-container">
                <div id="progressBar" class="progress-bar"></div>
            </div>

            <div id="chunkGrid" class="grid-container">
                <!-- Chunk visualization will be added here dynamically -->
            </div>

            <div id="fileInfo" class="info-panel" style="display: none;">
                <h3>File Information</h3>
                <div class="info-row">
                    <div class="info-label">File Name:</div>
                    <div id="fileName">-</div>
                </div>
                <div class="info-row">
                    <div class="info-label">File Type:</div>
                    <div id="fileType">-</div>
                </div>
                <div class="info-row">
                    <div class="info-label">File Size:</div>
                    <div id="fileSize">-</div>
                </div>
                <div class="info-row">
                    <div class="info-label">Total Chunks:</div>
                    <div id="totalChunks">-</div>
                </div>
                <div class="info-row">
                    <div class="info-label">Chunks Recovered:</div>
                    <div id="recoveredChunks">-</div>
                </div>
                <div class="info-row">
                    <div class="info-label">Recovery Progress:</div>
                    <div id="recoveryProgress">-</div>
                </div>

                <h3>LT Code Statistics</h3>
                <div class="info-row">
                    <div class="info-label">Current Phase:</div>
                    <div><span id="currentPhase" class="status-badge systematic-phase">Systematic Phase: 0/0
                            chunks</span></div>
                </div>
                <div class="info-row">
                    <div class="info-label">Systematic Packets:</div>
                    <div id="systematicPackets">0</div>
                </div>
                <div class="info-row">
                    <div class="info-label">Fountain Packets:</div>
                    <div id="fountainPackets">0</div>
                </div>
                <div class="info-row">
                    <div class="info-label">Decoding Efficiency:</div>
                    <div id="decodingEfficiency">0%</div>
                </div>

                <button id="downloadFileBtn" class="download-button" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                        stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    Download File
                </button>

                <div class="debug-options">
                    <div class="control-group">
                        <div class="control-row">
                            <label class="switch-container">
                                <input type="checkbox" id="saveChunksManifestSwitch" checked>
                                <span class="slider"></span>
                                <span class="label-text">Save Chunks Manifest</span>
                                <span class="tooltip"
                                    data-tooltip="Enable to save a manifest file with metadata about decoded chunks">?</span>
                            </label>
                        </div>
                        <button id="fileManifestSaveBtn" class="debug-button">Save Manifest Now</button>
                    </div>
                </div>
            </div>

            <div id="decodingStatus" class="info-panel">
                <h3>Status</h3>
                <div class="info-row">
                    <div class="info-label">Camera:</div>
                    <div><span id="cameraStatus" class="status-badge inactive">Inactive</span></div>
                </div>
                <div class="info-row">
                    <div class="info-label">Processing:</div>
                    <div><span id="processingStatus" class="status-badge inactive">Inactive</span></div>
                </div>
                <div class="info-row">
                    <div class="info-label">Decoding:</div>
                    <div><span id="decodingStatusBadge" class="status-badge inactive">Inactive</span></div>
                </div>
                <div class="info-row">
                    <div class="info-label">High Density Mode:</div>
                    <div><span id="highDensityStatus" class="status-badge inactive">Disabled</span></div>
                </div>
                <div class="info-row">
                    <div class="info-label">Workers:</div>
                    <div id="workerStatus">0 active</div>
                </div>
                <div class="info-row">
                    <div class="info-label">Last Frame:</div>
                    <div id="lastFrameTime">-</div>
                </div>

                <h3>QR Code Statistics</h3>
                <div class="stats-container">
                    <div class="stat-box">
                        <div class="stat-value" id="qrTotalDetected">0</div>
                        <div class="stat-label">Total Detected</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="qrUniqueChunks">0</div>
                        <div class="stat-label">Unique Chunks</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="qrDuplicates">0</div>
                        <div class="stat-label">Duplicates</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="qrInvalidFormat">0</div>
                        <div class="stat-label">Invalid Format</div>
                    </div>
                </div>
                <div class="stats-container">
                    <div class="stat-box">
                        <div class="stat-value" id="qrMetadataChunks">0</div>
                        <div class="stat-label">Metadata Chunks</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="qrDataChunks">0</div>
                        <div class="stat-label">Data Chunks</div>
                    </div>
                </div>
                <h4>Error Tracking</h4>
                <div class="stats-container error-tracking-container">
                    <div class="stat-box error-stat">
                        <div class="stat-value" id="qrNotReadable">0</div>
                        <div class="stat-label">Not Readable</div>
                    </div>
                    <div class="stat-box error-stat">
                        <div class="stat-value" id="qrInvalidFormatErr">0</div>
                        <div class="stat-label">Invalid Format</div>
                    </div>
                    <div class="stat-box error-stat">
                        <div class="stat-value" id="qrFailedIntegrity">0</div>
                        <div class="stat-label">Failed Integrity</div>
                    </div>
                    <div class="stat-box error-stat">
                        <div class="stat-value" id="qrNotCorrectable">0</div>
                        <div class="stat-label">Not Correctable</div>
                    </div>
                </div>
                <div class="info-row">
                    <div class="info-label">QR Rate:</div>
                    <div id="qrDetectionRate">0 per second</div>
                </div>
                <div class="info-row">
                    <div class="info-label">Last Unique:</div>
                    <div id="lastUniqueTime">-</div>
                </div>

                <button id="resetDecoderBtn" class="danger" style="margin-top: 15px; width: 100%;">Reset
                    Decoder</button>
            </div>

            <div id="debugPanelContainer" class="debug-panel-container" style="display: none;">
                <div class="debug-panel-header">
                    <h3>Debug Console</h3>
                    <div class="log-level-controls">
                        <label><input type="checkbox" id="logLevelVerbose" checked> Verbose</label>
                        <label><input type="checkbox" id="logLevelInfo" checked> Info</label>
                        <label><input type="checkbox" id="logLevelWarning" checked> Warnings</label>
                        <label><input type="checkbox" id="logLevelError" checked> Errors</label>
                        <label><input type="checkbox" id="logLevelSuccess" checked> Success</label>
                        <button id="clearLogsBtn" title="Clear logs">Clear</button>
                    </div>
                </div>
                <div id="debugPanel" class="debug-panel">
                    <div class="debug-entry">Debug information will appear here when debug mode is enabled</div>
                </div>
            </div>
        </div>
    </div>

    <div id="notification" class="notification">
        Notification message
    </div>

    <!-- Worker script with enhanced detection capabilities -->
    <script id="workerScript" type="javascript/worker">// Fixed worker script that ensures jsQR is properly loaded
        // Define variables
        let jsQR = null;
        let isLibraryLoaded = false;
        let pendingTasks = [];
        
        // Function to process tasks when library is ready
        function processPendingTasks() {
            while (pendingTasks.length > 0) {
                const task = pendingTasks.shift();
                processTask(task.data);
            }
        }
        
        // Function to process a detection task
        function processTask(data) {
            const { id, imageData, highDensityMode } = data;
            
            try {
                // Verify jsQR is available
                if (typeof jsQR !== 'function') {
                    throw new Error('jsQR library not available');
                }
                
                // Verify image data
                if (!imageData || !imageData.data || !imageData.width || !imageData.height) {
                    throw new Error('Invalid image data');
                }
                
                // Create a properly structured ImageData object for jsQR
                const clampedArray = new Uint8ClampedArray(imageData.data.buffer);
                
                // Enhanced detection options
                const options = {
                    inversionAttempts: highDensityMode ? "attemptBoth" : "dontInvert",
                    canOverwriteImage: true,
                    greyScaleWeights: {
                        red: 0.3,
                        green: 0.59,
                        blue: 0.11
                    }
                };
                
                // Detect QR code
                const code = jsQR(
                    clampedArray,
                    imageData.width,
                    imageData.height,
                    options
                );
                
                // Send back results
                if (code) {
                    // Validate and sanitize the location data
                    let sanitizedLocation = null;
                    
                    try {
                        if (code.location && 
                            code.location.topLeft && typeof code.location.topLeft.x === 'number' && typeof code.location.topLeft.y === 'number' &&
                            code.location.topRight && typeof code.location.topRight.x === 'number' && typeof code.location.topRight.y === 'number' &&
                            code.location.bottomLeft && typeof code.location.bottomLeft.x === 'number' && typeof code.location.bottomLeft.y === 'number' &&
                            code.location.bottomRight && typeof code.location.bottomRight.x === 'number' && typeof code.location.bottomRight.y === 'number'
                        ) {
                            // Create a proper location object with validated coordinates
                            sanitizedLocation = {
                                topLeft: { 
                                    x: Math.round(code.location.topLeft.x), 
                                    y: Math.round(code.location.topLeft.y) 
                                },
                                topRight: { 
                                    x: Math.round(code.location.topRight.x), 
                                    y: Math.round(code.location.topRight.y) 
                                },
                                bottomLeft: { 
                                    x: Math.round(code.location.bottomLeft.x), 
                                    y: Math.round(code.location.bottomLeft.y) 
                                },
                                bottomRight: { 
                                    x: Math.round(code.location.bottomRight.x), 
                                    y: Math.round(code.location.bottomRight.y) 
                                }
                            };
                        } else {
                            console.log("QR location data invalid or incomplete, sending null location");
                        }
                    } catch (locationError) {
                        console.error("Error sanitizing location data:", locationError);
                    }
                    
                    self.postMessage({
                        id,
                        success: true,
                        data: code.data,
                        location: sanitizedLocation
                    });
                } else {
                    self.postMessage({
                        id,
                        success: false,
                        error: 'No QR code detected'
                    });
                }
            } catch (error) {
                self.postMessage({
                    id,
                    success: false,
                    error: error.message,
                    stack: error.stack
                });
            }
        }
        
        // Function to load jsQR library with retries
        function loadJsQrLibrary(retryCount = 0) {
            try {
                // Try to import the library
                self.importScripts('https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js');
                
                // Check if jsQR is defined and is a function
                if (typeof self.jsQR === 'function') {
                    jsQR = self.jsQR;
                    isLibraryLoaded = true;
                    
                    self.postMessage({ 
                        type: 'ready',
                        status: 'jsQR library loaded successfully'
                    });
                    
                    // Process any pending tasks
                    processPendingTasks();
                } else {
                    throw new Error('jsQR not found after import');
                }
            } catch (error) {
                if (retryCount < 3) {
                    // Retry loading after a delay
                    setTimeout(() => {
                        loadJsQrLibrary(retryCount + 1);
                    }, 500);
                } else {
                    self.postMessage({ 
                        type: 'error',
                        error: `Failed to load jsQR library after ${retryCount} attempts: ${error.message}`
                    });
                }
            }
        }
        
        // Load the jsQR library when worker starts
        loadJsQrLibrary();
        
        // Listen for messages from main thread
        self.addEventListener('message', function(e) {
            if (!e.data || !e.data.type) return;
            
            const { type } = e.data;
            
            if (type === 'detect') {
                if (isLibraryLoaded) {
                    // Process immediately if library is loaded
                    processTask(e.data);
                } else {
                    // Queue the task for later
                    pendingTasks.push({ data: e.data });
                    
                    self.postMessage({
                        id: e.data.id,
                        type: 'pending',
                        message: 'Task queued while waiting for jsQR library to load'
                    });
                }
            } else if (type === 'ping') {
                // Simple ping response to check worker health
                self.postMessage({
                    id: e.data.id,
                    type: 'pong',
                    libraryLoaded: isLibraryLoaded,
                    time: Date.now()
                });
            } else if (type === 'checkLibrary') {
                // Report library status
                self.postMessage({
                    id: e.data.id,
                    type: 'libraryStatus',
                    loaded: isLibraryLoaded,
                    global: typeof self.jsQR === 'function',
                    local: typeof jsQR === 'function'
                });
            }
        });
    </script>

    <script>
        /**
         * improved-text-handling.js
         * Enhanced text processing utilities for QR code decoding
         */

        /**
         * Detects if content is likely base64-encoded
         * @param {string} content - The string to check
         * @returns {boolean} - True if content is likely base64-encoded
         */
        function isLikelyBase64(content) {
            // Check if content matches base64 pattern
            const base64Pattern = /^[A-Za-z0-9+/]*={0,2}$/;

            // Base64 strings are typically multiples of 4 in length or have padding
            const hasValidLength = content.length % 4 === 0 || content.endsWith('=') || content.endsWith('==');

            // Base64 should have a reasonable ratio of base64 characters
            const base64Ratio = (content.match(/[A-Za-z0-9+/=]/g) || []).length / content.length;

            // Check for common base64 prefixes
            const hasBase64Prefix = content.startsWith('data:') && content.includes(';base64,');

            // If it has an explicit base64 prefix, it's definitely base64
            if (hasBase64Prefix) {
                return true;
            }

            // For regular content, it should match the pattern, have valid length, and high base64 ratio
            return base64Pattern.test(content) && hasValidLength && base64Ratio > 0.98;
        }

        /**
         * Attempts to decode base64 content
         * @param {string} content - The base64 string to decode
         * @returns {string|null} - Decoded content or null if decoding failed
         */
        function tryDecodeBase64(content) {
            try {
                // Extract the base64 content if it has a data URL prefix
                let base64Content = content;
                if (content.includes(';base64,')) {
                    base64Content = content.split(';base64,')[1];
                }

                // Decode the base64 content
                const decoded = atob(base64Content);

                // Check if result is readable text (high percentage of printable ASCII)
                const printableRatio = (decoded.match(/[\x20-\x7E]/g) || []).length / decoded.length;
                if (printableRatio > 0.8) {
                    return decoded;
                }

                // Not readable text, probably binary data
                return null;
            } catch (error) {
                // Decoding failed
                return null;
            }
        }

        /**
         * Cleans binary characters from text content
         * @param {string} content - The string to clean
         * @param {boolean} aggressive - Whether to use aggressive cleaning (default: false)
         * @returns {string} - Cleaned text
         */
        function cleanBinaryCharacters(content, aggressive = false) {
            if (!content) return '';

            // Basic cleaning: remove control characters except tabs and newlines
            let cleaned = content.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');

            if (aggressive) {
                // More aggressive cleaning: keep only printable ASCII plus tabs, newlines
                cleaned = cleaned.replace(/[^\x09\x0A\x0D\x20-\x7E]/g, '');
            } else {
                // Less aggressive: allow extended ASCII and common Unicode but remove unusual characters
                cleaned = cleaned.replace(/[\u0080-\u009F]/g, ''); // Remove C1 control codes

                // Replace null bytes which often indicate binary content
                cleaned = cleaned.replace(/\x00/g, '');
            }

            return cleaned;
        }

        /**
         * Detects if content is likely binary data
         * @param {string} content - The string to check
         * @returns {boolean} - True if content is likely binary
         */
        function isLikelyBinary(content) {
            if (!content) return false;

            // Calculate ratio of non-printable characters
            const nonPrintableCount = (content.match(/[^\x09\x0A\x0D\x20-\x7E]/g) || []).length;
            const binaryRatio = nonPrintableCount / content.length;

            // Check for common binary file signatures
            const hasBinarySignature = /^\x89PNG|\xff\xd8\xff|GIF8|^\x25PDF/.test(content.substring(0, 8));

            // Check for high concentration of null bytes
            const hasHighNullByteCount = (content.match(/\x00/g) || []).length > content.length * 0.05;

            return binaryRatio > 0.1 || hasBinarySignature || hasHighNullByteCount;
        }

        /**
         * Process mixed content to extract readable text
         * @param {string} content - The content to process
         * @returns {object} - Processed result with cleaned text and metadata
         */
        function processMixedContent(content) {
            const result = {
                originalContent: content,
                processedContent: content,
                isBase64: false,
                isBinary: false,
                textExtracted: false,
                processingNotes: []
            };

            // Early return for empty content
            if (!content || content.trim() === '') {
                result.processingNotes.push('Empty content detected');
                return result;
            }

            // Check if content is likely binary
            if (isLikelyBinary(content)) {
                result.isBinary = true;
                result.processingNotes.push('Binary content detected');

                // Try basic cleaning first
                result.processedContent = cleanBinaryCharacters(content, false);

                // If still very binary after basic cleaning, try aggressive cleaning
                if (isLikelyBinary(result.processedContent)) {
                    result.processedContent = cleanBinaryCharacters(content, true);
                    result.processingNotes.push('Aggressive binary cleaning applied');
                } else {
                    result.processingNotes.push('Basic binary cleaning applied');
                }

                result.textExtracted = !isLikelyBinary(result.processedContent);
            }
            // Check if content is base64-encoded
            else if (isLikelyBase64(content)) {
                result.isBase64 = true;
                result.processingNotes.push('Base64 content detected');

                // Try to decode base64
                const decodedContent = tryDecodeBase64(content);

                if (decodedContent) {
                    // If decoded content is binary, clean it
                    if (isLikelyBinary(decodedContent)) {
                        result.isBinary = true;
                        result.processedContent = cleanBinaryCharacters(decodedContent, false);
                        result.processingNotes.push('Decoded base64 contains binary content');
                    } else {
                        result.processedContent = decodedContent;
                        result.processingNotes.push('Successfully decoded base64 to text');
                    }
                    result.textExtracted = true;
                } else {
                    // Decoding failed or produced binary data
                    result.processingNotes.push('Base64 decoding failed or produced non-text content');
                }
            }
            // Regular text content
            else {
                // Apply light cleaning to ensure consistent text handling
                result.processedContent = cleanBinaryCharacters(content, false);
                result.processingNotes.push('Regular text content processed');
                result.textExtracted = true;
            }

            return result;
        }

        /**
         * Extract embedded text from potentially complex content
         * Handles multiple formats including mixed binary and text
         * @param {string} content - The content to process
         * @returns {string} - The best extracted text
         */
        function extractBestText(content) {
            const processed = processMixedContent(content);

            // If text extraction was successful, return the processed content
            if (processed.textExtracted) {
                return processed.processedContent;
            }

            // If text extraction failed but we have binary content,
            // try one more aggressive approach
            if (processed.isBinary) {
                // Look for text chunks in binary data using a sliding window approach
                const textChunks = [];
                let currentChunk = '';

                for (let i = 0; i < content.length; i++) {
                    const char = content.charAt(i);

                    // If character is printable ASCII or common whitespace
                    if (/[\x09\x0A\x0D\x20-\x7E]/.test(char)) {
                        currentChunk += char;
                    } else {
                        // End of text chunk
                        if (currentChunk.length > 10) { // Only keep substantial chunks
                            textChunks.push(currentChunk);
                        }
                        currentChunk = '';
                    }
                }

                // Add the last chunk if substantial
                if (currentChunk.length > 10) {
                    textChunks.push(currentChunk);
                }

                // If we found text chunks, join them with newlines
                if (textChunks.length > 0) {
                    return textChunks.join('\n');
                }
            }

            // Fallback: return original content with aggressive cleaning
            return cleanBinaryCharacters(content, true);
        }

        // Export the functions for use in other modules
        if (typeof module !== 'undefined' && module.exports) {
            module.exports = {
                isLikelyBase64,
                tryDecodeBase64,
                cleanBinaryCharacters,
                isLikelyBinary,
                processMixedContent,
                extractBestText
            };
        } else {
            // Browser environment
            window.improvedTextHandling = {
                isLikelyBase64,
                tryDecodeBase64,
                cleanBinaryCharacters,
                isLikelyBinary,
                processMixedContent,
                extractBestText
            };
        }

        // Define core modules first
        // 1. Debug Manager for logging
        const LogManager = {
            debugPanel: null,
            maxEntries: 100,
            entries: [],
            // Add log level filtering
            logLevels: {
                verbose: true,
                info: true,
                warning: true,
                error: true,
                success: true
            },

            init: function () {
                this.debugPanel = document.getElementById('debugPanel');
                // Initialize debugPanelContainer reference
                this.debugPanelContainer = document.getElementById('debugPanelContainer');

                // Retrieve log level settings from local storage if available
                try {
                    const savedLogLevels = localStorage.getItem('qrDecoder_logLevels');
                    if (savedLogLevels) {
                        this.logLevels = JSON.parse(savedLogLevels);
                    }

                    // Update log checkbox states directly
                    const verboseElement = document.getElementById('logLevelVerbose');
                    const infoElement = document.getElementById('logLevelInfo');
                    const warningElement = document.getElementById('logLevelWarning');
                    const errorElement = document.getElementById('logLevelError');
                    const successElement = document.getElementById('logLevelSuccess');

                    if (verboseElement) verboseElement.checked = this.logLevels.verbose;
                    if (infoElement) infoElement.checked = this.logLevels.info;
                    if (warningElement) warningElement.checked = this.logLevels.warning;
                    if (errorElement) errorElement.checked = this.logLevels.error;
                    if (successElement) successElement.checked = this.logLevels.success;
                } catch (e) {
                    console.error('Error loading log levels:', e);
                }
            },

            // Update log level checkbox states

            // Add method to toggle log levels
            toggleLogLevel: function (level, enabled) {
                if (this.logLevels.hasOwnProperty(level)) {
                    this.logLevels[level] = enabled;
                    // Save to local storage
                    try {
                        localStorage.setItem('qrDecoder_logLevels', JSON.stringify(this.logLevels));
                    } catch (e) {
                        console.error('Error saving log levels:', e);
                    }
                }
            },

            // Minimal implementation for compatibility
            updatePanel: function () {
                // Simplified implementation that just ensures the panel is visible if debug mode is on
                if (this.debugPanel && Core.state.debugMode) {
                    this.debugPanel.style.display = 'block';
                }
            },


            // MODIFICATION: Enhanced logging methods to centralize all console output

            /**
             * Log a debug message (verbose level)
             * @param {string} message - The message to log
             * @param {Object} options - Optional parameters
             * @param {boolean} options.forceConsole - Force console output even if debug mode is off
             */
            debug: function (message, options = {}) {
                this.addEntry(message, 'verbose');
                if (Core.state.debugMode || options.forceConsole) {
                    console.debug(message);
                }
            },

            /**
             * Log a standard message (info level)
             * @param {string} message - The message to log
             * @param {Object} options - Optional parameters
             * @param {boolean} options.forceConsole - Force console output even if debug mode is off
             */
            log: function (message, options = {}) {
                this.addEntry(message, 'info');
                if (Core.state.debugMode || options.forceConsole) {
                    console.log(message);
                }
            },

            /**
             * Log an info message (info level)
             * @param {string} message - The message to log
             * @param {Object} options - Optional parameters
             * @param {boolean} options.forceConsole - Force console output even if debug mode is off
             */
            info: function (message, options = {}) {
                this.addEntry(message, 'info');
                if (Core.state.debugMode || options.forceConsole) {
                    console.info(message);
                }
            },

            /**
             * Log a warning message (warning level)
             * @param {string} message - The message to log
             * @param {Object} options - Optional parameters
             * @param {boolean} options.forceConsole - Force console output even if debug mode is off
             */
            warn: function (message, options = {}) {
                this.addEntry(message, 'warning');
                if (Core.state.debugMode || options.forceConsole) {
                    console.warn(message);
                }
            },

            /**
             * Log an error message (error level) - always appears in console
             * @param {string} message - The message to log
             */
            error: function (message) {
                this.addEntry(message, 'error');
                // Always log errors, even in non-debug mode
                console.error(message);
            },

            /**
             * Log a success message (success level)
             * @param {string} message - The message to log
             * @param {Object} options - Optional parameters
             * @param {boolean} options.forceConsole - Force console output even if debug mode is off
             */
            success: function (message, options = {}) {
                this.addEntry(message, 'success');
                if (Core.state.debugMode || options.forceConsole) {
                    console.log('%c' + message, 'color: green');
                }
            },

            /**
             * Add a colored message to the console
             * @param {string} message - The message to log
             * @param {string} color - CSS color
             * @param {Object} options - Optional parameters
             * @param {boolean} options.forceConsole - Force console output even if debug mode is off
             */
            coloredLog: function (message, color, options = {}) {
                this.addEntry(message, 'info');
                if (Core.state.debugMode || options.forceConsole) {
                    console.log(`%c${message}`, `color: ${color}`);
                }
            },

            addEntry: function (message, type) {
                // Only add entry if the log level is enabled
                if (!this.logLevels[type]) return;

                const timestamp = new Date().toLocaleTimeString();
                this.entries.unshift({ message, type, timestamp });

                // Limit entries
                if (this.entries.length > this.maxEntries) {
                    this.entries.pop();
                }

                // Update panel if initialized
                if (this.debugPanel && Core.state.debugMode) {
                    // No panel update needed
                }
            },


            clear: function () {
                this.entries = [];
                if (this.debugPanel) {
                    this.debugPanel.innerHTML = '';
                }
            }
        };

        // 2. Event Bus for communication between modules
        const EventBus = {
            listeners: {},

            init: function () {
                // Initialize event listeners
                this.listeners = {};
            },

            on: function (event, callback) {
                if (!this.listeners[event]) {
                    this.listeners[event] = [];
                }
                this.listeners[event].push(callback);
                return this; // For chaining
            },

            off: function (event, callback) {
                if (this.listeners[event]) {
                    if (callback) {
                        this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);
                    } else {
                        delete this.listeners[event];
                    }
                }
                return this; // For chaining
            },

            emit: function (event, ...args) {
                if (this.listeners[event]) {
                    this.listeners[event].forEach(callback => {
                        try {
                            callback(...args);
                        } catch (error) {
                            console.error(`Error in event listener for ${event}:`, error);
                            LogManager.error(`Event error (${event}): ${error.message}`);
                        }
                    });
                }
                return this; // For chaining
            }
        };

        // QR Stats Updater for enhanced statistics
        const qrStatsUpdater = {
            lastUpdated: 0,
            updateInterval: 500, // ms

            update: function (stats) {
                const now = Date.now();
                if (now - this.lastUpdated < this.updateInterval) return;

                this.lastUpdated = now;

                // Update statistics in the UI
                try {
                    const statsElement = document.getElementById('qrStats');
                    if (!statsElement) return;

                    let html = '<table class="stats-table">';
                    for (const [key, value] of Object.entries(stats)) {
                        html += `<tr><td>${key}:</td><td>${value}</td></tr>`;
                    }
                    html += '</table>';

                    statsElement.innerHTML = html;
                } catch (error) {
                    console.error("Error updating QR stats:", error);
                }
            }
        };

        // UI Extensions for enhanced functionality
        const UIExtensions = {
            init: function () {
                this.setupEnhancedControls();
                this.setupAdvancedOptions();
            },

            setupEnhancedControls: function () {
                // Setup any enhanced controls
                const enhancedControls = document.querySelectorAll('.enhanced-control');
                enhancedControls.forEach(control => {
                    control.classList.remove('hidden');
                });
            },

            setupAdvancedOptions: function () {
                // Setup advanced options panel
                const advancedPanel = document.getElementById('advancedOptions');
                if (!advancedPanel) return;

                advancedPanel.classList.remove('hidden');
            }
        };

        // 3. UI Manager for interface updates
        const UI = {
            notificationElement: null,
            notificationTimeout: null,
            tabButtons: null,
            tabContents: null,

            init: function () {
                this.notificationElement = document.getElementById('notification');
                this.tabButtons = document.querySelectorAll('.tab-button');
                this.tabContents = document.querySelectorAll('.tab-content');

                // Initialize tab system
                this.tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const tabId = button.getAttribute('data-tab');
                        this.activateTab(tabId);
                    });
                });

                // Activate first tab by default
                this.activateTab(this.tabButtons[0].getAttribute('data-tab'));

                // Update settings UI to match core state
                this.updateSettingsUI();

                // Setup event listeners for settings controls
                this.setupSettingsListeners();

                // Initialize enhanced UI components
                this.initEnhancedUI();

                LogManager.log('UI initialized');
            },

            activateTab: function (tabId) {
                // Start tab transition
                // First, mark current tab as transitioning by setting opacity to 0
                const currentActiveContent = document.querySelector('.tab-content.active');
                if (currentActiveContent) {
                    currentActiveContent.style.opacity = '0';
                }

                // After a short delay for the transition
                setTimeout(() => {
                    // Deactivate all tabs
                    this.tabButtons.forEach(btn => btn.classList.remove('active'));
                    this.tabContents.forEach(content => content.classList.remove('active'));

                    // Activate selected tab
                    const selectedButton = document.querySelector(`.tab-button[data-tab="${tabId}"]`);
                    const selectedContent = document.getElementById(tabId);

                    if (selectedButton && selectedContent) {
                        selectedButton.classList.add('active');
                        selectedContent.classList.add('active');

                        // Ensure new tab is visible with opacity transition
                        setTimeout(() => {
                            selectedContent.style.opacity = '1';
                        }, 50);
                    }
                }, 150);
            },

            showNotification: function (message, type = 'info') {
                if (!this.notificationElement) return;

                // Clear any existing timeout
                if (this.notificationTimeout) {
                    clearTimeout(this.notificationTimeout);
                }

                // Update notification message and type
                this.notificationElement.textContent = message;
                this.notificationElement.className = 'notification';

                if (type) {
                    this.notificationElement.classList.add(type);
                }

                // Show notification
                this.notificationElement.classList.add('show');

                // Hide after 3 seconds
                this.notificationTimeout = setTimeout(() => {
                    this.notificationElement.classList.remove('show');
                }, 3000);
            },

            updateStats: function () {
                try {
                    // Update statistics displays
                    const framesProcessedElement = document.getElementById('framesProcessed');
                    if (framesProcessedElement) {
                        framesProcessedElement.textContent = Core.state.frameCounter;
                    }

                    // Show unique QR codes detected instead of total QR codes
                    const qrCodesDetectedElement = document.getElementById('qrCodesDetected');
                    if (qrCodesDetectedElement && FountainDecoder && FountainDecoder.processingStats) {
                        qrCodesDetectedElement.textContent =
                            parseInt(FountainDecoder.processingStats.uniqueChunksReceived) || 0;
                    }

                    // Display chunks recovered as a percentage with format "X / Y (Z%)"
                    const fileInfo = FountainDecoder.fileMetadata;
                    let chunksPercent = '--';
                    let recoveredChunks = 0;
                    let totalChunks = '?';

                    // Get number of recovered chunks
                    recoveredChunks = parseInt(FountainDecoder.processingStats.uniqueChunksReceived) || 0;

                    // Get total chunks if available
                    if (fileInfo && fileInfo.totalChunks) {
                        totalChunks = fileInfo.totalChunks;
                        // Calculate percentage only if we have valid totalChunks
                        if (totalChunks > 0) {
                            chunksPercent = Math.round((recoveredChunks / totalChunks) * 100);
                        }
                    }

                    // Update systematic and fountain packet information
                    if (document.getElementById('systematicPackets')) {
                        document.getElementById('systematicPackets').textContent =
                            FountainDecoder.systematic_packets_received || 0;
                    }

                    if (document.getElementById('fountainPackets')) {
                        document.getElementById('fountainPackets').textContent =
                            FountainDecoder.fountain_packets_received || 0;
                    }

                    // Update efficiency information
                    if (document.getElementById('decodingEfficiency')) {
                        const efficiency = FountainDecoder.decoding_efficiency || 0;
                        document.getElementById('decodingEfficiency').textContent =
                            `${(efficiency * 100).toFixed(1)}%`;
                    }

                    // Update phase indicator
                    if (document.getElementById('currentPhase')) {
                        const phaseElement = document.getElementById('currentPhase');
                        if (FountainDecoder.systematic_phase_complete) {
                            phaseElement.textContent = `Fountain Phase: ${FountainDecoder.fountain_packets_received} redundant packets`;
                            phaseElement.className = 'status-badge fountain-phase';
                        } else {
                            phaseElement.textContent = `Systematic Phase: ${FountainDecoder.systematic_packets_received}/${totalChunks} chunks`;
                            phaseElement.className = 'status-badge systematic-phase';
                        }
                    }

                    // Format display string: "X / Y (Z%)"
                    const displayString = `${recoveredChunks} / ${totalChunks} (${chunksPercent}%)`;
                    const chunksRecoveredElement = document.getElementById('chunksRecovered');
                    if (chunksRecoveredElement) {
                        chunksRecoveredElement.textContent = displayString;
                    }

                    // Calculate QR Code/Frame Rate (renamed from Success Rate)
                    const successRate = Core.state.frameCounter > 0
                        ? Math.round((Core.state.qrCodesDetected / Core.state.frameCounter) * 100)
                        : 0;
                    document.getElementById('successRate').textContent = successRate + '%';

                    // Update error tracking statistics
                    const notReadableElement = document.getElementById('notReadableQR');
                    const invalidFormatElement = document.getElementById('invalidFormatQR');
                    const failedIntegrityElement = document.getElementById('failedIntegrityQR');

                    if (notReadableElement) {
                        notReadableElement.textContent = Core.state.qrErrorStats.notReadable || 0;
                    }

                    if (invalidFormatElement) {
                        invalidFormatElement.textContent = Core.state.qrErrorStats.invalidFormat || 0;
                    }

                    if (failedIntegrityElement) {
                        failedIntegrityElement.textContent = Core.state.qrErrorStats.failedIntegrity || 0;
                    }

                    // Update last frame time
                    const lastFrameTimeElement = document.getElementById('lastFrameTime');
                    if (Core.state.lastFrameTime && lastFrameTimeElement) {
                        const elapsed = new Date() - Core.state.lastFrameTime;
                        lastFrameTimeElement.textContent = `${elapsed}ms ago`;
                    }

                    // Debug: Update QR statistics display from FountainDecoder's processingStats
                    try {
                        if (FountainDecoder && FountainDecoder.processingStats) {
                            const stats = FountainDecoder.processingStats;

                            // Update the QR statistics in the UI with explicit type conversion to ensure numbers
                            const qrTotalDetectedElement = document.getElementById('qrTotalDetected');
                            const qrUniqueChunksElement = document.getElementById('qrUniqueChunks');
                            const qrDuplicatesElement = document.getElementById('qrDuplicates');
                            const qrInvalidFormatElement = document.getElementById('qrInvalidFormat');
                            const qrMetadataChunksElement = document.getElementById('qrMetadataChunks');
                            const qrDataChunksElement = document.getElementById('qrDataChunks');

                            // Error tracking elements
                            const qrNotReadableElement = document.getElementById('qrNotReadable');
                            const qrInvalidFormatErrElement = document.getElementById('qrInvalidFormatErr');
                            const qrFailedIntegrityElement = document.getElementById('qrFailedIntegrity');
                            const qrNotCorrectableElement = document.getElementById('qrNotCorrectable');

                            // Update elements if they exist
                            if (qrTotalDetectedElement) {
                                qrTotalDetectedElement.textContent = parseInt(stats.totalQrDetected) || 0;
                            }

                            if (qrUniqueChunksElement) {
                                qrUniqueChunksElement.textContent = parseInt(stats.uniqueChunksReceived) || 0;
                            }

                            if (qrDuplicatesElement) {
                                qrDuplicatesElement.textContent = parseInt(stats.duplicateChunks) || 0;
                            }

                            if (qrInvalidFormatElement) {
                                qrInvalidFormatElement.textContent = parseInt(stats.invalidFormats) || 0;
                            }

                            if (qrMetadataChunksElement) {
                                qrMetadataChunksElement.textContent = parseInt(stats.metadataChunks) || 0;
                            }

                            if (qrDataChunksElement) {
                                qrDataChunksElement.textContent = parseInt(stats.dataPackets) || 0;
                            }

                            // Update error tracking statistics
                            if (qrNotReadableElement) {
                                qrNotReadableElement.textContent = Core.state.qrErrorStats.notReadable || 0;
                            }

                            if (qrInvalidFormatErrElement) {
                                qrInvalidFormatErrElement.textContent = Core.state.qrErrorStats.invalidFormat || 0;
                            }

                            if (qrFailedIntegrityElement) {
                                qrFailedIntegrityElement.textContent = Core.state.qrErrorStats.failedIntegrity || 0;
                            }

                            if (qrNotCorrectableElement) {
                                qrNotCorrectableElement.textContent = Core.state.qrErrorStats.notCorrectable || 0;
                            }

                            // Log detailed QR stats to help with debugging
                            console.log("QR STATS UPDATE:", {
                                totalDetected: stats.totalQrDetected,
                                uniqueChunks: stats.uniqueChunksReceived,
                                duplicates: stats.duplicateChunks,
                                invalidFormats: stats.invalidFormats,
                                metadataChunks: stats.metadataChunks,
                                dataPackets: stats.dataPackets,
                                errorStats: Core.state.qrErrorStats
                            });

                            LogManager.log(`Updated QR stats: Total=${stats.totalQrDetected}, Unique=${stats.uniqueChunksReceived}`);
                        } else {
                            console.warn("FountainDecoder.processingStats not available");
                        }
                    } catch (e) {
                        console.error("Error updating QR stats:", e);
                    }
                } catch (outerError) {
                    console.error("Critical error in updateStats:", outerError);
                }
            },

            initEnhancedUI: function () {
                // Initialize UI extensions
                UIExtensions.init();

                // Set up interval to update stats and last unique time
                setInterval(() => {
                    if (document.getElementById('lastUniqueTime')) {
                        const element = document.getElementById('lastUniqueTime');
                        const lastTime = FountainDecoder.lastUniquePacketTime;

                        if (lastTime === 0) {
                            element.textContent = '-';
                            return;
                        }

                        const now = Date.now();
                        const elapsed = now - lastTime;

                        // Format elapsed time
                        if (elapsed < 1000) {
                            element.textContent = 'just now';
                        } else if (elapsed < 60000) {
                            element.textContent = `${Math.floor(elapsed / 1000)}s ago`;
                        } else if (elapsed < 3600000) {
                            element.textContent = `${Math.floor(elapsed / 60000)}m ago`;
                        } else {
                            element.textContent = `${Math.floor(elapsed / 3600000)}h ago`;
                        }
                    }

                    if (document.getElementById('qrDetectionRate')) {
                        this.updateQrDetectionRate();
                    }
                }, 1000);

                // Create stats container if it doesn't exist
                const debugPanel = document.querySelector('.debug-panel');
                if (!document.getElementById('qrStats') && debugPanel) {
                    const statsContainer = document.createElement('div');
                    statsContainer.id = 'qrStats';
                    statsContainer.className = 'stats-container';
                    debugPanel.appendChild(statsContainer);
                }

                // Add enhanced UI elements
                const controlPanel = document.querySelector('.control-panel');
                if (controlPanel) {
                    // Add any additional enhanced UI elements here
                    const enhancedControls = document.createElement('div');
                    enhancedControls.className = 'enhanced-controls';
                    enhancedControls.innerHTML = `
                        <div class="control-group enhanced-control hidden">
                            <label for="enhancedMode">Enhanced Mode</label>
                            <input type="checkbox" id="enhancedMode" checked>
                        </div>
                    `;
                    controlPanel.appendChild(enhancedControls);
                }

                LogManager.log('Enhanced UI initialized');
            },

            // Update QR detection rate
            updateQrDetectionRate: function () {
                // Static variables to track rate calculation
                if (!this._lastStatUpdate) this._lastStatUpdate = Date.now();
                if (!this._lastQrCountValue) this._lastQrCountValue = 0;

                const now = Date.now();
                const element = document.getElementById('qrDetectionRate');
                if (!element) return;

                // Get current total from FountainDecoder stats
                const currentTotal = FountainDecoder.processingStats.totalQrDetected;

                // Calculate time elapsed since last update in seconds
                const elapsedSec = (now - this._lastStatUpdate) / 1000;

                // Calculate rate
                const qrsDetected = currentTotal - this._lastQrCountValue;
                const rate = elapsedSec > 0 ? (qrsDetected / elapsedSec).toFixed(1) : 0;

                // Update display
                element.textContent = `${rate} per second`;

                // Store values for next calculation
                this._lastStatUpdate = now;
                this._lastQrCountValue = currentTotal;
            },

            updateSettingsUI: function () {
                // Update UI to match current settings
                document.getElementById('highDensitySwitch').checked = Core.state.highDensityMode;
                document.getElementById('debugModeSwitch').checked = Core.state.debugMode;
                document.getElementById('showDebugCanvasSwitch').checked = Core.state.showDebugCanvas;
                document.getElementById('showScanOverlaySwitch').checked = Core.state.showScanOverlay;

                // Update worker count slider
                const workerCountSlider = document.getElementById('workerCountSlider');
                const workerCountValue = document.getElementById('workerCountValue');
                if (workerCountSlider) {
                    workerCountSlider.value = Core.state.workerCount;
                }
                if (workerCountValue) {
                    workerCountValue.textContent = Core.state.workerCount;
                }

                // MODIFICATION: Update scan rate slider instead of dropdown
                const scanRateSlider = document.getElementById('scanRateSlider');
                const scanRateValue = document.getElementById('scanRateValue');
                if (scanRateSlider) {
                    scanRateSlider.value = Core.state.scanRate;
                }
                if (scanRateValue) {
                    scanRateValue.textContent = `${Core.state.scanRate} FPS`;
                }
                document.getElementById('imageProcessingSelect').value = Core.state.imageProcessing;

                // Properly handle scale factor setting - convert to string to ensure matching
                const scaleFactorSelect = document.getElementById('scaleFactorSelect');
                if (scaleFactorSelect) {
                    // Check if the value exists in the dropdown options
                    const scaleFactorValue = Core.state.scaleFactor.toString();
                    const optionExists = Array.from(scaleFactorSelect.options).some(option => option.value === scaleFactorValue);

                    if (optionExists) {
                        scaleFactorSelect.value = scaleFactorValue;
                    } else {
                        // If value doesn't exist in options, default to 0.5 (50%)
                        scaleFactorSelect.value = '1';
                        Core.state.scaleFactor = 1;
                        LogManager.log('Invalid scale factor value detected, reset to 0.5 (50%)');
                    }
                }

                // Update high density status badge
                const highDensityStatus = document.getElementById('highDensityStatus');
                if (Core.state.highDensityMode) {
                    highDensityStatus.textContent = 'Enabled';
                    highDensityStatus.className = 'status-badge active';
                } else {
                    highDensityStatus.textContent = 'Disabled';
                    highDensityStatus.className = 'status-badge inactive';
                }

                // Update debug panel visibility
                this.debugPanelContainer = document.getElementById('debugPanelContainer');
                if (this.debugPanelContainer) {
                    this.debugPanelContainer.style.display = Core.state.debugMode ? 'block' : 'none';
                }

                // MODIFICATION: Update debug canvas visibility based on settings
                const debugCanvas = document.getElementById('debugCanvas');
                const videoDebugCanvas = document.getElementById('videoDebugCanvas');

                if (debugCanvas) {
                    debugCanvas.style.display = Core.state.showDebugCanvas ? 'block' : 'none';
                }

                if (videoDebugCanvas) {
                    videoDebugCanvas.style.display = Core.state.showDebugCanvas ? 'block' : 'none';
                }

                // Log debug canvas state for troubleshooting
                if (Core.state.debugMode) {
                    LogManager.log(`Debug canvas visibility: ${Core.state.showDebugCanvas ? 'visible' : 'hidden'}`);
                }
            },

            setupSettingsListeners: function () {
                // Set up event listeners for all settings controls

                // Switches
                document.getElementById('highDensitySwitch').addEventListener('change', function (e) {
                    Core.state.highDensityMode = e.target.checked;
                    UI.updateSettingsUI();
                    LogManager.log(`High density mode ${e.target.checked ? 'enabled' : 'disabled'}`);
                });

                document.getElementById('debugModeSwitch').addEventListener('change', function (e) {
                    Core.state.debugMode = e.target.checked;
                    UI.updateSettingsUI();
                    LogManager.log(`Debug mode ${e.target.checked ? 'enabled' : 'disabled'}`);

                    // Show or hide the debug panel container
                    const debugPanelContainer = document.getElementById('debugPanelContainer');
                    if (debugPanelContainer) {
                        debugPanelContainer.style.display = e.target.checked ? 'block' : 'none';
                    }
                });

                // Add event listeners for log level filters
                const verboseElement = document.getElementById('logLevelVerbose');
                const infoElement = document.getElementById('logLevelInfo');
                const warningElement = document.getElementById('logLevelWarning');
                const errorElement = document.getElementById('logLevelError');
                const successElement = document.getElementById('logLevelSuccess');
                const clearLogsBtn = document.getElementById('clearLogsBtn');

                if (verboseElement) {
                    verboseElement.addEventListener('change', function (e) {
                        LogManager.toggleLogLevel('verbose', e.target.checked);
                    });
                }

                if (infoElement) {
                    infoElement.addEventListener('change', function (e) {
                        LogManager.toggleLogLevel('info', e.target.checked);
                    });
                }

                if (warningElement) {
                    warningElement.addEventListener('change', function (e) {
                        LogManager.toggleLogLevel('warning', e.target.checked);
                    });
                }

                if (errorElement) {
                    errorElement.addEventListener('change', function (e) {
                        LogManager.toggleLogLevel('error', e.target.checked);
                    });
                }

                if (successElement) {
                    successElement.addEventListener('change', function (e) {
                        LogManager.toggleLogLevel('success', e.target.checked);
                    });
                }

                // Add clear logs button functionality
                if (clearLogsBtn) {
                    clearLogsBtn.addEventListener('click', function () {
                        LogManager.clear();
                        LogManager.log('Logs cleared');
                    });
                }

                document.getElementById('showDebugCanvasSwitch').addEventListener('change', function (e) {
                    Core.state.showDebugCanvas = e.target.checked;
                    // Update both debug canvases
                    const cameraDebugCanvas = document.getElementById('debugCanvas');
                    const videoDebugCanvas = document.getElementById('videoDebugCanvas');

                    if (cameraDebugCanvas) {
                        cameraDebugCanvas.style.display = e.target.checked ? 'block' : 'none';
                    }

                    if (videoDebugCanvas) {
                        videoDebugCanvas.style.display = e.target.checked ? 'block' : 'none';
                    }

                    LogManager.log(`Debug canvas ${e.target.checked ? 'shown' : 'hidden'}`);

                    // Save to local storage
                    Core.saveSettings();
                });

                document.getElementById('showScanOverlaySwitch').addEventListener('change', function (e) {
                    Core.state.showScanOverlay = e.target.checked;
                    LogManager.log(`Scan overlay ${e.target.checked ? 'enabled' : 'disabled'}`);
                    // Save to local storage
                    Core.saveSettings();
                });

                // Dropdowns
                // Worker count slider
                document.getElementById('workerCountSlider').addEventListener('input', function (e) {
                    const count = parseInt(e.target.value);
                    // Update display value
                    const workerCountValue = document.getElementById('workerCountValue');
                    if (workerCountValue) {
                        workerCountValue.textContent = count;
                    }
                });

                document.getElementById('workerCountSlider').addEventListener('change', function (e) {
                    const count = parseInt(e.target.value);
                    Core.state.workerCount = count;
                    WorkerPool.createWorkers(count);

                    // Add performance warning for high counts
                    if (count > 8) {
                        LogManager.warn(`High worker count (${count}) may impact device performance on mobile`);
                    }

                    LogManager.log(`Worker count changed to ${count}${count > 8 ? ' (high performance mode)' : ''}`);
                    // Save to local storage
                    Core.saveSettings();
                });

                // MODIFICATION: Use scan rate slider instead of dropdown
                document.getElementById('scanRateSlider').addEventListener('input', function (e) {
                    const fps = parseInt(e.target.value);
                    Core.state.scanRate = fps;

                    // Update the display value
                    const scanRateValue = document.getElementById('scanRateValue');
                    if (scanRateValue) {
                        scanRateValue.textContent = `${fps} FPS`;
                    }

                    LogManager.log(`Scan rate changed to ${fps} FPS`);

                    // Save to local storage
                    Core.saveSettings();

                    // If camera is active, restart capture with new rate
                    if (CameraManager.captureInterval) {
                        CameraManager.stopCapture();
                        CameraManager.startCapture();
                    }
                });

                document.getElementById('imageProcessingSelect').addEventListener('change', function (e) {
                    Core.state.imageProcessing = e.target.value;
                    LogManager.log(`Image processing mode set to ${e.target.value}`);
                    // Save to local storage
                    Core.saveSettings();
                });

                document.getElementById('scaleFactorSelect').addEventListener('change', function (e) {
                    Core.state.scaleFactor = parseFloat(e.target.value);
                    LogManager.log(`Scale factor set to ${Core.state.scaleFactor}`);
                    // Save to local storage
                    Core.saveSettings();
                });

                // Buttons
                document.getElementById('resetSettingsBtn').addEventListener('click', function () {
                    Core.resetSettings();
                    UI.updateSettingsUI();
                    UI.showNotification('Settings reset to defaults', 'info');
                });

                // Add event listener for reset decoder button
                const resetBtn = document.getElementById('resetDecoderBtn');
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => {
                        FountainDecoder.reset();
                        UI.showNotification('Decoder reset', 'info');
                    });
                }

                document.getElementById('captureFrameBtn').addEventListener('click', function () {
                    CameraManager.captureStillFrame();
                });

                document.getElementById('saveChunksBtn').addEventListener('click', function () {
                    if (!Core.state.enableSaveChunksManifest) {
                        UI.showNotification('Save Chunks Manifest feature is disabled', 'warning');
                        return;
                    }

                    if (FountainDecoder && FountainDecoder.chunks && FountainDecoder.chunks.length > 0) {
                        // Save all chunk data in a single manifest file
                        FountainDecoder.saveAllChunks();
                        UI.showNotification('Comprehensive manifest file with all chunk data saved', 'success');
                    } else {
                        UI.showNotification('No chunks available to save', 'error');
                    }
                });

                // Add event listener for the fileManifestSaveBtn button
                document.getElementById('fileManifestSaveBtn')?.addEventListener('click', function () {
                    if (!Core.state.enableSaveChunksManifest) {
                        UI.showNotification('Save Chunks Manifest feature is disabled', 'warning');
                        return;
                    }

                    if (FountainDecoder && FountainDecoder.chunks && FountainDecoder.chunks.length > 0) {
                        // Save all chunk data in a single manifest file
                        FountainDecoder.saveAllChunks();
                        UI.showNotification('Comprehensive manifest file with all chunk data saved', 'success');
                    } else {
                        UI.showNotification('No chunks available to save', 'error');
                    }
                });

                // Add event listener for the saveChunksManifestSwitch toggle
                document.getElementById('saveChunksManifestSwitch')?.addEventListener('change', function (e) {
                    Core.state.enableSaveChunksManifest = e.target.checked;
                    LogManager.log(`Save Chunks Manifest ${e.target.checked ? 'enabled' : 'disabled'}`);

                    // Update button state for both save buttons
                    const saveChunksBtn = document.getElementById('saveChunksBtn');
                    const fileManifestSaveBtn = document.getElementById('fileManifestSaveBtn');

                    if (saveChunksBtn) {
                        saveChunksBtn.disabled = !e.target.checked;
                        if (!e.target.checked) {
                            saveChunksBtn.title = "Save Chunks Manifest feature is disabled";
                        } else {
                            saveChunksBtn.title = "";
                        }
                    }

                    if (fileManifestSaveBtn) {
                        fileManifestSaveBtn.disabled = !e.target.checked;
                        if (!e.target.checked) {
                            fileManifestSaveBtn.title = "Save Chunks Manifest feature is disabled";
                        } else {
                            fileManifestSaveBtn.title = "";
                        }
                    }

                    // Save to local storage
                    Core.saveSettings();
                });
            },

            updateProgressBar: function (percent) {
                const progressBar = document.getElementById('progressBar');
                if (progressBar) {
                    progressBar.style.width = `${percent}%`;
                }
            },

            // Moved event listener for resetDecoderBtn to setupSettingsListeners

            // Track recently received chunks for animations
            _lastReceivedChunks: new Set(),

            updateChunkGrid: function (totalChunks, receivedChunks) {
                const chunkGrid = document.getElementById('chunkGrid');
                if (!chunkGrid) return;

                // Clear existing grid
                chunkGrid.innerHTML = '';

                // If no chunks yet, show a placeholder
                if (totalChunks === 0) {
                    const placeholderItem = document.createElement('div');
                    placeholderItem.className = 'grid-item placeholder';
                    placeholderItem.textContent = 'Waiting for metadata...';
                    placeholderItem.style.gridColumn = 'span 10';
                    placeholderItem.style.display = 'flex';
                    placeholderItem.style.justifyContent = 'center';
                    placeholderItem.style.alignItems = 'center';
                    placeholderItem.style.height = '40px';
                    chunkGrid.appendChild(placeholderItem);
                    return;
                }

                // Debug information about chunks
                if (Core.state.debugMode) {
                    console.log(`Updating chunk grid: total=${totalChunks}, received=${receivedChunks.length}`);
                    console.log("Received chunks:", receivedChunks);
                }

                // Determine newly received chunks - those in receivedChunks but not in _lastReceivedChunks
                const newlyReceivedChunks = new Set();
                receivedChunks.forEach(id => {
                    const numId = typeof id === 'string' ? parseInt(id) : id;
                    if (!this._lastReceivedChunks.has(numId)) {
                        newlyReceivedChunks.add(numId);
                    }
                });

                // Update _lastReceivedChunks for next time
                this._lastReceivedChunks = new Set(receivedChunks.map(id => typeof id === 'string' ? parseInt(id) : id));

                // Create grid items for all chunks
                for (let i = 0; i < totalChunks; i++) {
                    const gridItem = document.createElement('div');
                    gridItem.className = 'grid-item';
                    gridItem.title = `Chunk ${i}`;

                    // Mark received chunks - convert all to string to ensure matching
                    const stringId = i.toString();
                    const isReceived = receivedChunks.some(id =>
                        id.toString() === stringId ||
                        parseInt(id) === i);

                    // Check if this chunk was just received
                    const isJustReceived = newlyReceivedChunks.has(i);

                    if (isJustReceived) {
                        gridItem.classList.add('just-read');
                    }

                    // Determine if this is a systematic or fountain chunk
                    const isSystematic = i < FountainDecoder.systematic_packets_received;

                    // Special handling for chunk 0 (first chunk) to make it more visually distinctive
                    if (i === 0) {
                        // Make chunk 0 visually distinctive regardless of receipt status
                        gridItem.style.position = 'relative';
                        gridItem.style.zIndex = '2';
                        gridItem.style.transform = 'scale(1.2)';
                        gridItem.style.margin = '2px';
                        gridItem.style.boxShadow = '0 0 5px rgba(0,0,0,0.3)';

                        if (isReceived) {
                            // Chunk 0 is received - show as success
                            gridItem.style.border = '3px solid var(--success-color)';
                            gridItem.style.backgroundColor = 'var(--success-color)';
                            gridItem.title = 'First chunk (index 0) - RECEIVED ';

                            // Add a checkmark or number indicator
                            const indicator = document.createElement('div');
                            indicator.style.position = 'absolute';
                            indicator.style.top = '50%';
                            indicator.style.left = '50%';
                            indicator.style.transform = 'translate(-50%, -50%)';
                            indicator.style.color = 'white';
                            indicator.style.fontWeight = 'bold';
                            indicator.style.fontSize = '12px';
                            indicator.textContent = '0';
                            gridItem.appendChild(indicator);
                        } else {
                            // Chunk 0 is missing - show as critical error with animation
                            gridItem.style.border = '3px solid var(--danger-color)';
                            gridItem.style.backgroundColor = 'rgba(220, 38, 38, 0.7)';
                            gridItem.title = 'MISSING CRITICAL first chunk (index 0) - Scan this QR code first!';
                            gridItem.classList.add('pulse-animation');

                            // Add an exclamation mark indicator
                            const indicator = document.createElement('div');
                            indicator.style.position = 'absolute';
                            indicator.style.top = '50%';
                            indicator.style.left = '50%';
                            indicator.style.transform = 'translate(-50%, -50%)';
                            indicator.style.color = 'white';
                            indicator.style.fontWeight = 'bold';
                            indicator.style.fontSize = '16px';
                            indicator.textContent = '!';
                            gridItem.appendChild(indicator);
                        }
                    } else {
                        // Regular chunks (not chunk 0)
                        if (isReceived) {
                            gridItem.classList.add('received');

                            // Add systematic or fountain class
                            if (isSystematic) {
                                gridItem.classList.add('systematic');
                                gridItem.title = `Chunk ${i}: Received from systematic packet`;
                            } else {
                                gridItem.classList.add('fountain');
                                gridItem.title = `Chunk ${i}: Received from fountain packet`;
                            }
                        } else {
                            gridItem.title = `Chunk ${i}: Not yet received`;
                        }
                    }

                    chunkGrid.appendChild(gridItem);
                }

                // Add missing chunks info below the grid
                const missingChunks = FountainDecoder.getMissingChunkIds();
                if (missingChunks && missingChunks.length > 0) {
                    // Create ranges of missing chunks for more compact display
                    const ranges = [];
                    let rangeStart = missingChunks[0];
                    let rangeEnd = missingChunks[0];

                    for (let i = 1; i < missingChunks.length; i++) {
                        if (missingChunks[i] === rangeEnd + 1) {
                            // Continue the current range
                            rangeEnd = missingChunks[i];
                        } else {
                            // End the current range and start a new one
                            if (rangeStart === rangeEnd) {
                                ranges.push(`${rangeStart}`);
                            } else {
                                ranges.push(`${rangeStart}-${rangeEnd}`);
                            }
                            rangeStart = missingChunks[i];
                            rangeEnd = missingChunks[i];
                        }
                    }

                    // Add the last range
                    if (rangeStart === rangeEnd) {
                        ranges.push(`${rangeStart}`);
                    } else {
                        ranges.push(`${rangeStart}-${rangeEnd}`);
                    }

                    // Create or update the missing chunks info element
                    let missingInfo = document.getElementById('missingChunksInfo');

                    if (!missingInfo) {
                        missingInfo = document.createElement('div');
                        missingInfo.id = 'missingChunksInfo';
                        missingInfo.style.marginTop = '10px';
                        missingInfo.style.padding = '5px';
                        missingInfo.style.backgroundColor = 'rgba(220, 53, 69, 0.1)';
                        missingInfo.style.borderRadius = '4px';
                        missingInfo.style.color = '#dc3545';
                        missingInfo.style.fontSize = '13px';
                        chunkGrid.parentNode.insertBefore(missingInfo, chunkGrid.nextSibling);
                    }

                    // Update the content
                    missingInfo.innerHTML = `<strong>Missing Chunks:</strong> ${ranges.join(', ')} <br>
                                            <small>${missingChunks.length} chunks missing out of ${totalChunks} total</small>`;
                } else {
                    // Check to show if missing chunks info is already present
                    const missingInfo = document.getElementById('missingChunksInfo');
                    if (missingInfo) {
                        missingInfo.parentNode.removeChild(missingInfo);
                    }
                }
            },

            updateFileInfo: function (fileInfo) {
                if (!fileInfo) return;

                // Show the file info panel
                const fileInfoPanel = document.getElementById('fileInfo');
                if (fileInfoPanel) {
                    fileInfoPanel.style.display = 'block';
                }

                // Update file information fields
                document.getElementById('fileName').textContent = fileInfo.name || '-';
                document.getElementById('fileType').textContent = fileInfo.type || '-';
                document.getElementById('fileSize').textContent = fileInfo.size ? this.formatFileSize(fileInfo.size) : '-';
                document.getElementById('totalChunks').textContent = fileInfo.totalChunks || '-';
                document.getElementById('recoveredChunks').textContent = fileInfo.recoveredChunks || '-';

                // Update progress
                const progress = fileInfo.totalChunks ?
                    Math.round((fileInfo.recoveredChunks / fileInfo.totalChunks) * 100) : 0;
                document.getElementById('recoveryProgress').textContent = `${progress}%`;

                // Update QR code statistics
                if (FountainDecoder.processingStats) {
                    const stats = FountainDecoder.processingStats;

                    document.getElementById('qrTotalDetected').textContent = stats.totalQrDetected || 0;
                    document.getElementById('qrUniqueChunks').textContent = stats.uniqueChunksReceived || 0;
                    document.getElementById('qrDuplicates').textContent = stats.duplicateChunks || 0;
                    document.getElementById('qrInvalidFormat').textContent = stats.invalidFormats || 0;
                    document.getElementById('qrMetadataChunks').textContent = stats.metadataChunks || 0;
                    document.getElementById('qrDataChunks').textContent = stats.dataPackets || 0;
                }

                // Add estimated time remaining if we have enough data
                const timeRemainingElement = document.getElementById('timeRemaining');
                if (timeRemainingElement && fileInfo.lastUniqueChunkTime && fileInfo.uniqueChunksReceived) {
                    // Calculate time per chunk
                    const timePerChunk = (fileInfo.lastUniqueChunkTime - Date.now()) / fileInfo.uniqueChunksReceived;

                    // Calculate remaining chunks
                    const remainingChunks = fileInfo.totalChunks - fileInfo.recoveredChunks;

                    if (remainingChunks > 0 && timePerChunk > 0) {
                        // Estimate time remaining
                        const timeRemaining = remainingChunks * timePerChunk;

                        // Format time
                        let timeDisplay;
                        if (timeRemaining < 60000) {
                            timeDisplay = `${Math.ceil(timeRemaining / 1000)} seconds`;
                        } else if (timeRemaining < 3600000) {
                            timeDisplay = `${Math.ceil(timeRemaining / 60000)} minutes`;
                        } else {
                            timeDisplay = `${(timeRemaining / 3600000).toFixed(1)} hours`;
                        }

                        timeRemainingElement.textContent = timeDisplay;
                    } else {
                        timeRemainingElement.textContent = 'Almost done!';
                    }
                }

                // Enable/disable download button
                const downloadBtn = document.getElementById('downloadFileBtn');
                if (downloadBtn) {
                    downloadBtn.disabled = !(fileInfo.complete);

                    // Add animation to download button when ready
                    if (fileInfo.complete) {
                        downloadBtn.classList.add('pulse-animation');
                    } else {
                        downloadBtn.classList.remove('pulse-animation');
                    }
                }
            },

            formatFileSize: function (bytes) {
                if (bytes === 0) return '0 Bytes';

                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(1024));
                return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + ' ' + sizes[i];
            },

            updateDecodingStatus: function (isActive) {
                try {
                    const decodingStatusBadge = document.getElementById('decodingStatusBadge');

                    // Add debugging
                    LogManager.log(`Updating decoding status to: ${isActive ? 'Active' : 'Inactive'}`);

                    if (decodingStatusBadge) {
                        if (isActive) {
                            decodingStatusBadge.textContent = 'Active';
                            decodingStatusBadge.className = 'status-badge active';
                            LogManager.success('Decoding status set to Active');
                        } else {
                            decodingStatusBadge.textContent = 'Inactive';
                            decodingStatusBadge.className = 'status-badge inactive';
                            LogManager.log('Decoding status set to Inactive');
                        }
                    } else {
                        LogManager.error('decodingStatusBadge element not found in the DOM!');
                        // Try to find the element by querying all span elements
                        const allBadges = document.querySelectorAll('span.status-badge');
                        LogManager.log(`Found ${allBadges.length} status badges in the DOM`);
                        allBadges.forEach((badge, index) => {
                            LogManager.log(`Badge ${index}: id=${badge.id}, text=${badge.textContent}`);
                        });
                    }
                } catch (error) {
                    console.error("Error updating decoding status:", error);
                }
            }
        };

        // Enhanced preprocessing function for better QR code detection
        const ImageProcessor = {
            preprocessImageData: function (imageData, method = 'adaptive') {
                // Apply image processing based on selected mode
                const width = imageData.width;
                const height = imageData.height;
                const data = imageData.data;

                // Debug information
                if (Core.state.debugMode) {
                    LogManager.log(`Preprocessing image: ${width}x${height}, method: ${method}`);
                }

                // First, apply scaling if needed
                const scaleFactor = Core.state.scaleFactor;
                let scaledImageData = imageData;

                if (scaleFactor !== 1) {
                    // Create scaled version of the image for better distant QR code detection
                    const scaledWidth = Math.floor(width * scaleFactor);
                    const scaledHeight = Math.floor(height * scaleFactor);

                    // Create temporary canvas for scaling
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = scaledWidth;
                    tempCanvas.height = scaledHeight;
                    const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });

                    // Create another canvas to draw the original image data
                    const originalCanvas = document.createElement('canvas');
                    originalCanvas.width = width;
                    originalCanvas.height = height;
                    const originalCtx = originalCanvas.getContext('2d', { willReadFrequently: true });

                    // Put the image data onto the original canvas
                    originalCtx.putImageData(imageData, 0, 0);

                    // Now draw it scaled to the temp canvas with proper smoothing
                    // MODIFICATION: Set appropriate image smoothing based on scaling direction
                    if (scaleFactor < 1) {
                        // Downscaling - disable smoothing for sharper QR codes
                        tempCtx.imageSmoothingEnabled = false;
                    } else {
                        // Upscaling - enable smoothing for better quality
                        tempCtx.imageSmoothingEnabled = true;
                        tempCtx.imageSmoothingQuality = 'high';
                    }
                    tempCtx.drawImage(originalCanvas, 0, 0, width, height, 0, 0, scaledWidth, scaledHeight);

                    // Get the scaled image data
                    scaledImageData = tempCtx.getImageData(0, 0, scaledWidth, scaledHeight);

                    if (Core.state.debugMode) {
                        const scaleDirection = scaleFactor > 1 ? "upscaled" : "downscaled";
                        LogManager.log(`${scaleDirection} image to ${scaledWidth}x${scaledHeight}`);
                    }
                }

                // Get processed data
                const processedData = scaledImageData.data;
                const processedWidth = scaledImageData.width;
                const processedHeight = scaledImageData.height;

                // Based on the method, apply different processing techniques
                switch (method) {
                    case 'contrast': {
                        // Enhance contrast - better for detecting QR codes in different lighting
                        const factor = 1.5; // Contrast factor (adjust as needed)
                        const midpoint = 128; // Midpoint for contrast adjustment

                        for (let i = 0; i < processedData.length; i += 4) {
                            // Apply contrast to each channel
                            for (let j = 0; j < 3; j++) {
                                const value = processedData[i + j];
                                // Apply contrast formula: (value - midpoint) * factor + midpoint
                                const adjusted = Math.min(255, Math.max(0,
                                    (value - midpoint) * factor + midpoint));
                                processedData[i + j] = adjusted;
                            }
                        }
                        break;
                    }

                    case 'bw': {
                        // Convert to black and white with optimized threshold
                        const threshold = this.getOptimalThreshold(processedData);

                        for (let i = 0; i < processedData.length; i += 4) {
                            // Calculate grayscale with proper weights
                            const gray = 0.299 * processedData[i] + 0.587 * processedData[i + 1] + 0.114 * processedData[i + 2];
                            const value = gray < threshold ? 0 : 255;

                            // Set all channels to the same value
                            processedData[i] = processedData[i + 1] = processedData[i + 2] = value;
                        }
                        break;
                    }

                    case 'invert': {
                        // Invert colors - sometimes helps with QR on dark backgrounds
                        for (let i = 0; i < processedData.length; i += 4) {
                            processedData[i] = 255 - processedData[i];
                            processedData[i + 1] = 255 - processedData[i + 1];
                            processedData[i + 2] = 255 - processedData[i + 2];
                        }
                        break;
                    }

                    case 'adaptive': {
                        // Convert to grayscale and apply adaptive thresholding
                        // First convert to grayscale for easier processing
                        const gray = new Uint8Array(processedWidth * processedHeight);

                        for (let i = 0, j = 0; i < processedData.length; i += 4, j++) {
                            gray[j] = Math.round(0.299 * processedData[i] + 0.587 * processedData[i + 1] + 0.114 * processedData[i + 2]);
                        }

                        // Apply adaptive thresholding with a sliding window
                        const windowSize = Math.max(3, Math.floor(Math.min(processedWidth, processedHeight) / 20));
                        const windowSize2 = windowSize * 2 + 1; // Ensure odd size
                        const C = 5; // Constant to subtract from the mean

                        // Use integral image to speed up computation of regional means
                        const integral = new Uint32Array((processedWidth + 1) * (processedHeight + 1));

                        // Calculate integral image
                        for (let y = 0; y < processedHeight; y++) {
                            for (let x = 0; x < processedWidth; x++) {
                                const pos = y * processedWidth + x;
                                const integralPos = (y + 1) * (processedWidth + 1) + (x + 1);
                                // Sum = current + left + top - topleft
                                integral[integralPos] = gray[pos] +
                                    integral[integralPos - 1] +
                                    integral[integralPos - (processedWidth + 1)] -
                                    integral[integralPos - (processedWidth + 1) - 1];
                            }
                        }

                        // Apply thresholding using integral image for fast window means
                        for (let y = 0; y < processedHeight; y++) {
                            for (let x = 0; x < processedWidth; x++) {
                                const pixelIndex = (y * processedWidth + x) * 4;

                                // Calculate bounds for the window
                                const xStart = Math.max(0, x - windowSize);
                                const yStart = Math.max(0, y - windowSize);
                                const xEnd = Math.min(processedWidth - 1, x + windowSize);
                                const yEnd = Math.min(processedHeight - 1, y + windowSize);

                                // Calculate window area
                                const area = (xEnd - xStart + 1) * (yEnd - yStart + 1);

                                // Calculate sum using integral image
                                const sum = integral[(yEnd + 1) * (processedWidth + 1) + (xEnd + 1)] -
                                    integral[(yEnd + 1) * (processedWidth + 1) + xStart] -
                                    integral[yStart * (processedWidth + 1) + (xEnd + 1)] +
                                    integral[yStart * (processedWidth + 1) + xStart];

                                // Calculate mean and apply threshold
                                const mean = Math.round(sum / area) - C;
                                const grayValue = gray[y * processedWidth + x];
                                const value = grayValue < mean ? 0 : 255;

                                // Set all channels to the same value
                                processedData[pixelIndex] = processedData[pixelIndex + 1] = processedData[pixelIndex + 2] = value;
                            }
                        }
                        break;
                    }

                    case 'aggressive': {
                        // Multi-stage processing for challenging QR codes

                        // Step 1: Convert to grayscale
                        for (let i = 0; i < processedData.length; i += 4) {
                            const gray = 0.299 * processedData[i] + 0.587 * processedData[i + 1] + 0.114 * processedData[i + 2];
                            processedData[i] = processedData[i + 1] = processedData[i + 2] = gray;
                        }

                        // Step 3: Normalize histogram to maximize contrast
                        this.normalizeHistogram(processedData);

                        // Step 4: Apply threshold using a dynamic method
                        const threshold = this.getOptimalThreshold(processedData);

                        for (let i = 0; i < processedData.length; i += 4) {
                            const value = processedData[i] < threshold ? 0 : 255;
                            processedData[i] = processedData[i + 1] = processedData[i + 2] = value;
                        }
                        break;
                    }

                    case 'none':
                    default:
                        // No processing, return as is
                        break;
                }

                // Display processed image in debug canvas if enabled
                if (Core.state.debugMode && Core.state.showDebugCanvas) {
                    // Determine which debug canvas to use based on active tab
                    const activeTabId = document.querySelector('.tab-content.active')?.id || '';
                    const isVideoTab = activeTabId === 'video-tab';
                    const debugCanvasId = isVideoTab ? 'videoDebugCanvas' : 'debugCanvas';

                    const debugCanvasElement = document.getElementById(debugCanvasId);
                    if (debugCanvasElement) {
                        const debugCanvasCtx = debugCanvasElement.getContext('2d');
                        if (debugCanvasCtx) {
                            // Show the processed image
                            const processedImageData = new ImageData(
                                new Uint8ClampedArray(processedData),
                                processedWidth,
                                processedHeight
                            );

                            // If canvas size doesn't match the processed image size, adjust it
                            if (debugCanvasElement.width !== width || debugCanvasElement.height !== height) {
                                debugCanvasElement.width = width;
                                debugCanvasElement.height = height;
                            }

                            // Clear the canvas
                            debugCanvasCtx.clearRect(0, 0, debugCanvasElement.width, debugCanvasElement.height);

                            // If we scaled down, draw scaled image back to original size
                            if (scaleFactor !== 1) {
                                // Create temporary canvas for the processed image
                                const tempCanvas = document.createElement('canvas');
                                tempCanvas.width = processedWidth;
                                tempCanvas.height = processedHeight;
                                const tempCtx = tempCanvas.getContext('2d');

                                // Draw processed image data
                                tempCtx.putImageData(processedImageData, 0, 0);

                                // Draw resized on debug canvas
                                debugCanvasCtx.drawImage(tempCanvas, 0, 0, width, height);
                            } else {
                                // Draw directly
                                debugCanvasCtx.putImageData(processedImageData, 0, 0);
                            }

                            // Make debug canvas visible
                            debugCanvasElement.style.display = 'block';
                        }
                    }
                }

                return scaledImageData;
            },

            getOptimalThreshold: function (data) {
                // Use Otsu's method to find the optimal threshold
                const histogram = new Array(256).fill(0);
                let pixelCount = 0;

                // Calculate histogram of grayscale values
                for (let i = 0; i < data.length; i += 4) {
                    histogram[data[i]]++;
                    pixelCount++;
                }

                // Normalize histogram
                for (let i = 0; i < 256; i++) {
                    histogram[i] /= pixelCount;
                }

                // Find optimal threshold using Otsu's method
                let sumB = 0;
                let wB = 0;
                let maximum = 0;
                let threshold = 0;
                let sum1 = 0;

                for (let i = 0; i < 256; i++) {
                    sum1 += i * histogram[i];
                }

                for (let i = 0; i < 256; i++) {
                    wB += histogram[i];

                    if (wB === 0) continue;

                    const wF = 1.0 - wB;
                    if (wF === 0) break;

                    sumB += i * histogram[i];
                    const mB = sumB / wB;
                    const mF = (sum1 - sumB) / wF;

                    // Between-class variance
                    const variance = wB * wF * (mB - mF) * (mB - mF);

                    if (variance > maximum) {
                        maximum = variance;
                        threshold = i;
                    }
                }

                return threshold;
            },

            normalizeHistogram: function (data) {
                // Find min and max values
                let min = 255;
                let max = 0;

                for (let i = 0; i < data.length; i += 4) {
                    const value = data[i];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }

                // If already full range, skip
                if (min === 0 && max === 255) return;

                // Normalize the range
                const range = max - min;
                if (range === 0) return; // All pixels are the same value

                for (let i = 0; i < data.length; i += 4) {
                    const normalized = Math.round(((data[i] - min) / range) * 255);
                    data[i] = data[i + 1] = data[i + 2] = normalized;
                }
            }
        };

        // 4. Camera Manager for camera access and control
        // Optimized CameraManager with fullscreen support and improved frame capture
        const CameraManager = {
            videoElement: null,
            canvasElement: null,
            canvasContext: null,
            debugCanvasElement: null,
            debugCanvasContext: null,
            mediaStream: null,
            captureInterval: null,
            rAFId: null, // requestAnimationFrame ID
            useRAF: true, // Use requestAnimationFrame instead of setInterval
            lastProcessedTime: 0,
            processingDelay: 0, // Automatically calculated based on scan rate
            screenOrientation: 'portrait',
            isFullscreen: false,

            init: function () {
                this.videoElement = document.getElementById('video');
                this.canvasElement = document.getElementById('canvas');
                this.canvasContext = this.canvasElement.getContext('2d', { willReadFrequently: true });
                this.debugCanvasElement = document.getElementById('debugCanvas');

                if (this.debugCanvasElement) {
                    this.debugCanvasContext = this.debugCanvasElement.getContext('2d');
                }

                this.setupCameraSelect();
                this.setupOrientationChange();
                this.setupTouchControls();

                document.getElementById('startCameraBtn').addEventListener('click', () => this.startCamera());
                document.getElementById('stopCameraBtn').addEventListener('click', () => this.stopCamera());
                document.getElementById('fullscreenBtn').addEventListener('click', () => this.toggleFullscreen());

                // Add fullscreen button if it doesn't exist
                if (!document.getElementById('fullscreenBtn')) {
                    const cameraControls = document.querySelector('.controls');
                    if (cameraControls) {
                        const fullscreenBtn = document.createElement('button');
                        fullscreenBtn.id = 'fullscreenBtn';
                        fullscreenBtn.className = 'success';
                        fullscreenBtn.innerHTML = '<i class="fullscreen-icon"></i> Fullscreen';
                        fullscreenBtn.addEventListener('click', () => this.toggleFullscreen());
                        cameraControls.appendChild(fullscreenBtn);
                    }
                }

                LogManager.log('Camera manager initialized with mobile optimizations');
            },

            setupOrientationChange: function () {
                // Detect and respond to orientation changes
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        this.updateCameraViewForOrientation();
                    }, 200); // Small delay to allow UI to update
                });

                // Initial orientation setup
                this.updateCameraViewForOrientation();
            },

            updateCameraViewForOrientation: function () {
                const isPortrait = window.innerHeight > window.innerWidth;
                this.screenOrientation = isPortrait ? 'portrait' : 'landscape';

                if (this.mediaStream && this.videoElement) {
                    // Adjust camera view based on orientation
                    const videoContainer = document.querySelector('.video-container');

                    if (videoContainer) {
                        if (isPortrait) {
                            videoContainer.style.height = '60vh';
                        } else {
                            videoContainer.style.height = '80vh';
                        }
                    }

                    // Ensure canvas matches video dimensions
                    this.resizeCanvasToVideo();
                }

                LogManager.log(`Screen orientation updated to ${this.screenOrientation}`);
            },

            setupTouchControls: function () {
                // Add touch-specific zoom controls for mobile
                const videoContainer = document.querySelector('.video-container');
                if (videoContainer) {
                    let startDistance = 0;
                    let currentZoom = 1;

                    videoContainer.addEventListener('touchstart', (e) => {
                        if (e.touches.length === 2) {
                            startDistance = Math.hypot(
                                e.touches[0].pageX - e.touches[1].pageX,
                                e.touches[0].pageY - e.touches[1].pageY
                            );
                        }
                    });

                    videoContainer.addEventListener('touchmove', (e) => {
                        if (e.touches.length === 2 && this.mediaStream) {
                            e.preventDefault(); // Prevent page zoom

                            const distance = Math.hypot(
                                e.touches[0].pageX - e.touches[1].pageX,
                                e.touches[0].pageY - e.touches[1].pageY
                            );

                            const scale = distance / startDistance;
                            currentZoom *= scale;
                            currentZoom = Math.max(1, Math.min(currentZoom, 5)); // Limit zoom 1x-5x

                            const videoTrack = this.mediaStream.getVideoTracks()[0];
                            if (videoTrack && videoTrack.getCapabilities && videoTrack.getCapabilities().zoom) {
                                const capabilities = videoTrack.getCapabilities();
                                const zoomRange = capabilities.zoom.max - capabilities.zoom.min;
                                const zoomValue = capabilities.zoom.min + (zoomRange * (currentZoom - 1) / 4);

                                videoTrack.applyConstraints({
                                    advanced: [{ zoom: zoomValue }]
                                }).catch(e => {
                                    LogManager.warn(`Could not apply zoom: ${e.message}`);
                                });
                            }

                            startDistance = distance;
                        }
                    }, { passive: false });
                }
            },

            setupCameraSelect: function () {
                const cameraSelect = document.getElementById('cameraSelect');

                navigator.mediaDevices.enumerateDevices()
                    .then(devices => {
                        const videoDevices = devices.filter(device => device.kind === 'videoinput');
                        cameraSelect.innerHTML = '';

                        if (videoDevices.length === 0) {
                            const option = document.createElement('option');
                            option.value = '';
                            option.textContent = 'No cameras found';
                            cameraSelect.appendChild(option);
                            LogManager.warn('No cameras found');
                        } else {
                            // Filter for "back" or "environment" cameras first for mobile
                            const backCameras = videoDevices.filter(device =>
                                device.label && (
                                    device.label.toLowerCase().includes('back') ||
                                    device.label.toLowerCase().includes('rear')
                                )
                            );

                            if (backCameras.length > 0) {
                                // Add back cameras first
                                backCameras.forEach(device => {
                                    const option = document.createElement('option');
                                    option.value = device.deviceId;
                                    option.textContent = device.label || `Back Camera ${backCameras.indexOf(device) + 1}`;
                                    option.selected = true; // Select the first back camera by default
                                    cameraSelect.appendChild(option);
                                });

                                // Then add the rest of the cameras
                                videoDevices
                                    .filter(device => !backCameras.includes(device))
                                    .forEach(device => {
                                        const option = document.createElement('option');
                                        option.value = device.deviceId;
                                        option.textContent = device.label || `Camera ${cameraSelect.options.length}`;
                                        cameraSelect.appendChild(option);
                                    });
                            } else {
                                // Add default option
                                const defaultOption = document.createElement('option');
                                defaultOption.value = '';
                                defaultOption.textContent = 'Default Camera';
                                cameraSelect.appendChild(defaultOption);

                                // Add all available cameras
                                videoDevices.forEach(device => {
                                    const option = document.createElement('option');
                                    option.value = device.deviceId;
                                    option.textContent = device.label || `Camera ${cameraSelect.options.length}`;
                                    cameraSelect.appendChild(option);
                                });
                            }
                            cameraSelect.disabled = false;

                            // Auto-select back camera but don't start automatically
                            if (this.isMobileDevice() && backCameras.length > 0) {
                                LogManager.log('Mobile device detected, auto-selecting back camera');
                                // Select back camera but don't start automatically
                            }

                            LogManager.log(`Found ${videoDevices.length} cameras (${backCameras.length} back cameras)`);
                        }
                    })
                    .catch(error => {
                        LogManager.error('Error enumerating devices: ' + error.message);
                        console.error('Error enumerating devices:', error);

                        cameraSelect.innerHTML = '';
                        const option = document.createElement('option');
                        option.value = '';
                        option.textContent = 'Default Camera';
                        cameraSelect.appendChild(option);
                        cameraSelect.disabled = false;
                    });
            },

            isMobileDevice: function () {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            },

            startCamera: function () {
                const cameraSelect = document.getElementById('cameraSelect');
                const deviceId = cameraSelect.value;

                if (Core.state.cameraActive && Core.state.currentCameraId === deviceId) {
                    return;
                }

                if (this.mediaStream) {
                    this.stopCamera();
                }

                const isMobile = this.isMobileDevice();

                // Default constraints
                const constraints = {
                    video: {
                        width: { ideal: isMobile ? 1280 : 1920 },
                        height: { ideal: isMobile ? 720 : 1080 },
                        facingMode: isMobile ? 'environment' : 'user',
                        frameRate: { ideal: 30, min: 15 }
                    }
                };

                // Use device ID if selected
                if (deviceId) {
                    constraints.video.deviceId = { exact: deviceId };
                }




                // Attempt to show UI overlay for camera access
                this.showCameraLoadingUI(true);

                navigator.mediaDevices.getUserMedia(constraints)
                    .then(stream => {
                        this.mediaStream = stream;
                        this.videoElement.srcObject = stream;

                        const videoTrack = stream.getVideoTracks()[0];
                        const settings = videoTrack.getSettings();

                        // Set canvas dimensions based on video track
                        this.canvasElement.width = settings.width || 1280;
                        this.canvasElement.height = settings.height || 720;

                        if (this.debugCanvasElement) {
                            this.debugCanvasElement.width = settings.width || 1280;
                            this.debugCanvasElement.height = settings.height || 720;
                        }

                        // Try to improve camera settings for QR scanning
                        try {
                            const capabilities = videoTrack.getCapabilities();
                            if (capabilities) {
                                const advancedConstraints = {};

                                // Enable continuous auto-focus
                                if (capabilities.focusMode) {
                                    advancedConstraints.focusMode = 'continuous';
                                }

                                // Enable torch/flashlight for low light (if available)
                                if (capabilities.torch) {
                                    advancedConstraints.torch = Core.state.enableTorch || false;
                                }

                                // Enable exposure compensation for better scanning
                                if (capabilities.exposureCompensation) {
                                    // Slightly increase exposure for better QR detection
                                    const maxExp = capabilities.exposureCompensation.max || 2;
                                    advancedConstraints.exposureCompensation = maxExp * 0.3;
                                }

                                // Apply advanced constraints if available
                                if (Object.keys(advancedConstraints).length > 0) {
                                    videoTrack.applyConstraints({
                                        advanced: [advancedConstraints]
                                    }).then(() => {
                                        LogManager.log('Applied advanced camera constraints: ' + JSON.stringify(advancedConstraints));
                                    }).catch(err => {
                                        LogManager.log('Could not apply advanced constraints: ' + err.message);
                                    });
                                }
                            }
                        } catch (err) {
                            LogManager.log('Camera capabilities not supported: ' + err.message);
                        }
                        // Initialize ImageCapture if supported
                        if (window.ImageCapture) {
                            try {
                                this._imageCapture = new ImageCapture(videoTrack);
                                LogManager.log('ImageCapture API initialized for direct frame capture');
                            } catch (err) {
                                LogManager.warn('ImageCapture API not supported: ' + err.message);
                                this._imageCapture = null;
                            }
                        } else {
                            LogManager.warn('ImageCapture API not available, using canvas fallback');
                        }

                        this.videoElement.onloadedmetadata = () => {
                            this.showCameraLoadingUI(false);
                            Core.state.cameraActive = true;
                            Core.state.currentCameraId = deviceId;

                            document.getElementById('cameraStatus').textContent = 'Active';
                            document.getElementById('cameraStatus').className = 'status-badge active';
                            document.getElementById('startCameraBtn').disabled = true;
                            document.getElementById('stopCameraBtn').disabled = false;
                            document.getElementById('cameraOverlay').classList.add('hidden');

                            if (Core.state.debugMode && this.debugCanvasElement) {
                                this.debugCanvasElement.style.display = 'block';
                            }

                            this.resizeCanvasToVideo();
                            this.startCapture();

                            // Apply fullscreen for mobile devices automatically if enabled
                            if (isMobile && Core.state.autoFullscreen && !this.isFullscreen) {
                                setTimeout(() => this.toggleFullscreen(), 500);
                            }

                            // Display the chunk grid overlay
                            this.showChunkGridOverlay(true);

                            LogManager.log('Camera started: ' + (videoTrack.label || 'unknown camera'));
                            LogManager.log(`Video dimensions: ${this.videoElement.videoWidth}x${this.videoElement.videoHeight}`);
                        };

                        this.videoElement.onerror = () => {
                            LogManager.error('Video element error');
                            this.showCameraLoadingUI(false);
                            this.stopCamera();
                            UI.showNotification('Error initializing camera', 'error');
                        };
                    })
                    .catch(error => {
                        LogManager.error('Camera access error: ' + error.message);
                        console.error('Camera access error:', error);
                        this.showCameraLoadingUI(false);

                        if (error.name === 'NotAllowedError') {
                            UI.showNotification('Camera access denied. Please allow camera permissions.', 'error');
                        } else if (error.name === 'NotFoundError') {
                            UI.showNotification('No camera found on this device.', 'error');
                        } else {
                            UI.showNotification('Camera access error: ' + error.message, 'error');
                        }
                    });
            },

            showCameraLoadingUI: function (isLoading) {
                const overlay = document.getElementById('cameraOverlay');
                if (overlay) {
                    if (isLoading) {
                        overlay.classList.remove('hidden');
                        overlay.innerHTML = `
                    <div class="overlay-content">
                        <div class="spinner"></div>
                        <h3>Initializing Camera</h3>
                        <p>Please wait while we set up the camera...</p>
                    </div>
                `;
                    } else {
                        overlay.classList.add('hidden');
                    }
                }
            },

            showChunkGridOverlay: function (show) {
                const chunkGrid = document.getElementById('chunkGrid');
                const videoContainer = document.querySelector('.video-container');

                if (chunkGrid && videoContainer) {
                    if (show) {
                        // Remove existing overlay if it exists
                        const existingOverlay = document.getElementById('chunkGridOverlay');
                        if (existingOverlay) {
                            existingOverlay.remove();
                        }

                        // Create new floating overlay
                        const gridOverlay = document.createElement('div');
                        gridOverlay.id = 'chunkGridOverlay';
                        gridOverlay.style.position = 'absolute';
                        gridOverlay.style.top = '0';
                        gridOverlay.style.left = '0';
                        gridOverlay.style.width = '100%';
                        gridOverlay.style.height = '100%';
                        gridOverlay.style.pointerEvents = 'none';
                        gridOverlay.style.zIndex = '10';
                        gridOverlay.style.display = 'flex';
                        gridOverlay.style.alignItems = 'center';
                        gridOverlay.style.justifyContent = 'center';

                        // Make background slightly darker in fullscreen mode
                        if (this.isFullscreen) {
                            gridOverlay.style.backgroundColor = 'rgba(0,0,0,0.25)';
                        } else {
                            gridOverlay.style.backgroundColor = 'rgba(0,0,0,0.1)';
                        }

                        const gridContainer = document.createElement('div');
                        gridContainer.id = 'overlayGridContainer';

                        // Make overlay larger and more visible in fullscreen mode
                        if (this.isFullscreen) {
                            gridContainer.style.width = '90%';
                            gridContainer.style.maxWidth = '800px';
                            gridContainer.style.backgroundColor = 'rgba(0,0,0,0.7)';
                            gridContainer.style.padding = '15px';
                        } else {
                            gridContainer.style.width = '80%';
                            gridContainer.style.maxWidth = '500px';
                            gridContainer.style.backgroundColor = 'rgba(0,0,0,0.4)';
                            gridContainer.style.padding = '10px';
                        }

                        gridContainer.style.borderRadius = '8px';

                        // Add header to show file information
                        const header = document.createElement('div');
                        header.style.marginBottom = '10px';
                        header.style.color = 'white';
                        header.style.fontWeight = 'bold';
                        header.style.textAlign = 'center';
                        header.style.fontSize = this.isFullscreen ? '16px' : '14px';
                        header.id = 'overlayGridHeader';

                        // Try to get file information
                        const fileName = document.getElementById('fileName');
                        const recoveryProgress = document.getElementById('recoveryProgress');

                        if (fileName && fileName.textContent !== '-' && recoveryProgress) {
                            header.textContent = `${fileName.textContent} - ${recoveryProgress.textContent}`;
                        } else {
                            header.textContent = 'Scanning for QR codes...';
                        }

                        gridContainer.appendChild(header);

                        // Create a clone of the chunk grid to display in overlay
                        const overlayGrid = document.createElement('div');
                        overlayGrid.className = 'grid-container';
                        overlayGrid.style.margin = '0';
                        overlayGrid.style.opacity = '0.9';

                        // Adjust grid size for fullscreen
                        if (this.isFullscreen) {
                            overlayGrid.style.gap = '4px';
                            overlayGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(24px, 1fr))';
                        }

                        gridContainer.appendChild(overlayGrid);
                        gridOverlay.appendChild(gridContainer);
                        videoContainer.appendChild(gridOverlay);

                        // Update grid overlay as chunks are received
                        EventBus.on('chunksUpdated', () => {
                            this.updateChunkGridOverlay();
                        });

                        // Initial update
                        this.updateChunkGridOverlay();
                    } else {
                        // Remove overlay if exists
                        const gridOverlay = document.getElementById('chunkGridOverlay');
                        if (gridOverlay) {
                            gridOverlay.remove();
                        }
                    }
                }
            },

            updateChunkGridOverlay: function () {
                const gridOverlay = document.getElementById('chunkGridOverlay');
                if (!gridOverlay) return;

                const overlayGrid = gridOverlay.querySelector('.grid-container');
                const overlayHeader = document.getElementById('overlayGridHeader');
                if (!overlayGrid) return;

                // Clear existing grid
                overlayGrid.innerHTML = '';

                // Update with current chunks
                const totalChunks = FountainDecoder.getTotalChunks() || 20;
                const receivedChunks = FountainDecoder.getReceivedChunkIds() || [];

                // Update header with latest info if available
                if (overlayHeader) {
                    const fileName = document.getElementById('fileName');
                    const recoveryProgress = document.getElementById('recoveryProgress');

                    if (fileName && fileName.textContent !== '-' && recoveryProgress) {
                        overlayHeader.textContent = `${fileName.textContent} - ${recoveryProgress.textContent}`;
                    }
                }

                if (totalChunks === 0) {
                    // Show a placeholder if no chunks yet
                    const placeholderItem = document.createElement('div');
                    placeholderItem.className = 'grid-item placeholder';
                    placeholderItem.textContent = 'Waiting for data...';
                    placeholderItem.style.gridColumn = 'span 10';
                    placeholderItem.style.display = 'flex';
                    placeholderItem.style.justifyContent = 'center';
                    placeholderItem.style.alignItems = 'center';
                    placeholderItem.style.height = '40px';
                    placeholderItem.style.color = 'white';
                    placeholderItem.style.backgroundColor = 'rgba(255,255,255,0.1)';
                    overlayGrid.appendChild(placeholderItem);
                    return;
                }

                for (let i = 0; i < totalChunks; i++) {
                    const gridItem = document.createElement('div');
                    gridItem.className = 'grid-item';
                    gridItem.title = `Chunk ${i}`;

                    const isReceived = receivedChunks.some(id =>
                        id.toString() === i.toString() || parseInt(id) === i
                    );

                    if (isReceived) {
                        gridItem.classList.add('received');
                    }

                    // Highlight chunk 0 as special (metadata chunk)
                    if (i === 0) {
                        gridItem.style.position = 'relative';
                        gridItem.style.zIndex = '2';
                        gridItem.style.transform = 'scale(1.2)';
                        gridItem.style.margin = '2px';
                        gridItem.style.boxShadow = '0 0 5px rgba(255,255,255,0.5)';

                        if (isReceived) {
                            gridItem.style.border = '3px solid var(--success-color)';
                            gridItem.style.backgroundColor = 'var(--success-color)';
                        } else {
                            gridItem.style.border = '3px solid var(--danger-color)';
                            gridItem.style.backgroundColor = 'rgba(220,38,38,0.7)';
                            gridItem.classList.add('pulse-animation');
                        }
                    }

                    overlayGrid.appendChild(gridItem);
                }

                // Make grid items more visible in fullscreen mode
                if (this.isFullscreen) {
                    const gridItems = overlayGrid.querySelectorAll('.grid-item');
                    gridItems.forEach(item => {
                        if (!item.classList.contains('placeholder')) {
                            if (item.classList.contains('just-read')) {
                                // Just-read items get special highlighting with shadow
                                item.style.opacity = '1';
                                item.style.boxShadow = '0 0 6px rgba(255,255,100,0.8)';
                            } else if (item.classList.contains('received')) {
                                item.style.opacity = '1';
                                item.style.boxShadow = '0 0 3px rgba(255,255,255,0.3)';
                            } else {
                                item.style.opacity = '0.6';
                            }
                        }
                    });
                }
            },

            toggleFullscreen: function () {
                const videoContainer = document.querySelector('.video-container');

                if (!videoContainer) return;

                // Check if browser supports Fullscreen API
                const fullscreenAvailable =
                    document.fullscreenEnabled ||
                    document.webkitFullscreenEnabled ||
                    document.mozFullScreenEnabled ||
                    document.msFullscreenEnabled;

                // Using native fullscreen API when possible
                if (fullscreenAvailable) {
                    if (!document.fullscreenElement &&
                        !document.webkitFullscreenElement &&
                        !document.mozFullScreenElement &&
                        !document.msFullscreenElement) {

                        // Enter native fullscreen
                        if (videoContainer.requestFullscreen) {
                            videoContainer.requestFullscreen();
                        } else if (videoContainer.webkitRequestFullscreen) {
                            videoContainer.webkitRequestFullscreen();
                        } else if (videoContainer.mozRequestFullScreen) {
                            videoContainer.mozRequestFullScreen();
                        } else if (videoContainer.msRequestFullscreen) {
                            videoContainer.msRequestFullscreen();
                        }

                        this.isFullscreen = true;

                        // Ensure video takes full available space
                        this.videoElement.style.width = '100%';
                        this.videoElement.style.height = '100%';
                        videoContainer.style.backgroundColor = '#000';

                        // Add custom exit fullscreen button for mobile
                        if (this.isMobileDevice()) {
                            this.addFullscreenExitButton(videoContainer);
                        }

                        // Make overlay more visible in fullscreen
                        this.showChunkGridOverlay(true);

                        // Adjust video size for fullscreen
                        setTimeout(() => {
                            this.resizeCanvasToVideo();
                            this.updateChunkGridOverlay(); // Make sure overlay is updated
                        }, 300); // Short delay to allow fullscreen transition

                        LogManager.log('Entered native fullscreen camera mode');
                    } else {
                        // Exit native fullscreen
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        } else if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        } else if (document.mozCancelFullScreen) {
                            document.mozCancelFullScreen();
                        } else if (document.msExitFullscreen) {
                            document.msExitFullscreen();
                        }

                        this.isFullscreen = false;

                        // Remove custom exit button
                        const exitBtn = document.getElementById('exitFullscreenBtn');
                        if (exitBtn) {
                            exitBtn.remove();
                        }

                        // Hide fullscreen overlay
                        const gridOverlay = document.getElementById('chunkGridOverlay');
                        if (gridOverlay) {
                            gridOverlay.remove();
                        }

                        // Reset video container styles
                        this.videoElement.style.width = '';
                        this.videoElement.style.height = '';
                        videoContainer.style.backgroundColor = '';

                        // Resize canvas back to normal
                        setTimeout(() => {
                            this.resizeCanvasToVideo();
                        }, 300); // Short delay to allow transition

                        LogManager.log('Exited native fullscreen camera mode');
                    }
                } else {
                    // Fallback for browsers without fullscreen support (custom implementation)
                    if (!this.isFullscreen) {
                        // Enter custom fullscreen mode
                        this.isFullscreen = true;

                        // Save original styles to restore later
                        this._originalStyles = {
                            videoContainer: {
                                position: videoContainer.style.position,
                                top: videoContainer.style.top,
                                left: videoContainer.style.left,
                                width: videoContainer.style.width,
                                height: videoContainer.style.height,
                                zIndex: videoContainer.style.zIndex
                            },
                            bodyOverflow: document.body.style.overflow
                        };

                        // Apply fullscreen styles
                        videoContainer.style.position = 'fixed';
                        videoContainer.style.top = '0';
                        videoContainer.style.left = '0';
                        videoContainer.style.width = '100vw';
                        videoContainer.style.height = '100vh';
                        videoContainer.style.zIndex = '1000';
                        videoContainer.style.backgroundColor = '#000';
                        document.body.style.overflow = 'hidden';

                        // Add custom exit button
                        this.addFullscreenExitButton(videoContainer);

                        // Make overlay more visible in fullscreen
                        this.showChunkGridOverlay(true);

                        // Adjust video size for fullscreen
                        this.resizeCanvasToVideo();
                        this.updateChunkGridOverlay(); // Make sure overlay is updated

                        LogManager.log('Entered custom fullscreen camera mode');
                    } else {
                        // Exit custom fullscreen mode
                        this.isFullscreen = false;

                        // Restore original styles
                        if (this._originalStyles) {
                            Object.assign(videoContainer.style, this._originalStyles.videoContainer);
                            document.body.style.overflow = this._originalStyles.bodyOverflow;
                        } else {
                            // Default reset if original styles weren't saved
                            videoContainer.style.position = '';
                            videoContainer.style.top = '';
                            videoContainer.style.left = '';
                            videoContainer.style.width = '';
                            videoContainer.style.height = '';
                            videoContainer.style.zIndex = '';
                            videoContainer.style.backgroundColor = '';
                            document.body.style.overflow = '';
                        }

                        // Remove exit button
                        const exitBtn = document.getElementById('exitFullscreenBtn');
                        if (exitBtn) {
                            exitBtn.remove();
                        }

                        // Hide fullscreen overlay
                        const gridOverlay = document.getElementById('chunkGridOverlay');
                        if (gridOverlay) {
                            gridOverlay.remove();
                        }

                        // Resize canvas back to normal
                        this.resizeCanvasToVideo();

                        LogManager.log('Exited custom fullscreen camera mode');
                    }
                }

                // Update button text
                const fullscreenBtn = document.getElementById('fullscreenBtn');
                if (fullscreenBtn) {
                    fullscreenBtn.innerHTML = this.isFullscreen ?
                        '<i class="fullscreen-icon"></i> Exit Fullscreen' :
                        '<i class="fullscreen-icon"></i> Fullscreen';
                }
            },

            // Helper method to add exit button in fullscreen mode
            addFullscreenExitButton: function (container) {
                // Create exit button
                const exitBtn = document.createElement('button');
                exitBtn.id = 'exitFullscreenBtn';
                exitBtn.innerHTML = '';
                exitBtn.style.position = 'absolute';
                exitBtn.style.top = '10px';
                exitBtn.style.right = '10px';
                exitBtn.style.background = 'rgba(0,0,0,0.5)';
                exitBtn.style.color = 'white';
                exitBtn.style.border = 'none';
                exitBtn.style.borderRadius = '50%';
                exitBtn.style.width = '40px';
                exitBtn.style.height = '40px';
                exitBtn.style.fontSize = '20px';
                exitBtn.style.cursor = 'pointer';
                exitBtn.style.zIndex = '1001';
                exitBtn.addEventListener('click', () => this.toggleFullscreen());

                container.appendChild(exitBtn);

            },

            stopCamera: function () {
                this.stopCapture();

                if (this.mediaStream) {
                    this.mediaStream.getTracks().forEach(track => track.stop());
                    this.mediaStream = null;
                }

                this.videoElement.srcObject = null;
                Core.state.cameraActive = false;
                Core.state.currentCameraId = null;

                document.getElementById('cameraStatus').textContent = 'Inactive';
                document.getElementById('cameraStatus').className = 'status-badge inactive';
                document.getElementById('startCameraBtn').disabled = false;
                document.getElementById('stopCameraBtn').disabled = true;
                document.getElementById('cameraOverlay').classList.remove('hidden');

                if (this.debugCanvasElement) {
                    this.debugCanvasElement.style.display = 'none';
                }

                // Hide chunk grid overlay
                this.showChunkGridOverlay(false);

                // Exit fullscreen if active
                if (this.isFullscreen) {
                    this.toggleFullscreen();
                }

                LogManager.log('Camera stopped');
            },

            resizeCanvasToVideo: function () {
                if (!this.videoElement || !this.videoElement.videoWidth) return;

                const videoWidth = this.videoElement.videoWidth;
                const videoHeight = this.videoElement.videoHeight;

                if (this.canvasElement.width !== videoWidth || this.canvasElement.height !== videoHeight) {
                    this.canvasElement.width = videoWidth;
                    this.canvasElement.height = videoHeight;

                    if (this.debugCanvasElement) {
                        this.debugCanvasElement.width = videoWidth;
                        this.debugCanvasElement.height = videoHeight;
                    }

                    LogManager.debug(`Canvas resized to match video: ${videoWidth}x${videoHeight}`);
                }

                // In fullscreen mode, adjust canvas size for better visibility
                if (this.isFullscreen) {
                    const videoContainer = document.querySelector('.video-container');
                    if (videoContainer) {
                        // Calculate aspect ratio
                        const containerRatio = window.innerWidth / window.innerHeight;
                        const videoRatio = videoWidth / videoHeight;

                        if (videoRatio > containerRatio) {
                            // Video is wider than container
                            this.videoElement.style.width = '100%';
                            this.videoElement.style.height = 'auto';
                        } else {
                            // Video is taller than container
                            this.videoElement.style.width = 'auto';
                            this.videoElement.style.height = '100%';
                        }
                    }
                } else {
                    // Reset to normal display
                    this.videoElement.style.width = '';
                    this.videoElement.style.height = '';
                }
            },

            startCapture: function () {
                this.stopCapture(); // Clear any existing capture

                // Calculate processing delay based on scan rate
                this.processingDelay = 500 / Core.state.scanRate;
                this.lastProcessedTime = 0;

                // Set up a frame queue to manage captured frames
                this.frameQueue = [];
                this.maxQueueSize = 3; // Limit queue size to prevent memory issues

                // Start continuous capture interval
                this.captureInterval = setInterval(() => {
                    // Only add to queue if not exceeding max size
                    if (this.frameQueue.length < this.maxQueueSize) {
                        this.captureFrameToQueue();
                    }

                    // Process next frame from queue if workers are available
                    this.processNextFrameFromQueue();

                    // Monitor performance to adapt scan rate if needed
                    this.monitorPerformance();
                }, this.processingDelay);

                LogManager.log(`Continuous frame capture started at ${Core.state.scanRate}FPS (${this.processingDelay}ms interval)`);
                UI.updateDecodingStatus(true);
            },

            captureWithRAF: function () {
                // Legacy method preserved for backward compatibility
                LogManager.warn('captureWithRAF is deprecated, using new continuous capture instead');
                this.startCapture(); // Use the new continuous capture method
            },

            captureFrameToQueue: function () {
                try {
                    if (this.videoElement.readyState !== this.videoElement.HAVE_ENOUGH_DATA) {
                        return;
                    }

                    const videoWidth = this.videoElement.videoWidth;
                    const videoHeight = this.videoElement.videoHeight;

                    // Make sure canvas is properly sized
                    if (this.canvasElement.width !== videoWidth || this.canvasElement.height !== videoHeight) {
                        this.resizeCanvasToVideo();
                    }

                    // Draw current frame to the canvas
                    this.canvasContext.drawImage(this.videoElement, 0, 0, videoWidth, videoHeight);

                    // Get image data and add to queue with timestamp
                    const imageData = this.canvasContext.getImageData(0, 0, videoWidth, videoHeight);

                    this.frameQueue.push({
                        imageData: imageData,
                        timestamp: Date.now()
                    });

                    // Log queue size in debug mode
                    if (Core.state.debugMode) {
                        LogManager.debug(`Frame added to queue. Queue size: ${this.frameQueue.length}`);
                    }
                } catch (error) {
                    LogManager.error(`Frame capture error: ${error.message}`);
                    console.error('Frame capture error:', error);

                    // Don't let a single frame error stop the process
                    // Just continue with next frame
                }
            },

            processNextFrameFromQueue: function () {
                // Check if we have frames in queue and workers available
                if (this.frameQueue.length === 0) {
                    return;
                }

                // Check if workers are available
                const availableWorkers = WorkerPool.workers.filter(worker => !worker.busy && worker.readyState);
                if (availableWorkers.length === 0) {
                    // All workers busy, wait for next cycle
                    return;
                }

                // Get the most recent frame (discard older frames to stay current)
                // This helps prevent processing lag by focusing on newest data
                const frame = this.frameQueue.pop();
                this.frameQueue = []; // Clear any remaining older frames

                // Process the frame
                Core.state.frameCounter++;
                Core.state.lastFrameTime = new Date();

                // Preprocess and send to worker pool
                const processedImageData = this.preprocessImageData(frame.imageData);
                WorkerPool.processFrame(processedImageData);

                // Update UI stats
                UI.updateStats();
            },

            monitorPerformance: function () {
                // Track processed frames per second
                if (!this._performanceStats) {
                    this._performanceStats = {
                        startTime: Date.now(),
                        frameCount: 0,
                        lastFpsCalculation: Date.now(),
                        currentFps: 0,
                        adaptationCount: 0
                    };
                }

                const stats = this._performanceStats;
                stats.frameCount++;

                // Calculate FPS every second
                const now = Date.now();
                if (now - stats.lastFpsCalculation >= 1000) {
                    const elapsed = (now - stats.lastFpsCalculation) / 1000;
                    stats.currentFps = stats.frameCount / elapsed;
                    stats.frameCount = 0;
                    stats.lastFpsCalculation = now;

                    // Log current FPS
                    if (Core.state.debugMode) {
                        LogManager.log(`Current processing rate: ${stats.currentFps.toFixed(1)} FPS`);
                    }

                    // Adapt scan rate if needed
                    if (stats.currentFps < Core.state.scanRate * 0.7 && stats.adaptationCount < 3) {
                        // We're not keeping up with target rate, reduce it
                        const newRate = Math.max(5, Math.floor(stats.currentFps));
                        LogManager.warn(`Performance adaptation: Reducing scan rate to ${newRate} FPS`);

                        // Update core state and restart capture
                        Core.state.scanRate = newRate;
                        this.stopCapture();
                        this.startCapture();

                        // Update UI
                        UI.updateSettingsUI();
                        stats.adaptationCount++;
                    }
                }
            },

            stopCapture: function () {
                if (this.captureInterval) {
                    clearInterval(this.captureInterval);
                    this.captureInterval = null;
                }

                if (this.rAFId) {
                    cancelAnimationFrame(this.rAFId);
                    this.rAFId = null;
                }

                UI.updateDecodingStatus(false);
                LogManager.log('Frame capture stopped');
            },
            // Capture and process a frame 
            captureAndProcessFrame: async function () {
                // Get current time
                const now = Date.now();

                // Check if we should process this frame (based on throttling)
                if (now - this.lastProcessedTime < this.processingDelay) {
                    return;
                }

                this.lastProcessedTime = now;

                // Check if workers are available
                const availableWorkers = WorkerPool.workers.filter(worker => !worker.busy && worker.readyState);
                if (availableWorkers.length === 0) {
                    // All workers busy, skip this frame
                    return;
                }

                // Try to use direct capture if available
                let imageData = null;

                if (this._imageCapture) {
                    try {
                        imageData = await this.captureFrameDirectly();
                    } catch (error) {
                        LogManager.warn('Direct capture failed, falling back to canvas: ' + error.message);
                        imageData = null;
                    }
                }

                // Fall back to canvas capture if direct capture failed or not available
                if (!imageData) {
                    imageData = this.captureFrameWithCanvas();
                }

                // Skip if we couldn't get image data
                if (!imageData) {
                    return;
                }

                // Process the frame
                Core.state.frameCounter++;
                this.currentFrame++;
                Core.state.lastFrameTime = new Date();

                // Preprocess image data before sending to worker pool
                const processedImageData = this.preprocessImageData(imageData);

                // Send to worker pool for processing
                WorkerPool.processFrame(processedImageData);

                // Update UI stats
                UI.updateStats();
            },

            // Capture frame using the ImageCapture API (direct from camera)
            captureFrameDirectly: async function () {
                if (!this._imageCapture) {
                    return null;
                }

                try {
                    // Grab frame from camera
                    const imageBitmap = await this._imageCapture.grabFrame();

                    // We need to convert ImageBitmap to ImageData for processing
                    // Create a temporary canvas if needed
                    if (!this._tempCanvas) {
                        this._tempCanvas = document.createElement('canvas');
                        this._tempCtx = this._tempCanvas.getContext('2d');
                    }

                    // Set canvas size to match the captured frame
                    this._tempCanvas.width = imageBitmap.width;
                    this._tempCanvas.height = imageBitmap.height;

                    // Draw the frame to the canvas to get ImageData
                    this._tempCtx.drawImage(imageBitmap, 0, 0);
                    return this._tempCtx.getImageData(0, 0, imageBitmap.width, imageBitmap.height);
                } catch (error) {
                    LogManager.error(`Direct frame capture error: ${error.message}`);
                    throw error;
                }
            },

            // Capture frame using canvas (fallback method)
            captureFrameWithCanvas: function () {
                // Skip if video is not ready
                if (this.videoElement.readyState !== this.videoElement.HAVE_ENOUGH_DATA) {
                    return null;
                }

                try {
                    const videoWidth = this.videoElement.videoWidth;
                    const videoHeight = this.videoElement.videoHeight;

                    // Make sure canvas is properly sized
                    if (this.canvasElement.width !== videoWidth || this.canvasElement.height !== videoHeight) {
                        this.canvasElement.width = videoWidth;
                        this.canvasElement.height = videoHeight;
                    }

                    // Draw current frame to the canvas
                    this.canvasContext.drawImage(this.videoElement, 0, 0, videoWidth, videoHeight);

                    // Get image data
                    return this.canvasContext.getImageData(0, 0, videoWidth, videoHeight);
                } catch (error) {
                    LogManager.error(`Canvas frame capture error: ${error.message}`);
                    console.error('Canvas frame capture error:', error);
                    return null;
                }
            },
            captureFrame: function () {
                if (this.videoElement.readyState !== this.videoElement.HAVE_ENOUGH_DATA) {
                    return;
                }

                const videoWidth = this.videoElement.videoWidth;
                const videoHeight = this.videoElement.videoHeight;

                // Make sure canvas is properly sized
                if (this.canvasElement.width !== videoWidth || this.canvasElement.height !== videoHeight) {
                    this.resizeCanvasToVideo();
                }

                Core.state.frameCounter++;
                Core.state.lastFrameTime = new Date();

                try {
                    // Use drawImage for optimal performance
                    this.canvasContext.drawImage(this.videoElement, 0, 0, videoWidth, videoHeight);

                    // Only get image data when needed (avoid unnecessary CPU work)
                    const imageData = this.canvasContext.getImageData(0, 0, videoWidth, videoHeight);

                    // Process image asynchronously when possible
                    if (window.createImageBitmap && false) { // Disabled for now as it caused issues with some browsers
                        createImageBitmap(imageData).then(bitmap => {
                            const processedImageData = this.preprocessImageData(imageData);
                            WorkerPool.processFrame(processedImageData);
                        }).catch(err => {
                            // Fallback to synchronous processing if createImageBitmap fails
                            const processedImageData = this.preprocessImageData(imageData);
                            WorkerPool.processFrame(processedImageData);
                        });
                    } else {
                        // Process synchronously
                        const processedImageData = this.preprocessImageData(imageData);
                        WorkerPool.processFrame(processedImageData);
                    }

                    UI.updateStats();

                    // Update chunk grid overlay periodically
                    if (Core.state.frameCounter % 30 === 0) {
                        this.updateChunkGridOverlay();
                    }
                } catch (error) {
                    LogManager.error(`Frame capture error: ${error.message}`);
                    console.error('Frame capture error:', error);
                }
            },

  // Capture and process a frame 
    captureAndProcessFrame: async function() {
        // Get current time
        const now = Date.now();
        
        // Check if we should process this frame (based on throttling)
        if (now - this.lastProcessedTime < this.processingDelay) {
            return;
        }
        
        this.lastProcessedTime = now;
        
        // Check if workers are available
        const availableWorkers = WorkerPool.workers.filter(worker => !worker.busy && worker.readyState);
        if (availableWorkers.length === 0) {
            // All workers busy, skip this frame
            return;
        }
        
        // Try to use direct capture if available
        let imageData = null;
        
        if (this._imageCapture) {
            try {
                imageData = await this.captureFrameDirectly();
            } catch (error) {
                LogManager.warn('Direct capture failed, falling back to canvas: ' + error.message);
                imageData = null;
            }
        }
        
        // Fall back to canvas capture if direct capture failed or not available
        if (!imageData) {
            imageData = this.captureFrameWithCanvas();
        }
        
        // Skip if we couldn't get image data
        if (!imageData) {
            return;
        }
        
        // Process the frame
        Core.state.frameCounter++;
        this.currentFrame++;
        Core.state.lastFrameTime = new Date();
        
        // Preprocess image data before sending to worker pool
        const processedImageData = this.preprocessImageData(imageData);
        
        // Send to worker pool for processing
        WorkerPool.processFrame(processedImageData);
        
        // Update UI stats
        UI.updateStats();
    },
    
    // Capture frame using the ImageCapture API (direct from camera)
    captureFrameDirectly: async function() {
        if (!this._imageCapture) {
            return null;
        }
        
        try {
            // Grab frame from camera
            const imageBitmap = await this._imageCapture.grabFrame();
            
            // We need to convert ImageBitmap to ImageData for processing
            // Create a temporary canvas if needed
            if (!this._tempCanvas) {
                this._tempCanvas = document.createElement('canvas');
                this._tempCtx = this._tempCanvas.getContext('2d');
            }
            
            // Set canvas size to match the captured frame
            this._tempCanvas.width = imageBitmap.width;
            this._tempCanvas.height = imageBitmap.height;
            
            // Draw the frame to the canvas to get ImageData
            this._tempCtx.drawImage(imageBitmap, 0, 0);
            return this._tempCtx.getImageData(0, 0, imageBitmap.width, imageBitmap.height);
        } catch (error) {
            LogManager.error(`Direct frame capture error: ${error.message}`);
            throw error;
        }
    },
    
    // Capture frame using canvas (fallback method)
    captureFrameWithCanvas: function() {
        // Skip if video is not ready
        if (this.videoElement.readyState !== this.videoElement.HAVE_ENOUGH_DATA) {
            return null;
        }
        
        try {
            const videoWidth = this.videoElement.videoWidth;
            const videoHeight = this.videoElement.videoHeight;
            
            // Make sure canvas is properly sized
            if (this.canvasElement.width !== videoWidth || this.canvasElement.height !== videoHeight) {
                this.canvasElement.width = videoWidth;
                this.canvasElement.height = videoHeight;
            }
            
            // Draw current frame to the canvas
            this.canvasContext.drawImage(this.videoElement, 0, 0, videoWidth, videoHeight);
            
            // Get image data
            return this.canvasContext.getImageData(0, 0, videoWidth, videoHeight);
        } catch (error) {
            LogManager.error(`Canvas frame capture error: ${error.message}`);
            console.error('Canvas frame capture error:', error);
            return null;
        }
    },
    
    // Preprocess image data before sending to worker pool
    preprocessImageData: function(imageData) {
        // Use CameraManager's preprocessing function if available, or implement our own
        //if (CameraManager && typeof CameraManager.preprocessImageData === 'function') {
        //    return CameraManager.preprocessImageData(imageData);
        //}
        
        // Basic preprocessing if CameraManager's function is not available
        return ImageProcessor.preprocessImageData(imageData, Core.state.imageProcessing);
    },

            captureStillFrame: function () {
                if (!Core.state.cameraActive) {
                    UI.showNotification('Camera is not active', 'warning');
                    return;
                }

                this.captureFrame();

                try {
                    // Create higher quality capture for QR debugging
                    const dataURL = this.canvasElement.toDataURL('image/png');
                    const link = document.createElement('a');
                    link.href = dataURL;
                    link.download = `qr-frame-${new Date().toISOString().replace(/[:.]/g, '-')}.png`;
                    link.style.display = 'none';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    UI.showNotification('Frame captured and saved', 'success');
                    LogManager.log('Still frame captured and saved');
                } catch (error) {
                    LogManager.error('Error saving frame: ' + error.message);
                    UI.showNotification('Error saving frame', 'error');
                }
            }
        };

        // CSS Updates for mobile optimization
        const mobileStyles = `
/* Mobile optimization styles */
@media (max-width: 768px) {
    .video-container {
        height: 60vh !important;
        max-height: none !important;
        overflow: hidden;
        position: relative;
    }
    
    #video, #uploadedVideo {
        width: 100%;
        height: 100%;
        max-height: none;
        object-fit: cover;
    }
    
    .controls {
        position: relative;
        z-index: 20;
    }
    
    #chunkGridOverlay {
        box-sizing: border-box;
    }
    
    #chunkGridOverlay .grid-container {
        grid-template-columns: repeat(auto-fill, minmax(15px, 1fr));
        gap: 3px;
    }
    
    .fullscreen-icon {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid currentColor;
        position: relative;
        top: 2px;
        margin-right: 5px;
    }
    
    /* Torch/flashlight button */
    .torch-btn {
        position: absolute;
        top: 10px;
        right: 60px;
        background: rgba(0,0,0,0.5);
        color: white;
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        font-size: 20px;
        cursor: pointer;
        z-index: 1001;
    }
    
    /* QR frame guide */
    .qr-guide {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 70vw;
        max-width: 300px;
        height: 70vw;
        max-height: 300px;
        border: 2px dashed rgba(255,255,255,0.8);
        border-radius: 10px;
        box-shadow: 0 0 0 2000px rgba(0,0,0,0.3);
        pointer-events: none;
        z-index: 5;
    }
    
    .qr-guide::before,
    .qr-guide::after {
        content: '';
        position: absolute;
        width: 30px;
        height: 30px;
        border-color: var(--primary-color);
        border-style: solid;
        border-width: 0;
    }
    
    .qr-guide::before {
        top: -2px;
        left: -2px;
        border-top-width: 4px;
        border-left-width: 4px;
        border-top-left-radius: 8px;
    }
    
    .qr-guide::after {
        bottom: -2px;
        right: -2px;
        border-bottom-width: 4px;
        border-right-width: 4px;
        border-bottom-right-radius: 8px;
    }
}
`;
        // 5. Worker Pool for managing web workers
        // Enhanced WorkerPool implementation
        const WorkerPool = {
            workers: [],
            queue: [],
            processing: [],
            taskId: 0,
            workerScript: '',

            init: function () {
                // Get worker script - either from DOM or use the improved one
                const scriptElement = document.getElementById('workerScript');
                if (scriptElement) {
                    this.workerScript = scriptElement.textContent;

                    // Optional: Replace with the enhanced worker script
                    // Uncomment the next line to use the enhanced script
                    // this.workerScript = enhancedWorkerScript;
                } else {
                    LogManager.error('Worker script not found in DOM');
                }

                // Create initial worker pool
                this.createWorkers(Core.state.workerCount);

                // Set up diagnostic timer to check worker health
                Core.workerHealthCheckInterval = setInterval(() => this.checkWorkerHealth(), 10000);

                LogManager.debug('Worker pool initialized');
            },

            createWorkers: function (count) {
                // Clean up existing workers
                this.terminateWorkers();

                // Create blob URL for worker script
                const blob = new Blob([this.workerScript], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(blob);

                // Create new workers
                this.workers = [];

                for (let i = 0; i < count; i++) {
                    try {
                        const worker = new Worker(workerUrl);

                        // Set up message handler
                        worker.onmessage = this.handleWorkerMessage.bind(this);
                        worker.onerror = this.handleWorkerError.bind(this);

                        // Add worker to pool with initial idle state
                        this.workers.push({
                            worker: worker,
                            id: i,
                            busy: false,
                            readyState: false,
                            lastActivity: Date.now(),
                            errors: 0
                        });

                        // Send a ping to test worker functionality
                        worker.postMessage({
                            id: 'init-' + i,
                            type: 'ping'
                        });

                        // Wait for worker ready message
                        worker.addEventListener('message', (e) => {
                            if (e.data && (e.data.type === 'ready' || e.data.type === 'pong')) {
                                const workerInfo = this.workers.find(w => w.worker === worker);
                                if (workerInfo) {
                                    workerInfo.readyState = true;
                                    workerInfo.lastActivity = Date.now();
                                    LogManager.debug(`Worker ${workerInfo.id} is ready (${e.data.type})`);

                                    // If it was a ready message with status, log it
                                    if (e.data.status) {
                                        LogManager.debug(`Worker status: ${e.data.status}`);
                                    }
                                }
                            }
                        }, { once: false });
                    } catch (error) {
                        LogManager.error(`Error creating worker: ${error.message}`);
                        console.error('Error creating worker:', error);
                    }
                }

                // Update UI
                document.getElementById('workerStatus').textContent = `${this.workers.length} active`;

                // Update core state
                Core.state.workerCount = count;

                // Log
                LogManager.log(`Worker pool created with ${this.workers.length} workers`);

                // Revoke blob URL
                URL.revokeObjectURL(workerUrl);
            },

            terminateWorkers: function () {
                // Terminate all existing workers
                this.workers.forEach(workerInfo => {
                    try {
                        workerInfo.worker.terminate();
                    } catch (e) {
                        console.error('Error terminating worker:', e);
                    }
                });

                // Clear arrays
                this.workers = [];
                this.queue = [];
                this.processing = [];

                LogManager.log('All workers terminated');
            },

            processFrame: function (imageData, taskType = 'camera-frame') {
                // Skip if no workers are ready
                const readyWorkers = this.workers.filter(worker => worker.readyState);
                if (readyWorkers.length === 0) {
                    LogManager.warn('No workers ready to process frames');
                    return;
                }

                // Generate unique task ID
                const id = this.taskId++;

                // Create task
                const task = {
                    id: id,
                    type: taskType,
                    imageData: imageData,
                    timestamp: Date.now()
                };

                // Add to queue
                this.queue.push(task);

                // Process queue
                this.processQueue();
            },

            isWorkerAvailable: function () {
                return this.workers.some(worker => !worker.busy && worker.readyState);
            },

            processQueue: function () {
                // Skip if queue is empty
                if (this.queue.length === 0) {
                    return;
                }

                // Find available workers
                const availableWorkers = this.workers.filter(worker => !worker.busy && worker.readyState);

                // Process as many tasks as we have available workers
                while (availableWorkers.length > 0 && this.queue.length > 0) {
                    const workerInfo = availableWorkers.pop();

                    // Get most recent task if there are multiple (for camera frames)
                    // or the first task for other types of processing
                    let task;
                    if (this.queue.length > 1 && this.queue[0].type === 'camera-frame') {
                        // For camera frames, get the most recent one
                        task = this.queue.pop();
                        // Clear older camera frames to prevent backlog
                        this.queue = this.queue.filter(t => t.type !== 'camera-frame');
                    } else {
                        // For other tasks or single frame, get the first one
                        task = this.queue.shift();
                    }

                    // Mark worker as busy
                    workerInfo.busy = true;
                    workerInfo.lastActivity = Date.now();

                    // Add task to processing list
                    this.processing.push({
                        id: task.id,
                        workerId: workerInfo.id,
                        timestamp: task.timestamp
                    });

                    // Clone the image data to ensure it's valid for transfer
                    const clonedData = {
                        width: task.imageData.width,
                        height: task.imageData.height,
                        data: task.imageData.data
                    };

                    // Send task to worker with all necessary parameters
                    workerInfo.worker.postMessage({
                        id: task.id,
                        imageData: clonedData,
                        highDensityMode: Core.state.highDensityMode,
                        processingMethod: Core.state.imageProcessing,
                        type: 'detect'
                    }, [task.imageData.data.buffer]); // Transfer image data buffer for performance

                    if (Core.state.debugMode) {
                        LogManager.log(`Task ${task.id} sent to worker ${workerInfo.id} (${task.imageData.width}x${task.imageData.height})`);
                    }
                }
            },

            handleWorkerMessage: function (e) {
                const result = e.data;

                // Update worker activity timestamp
                const workerInfo = this.findWorkerByEvent(e);
                if (workerInfo) {
                    workerInfo.lastActivity = Date.now();
                }

                // Handle different message types
                if (result.type === 'pong') {
                    // Ping response - worker is alive
                    return;
                } else if (result.type === 'error') {
                    // General worker error
                    LogManager.error(`Worker error: ${result.error}`);
                    return;
                } else if (result.type === 'ready') {
                    // Worker initialization complete
                    return;
                }

                // This is a task result
                // Find the processing task
                const taskIndex = this.processing.findIndex(task => task.id === result.id);

                if (taskIndex !== -1) {
                    const task = this.processing[taskIndex];

                    // Remove from processing list
                    this.processing.splice(taskIndex, 1);

                    // Find worker
                    const workerInfo = this.workers.find(worker => worker.id === task.workerId);

                    if (workerInfo) {
                        // Mark worker as available
                        workerInfo.busy = false;

                        // Reset error count on successful processing
                        if (result.success) {
                            workerInfo.errors = 0;
                        }
                    }

                    // Handle result
                    if (result.success) {
                        // QR code detected
                        Core.state.qrCodesDetected++;

                        // Log detection
                        if (Core.state.debugMode) {
                            LogManager.success(`QR code detected by worker ${task.workerId}: ${result.data.substring(0, 20)}...`);
                        }

                        // Directly update decoding status badge (as backup to ensure it gets updated)
                        const decodingStatusBadge = document.getElementById('decodingStatusBadge');
                        if (decodingStatusBadge) {
                            decodingStatusBadge.textContent = 'Active';
                            decodingStatusBadge.className = 'status-badge active';
                            LogManager.success('Decoding status directly set to Active');
                        }

                        // Process QR code data
                        this.handleQRData(result.data, result.location);
                    } else {
                        // QR code not detected
                        if (Core.state.debugMode && result.debugInfo) {
                            LogManager.log(`No QR code in frame: ${JSON.stringify(result.debugInfo)}`);
                        }

                        // Track QR code detection errors
                        if (result.error) {
                            if (result.error === 'No QR code detected') {
                                // Nothing to track, this is normal
                            } else if (result.error.includes('not readable') || result.error.includes('corrupted')) {
                                // Track not readable QR codes
                                Core.state.qrErrorStats.notReadable++;
                                LogManager.warn(`QR code detected but not readable: ${result.error}`);
                            } else if (workerInfo) {
                                // Count other worker errors
                                workerInfo.errors++;

                                // Log details about significant errors
                                if (result.stack) {
                                    LogManager.error(`Worker ${task.workerId} error: ${result.error}\n${result.stack}`);
                                }

                                // Restart worker if too many errors
                                if (workerInfo.errors > 5) {
                                    LogManager.warn(`Restarting worker ${workerInfo.id} after too many errors`);
                                    this.restartWorker(workerInfo.id);
                                }
                            }
                        }
                    }

                    // Continue processing queue
                    this.processQueue();
                }
            },

            handleWorkerError: function (error) {
                LogManager.error('Worker error: ' + error.message);
                console.error('Worker error:', error);

                // Find the worker that generated the error
                const workerInfo = this.findWorkerByEvent(error);
                if (workerInfo) {
                    workerInfo.errors++;

                    // Restart worker if too many errors
                    if (workerInfo.errors > 3) {
                        this.restartWorker(workerInfo.id);
                    }
                }

                // Log worker state
                LogManager.error('Worker state: ' + JSON.stringify({
                    workerCount: this.workers.length,
                    queueLength: this.queue.length,
                    processingTasks: this.processing.length
                }));
            },

            findWorkerByEvent: function (event) {
                // Find worker info based on event source
                return this.workers.find(w => w.worker === event.target);
            },

            restartWorker: function (id) {
                // Find worker by ID
                const index = this.workers.findIndex(w => w.id === id);
                if (index === -1) return;

                // Get worker info
                const workerInfo = this.workers[index];

                // Terminate old worker
                try {
                    workerInfo.worker.terminate();
                } catch (e) {
                    console.error('Error terminating worker:', e);
                }

                // Create new worker
                try {
                    const blob = new Blob([this.workerScript], { type: 'application/javascript' });
                    const workerUrl = URL.createObjectURL(blob);

                    const worker = new Worker(workerUrl);

                    // Set up message handler
                    worker.onmessage = this.handleWorkerMessage.bind(this);
                    worker.onerror = this.handleWorkerError.bind(this);

                    // Update worker info
                    workerInfo.worker = worker;
                    workerInfo.busy = false;
                    workerInfo.readyState = false;
                    workerInfo.lastActivity = Date.now();
                    workerInfo.errors = 0;

                    // Wait for worker ready message
                    worker.addEventListener('message', (e) => {
                        if (e.data && (e.data.type === 'ready' || e.data.type === 'pong')) {
                            workerInfo.readyState = true;
                            LogManager.log(`Worker ${workerInfo.id} restarted and ready`);
                        }
                    });

                    // Send a ping to test worker functionality
                    worker.postMessage({
                        id: 'restart-' + id,
                        type: 'ping'
                    });

                    // Revoke blob URL
                    URL.revokeObjectURL(workerUrl);

                    LogManager.log(`Worker ${id} restarted`);
                } catch (error) {
                    LogManager.error(`Error restarting worker ${id}: ${error.message}`);
                }
            },

            checkWorkerHealth: function () {
                const now = Date.now();

                // Check each worker
                this.workers.forEach(workerInfo => {
                    // If worker hasn't responded in 30 seconds, restart it
                    if (now - workerInfo.lastActivity > 30000) {
                        LogManager.warn(`Worker ${workerInfo.id} appears stalled, restarting`);
                        this.restartWorker(workerInfo.id);
                        return;
                    }

                    // Send ping to ensure worker is responsive
                    try {
                        workerInfo.worker.postMessage({
                            id: 'ping-' + workerInfo.id,
                            type: 'ping'
                        });
                    } catch (e) {
                        LogManager.error(`Error sending ping to worker ${workerInfo.id}: ${e.message}`);
                        this.restartWorker(workerInfo.id);
                    }
                });

                // Check for abandoned tasks
                const staleTimeout = 10000; // 10 seconds
                const staleTasks = this.processing.filter(task => now - task.timestamp > staleTimeout);

                if (staleTasks.length > 0) {
                    LogManager.warn(`Found ${staleTasks.length} stale tasks, cleaning up`);

                    // Remove stale tasks
                    this.processing = this.processing.filter(task => now - task.timestamp <= staleTimeout);

                    // Reset busy workers associated with stale tasks
                    staleTasks.forEach(task => {
                        const workerInfo = this.workers.find(w => w.id === task.workerId);
                        if (workerInfo) {
                            workerInfo.busy = false;

                            // If multiple stale tasks for same worker, restart it
                            const workerStaleTasks = staleTasks.filter(t => t.workerId === workerInfo.id);
                            if (workerStaleTasks.length > 1) {
                                LogManager.warn(`Worker ${workerInfo.id} had ${workerStaleTasks.length} stale tasks, restarting`);
                                this.restartWorker(workerInfo.id);
                            }
                        }
                    });
                }
            },

            handleQRData: function (data, location) {
                // Enhanced debugging - log the raw QR code data
                if (Core.state.debugMode) {
                    const displayData = typeof data === 'string'
                        ? data.substring(0, 150) + (data.length > 150 ? '...' : '')
                        : JSON.stringify(data);
                    console.error(`Raw QR data received: ${displayData}`);

                    // Location handling with better null checking and error handling
                    if (location) {
                        console.log("QR location data received:", location);
                        try {
                            // Check if we have valid coordinates for calculating dimensions
                            if (location.topLeft && location.topRight &&
                                typeof location.topLeft.x === 'number' &&
                                typeof location.topLeft.y === 'number' &&
                                typeof location.topRight.x === 'number' &&
                                typeof location.topRight.y === 'number') {

                                // Calculate QR code dimensions (distance between top corners)
                                const dimension = Math.round(Math.sqrt(
                                    Math.pow(location.topRight.x - location.topLeft.x, 2) +
                                    Math.pow(location.topRight.y - location.topLeft.y, 2)
                                ));

                                LogManager.log(`QR location: topLeft(${location.topLeft.x},${location.topLeft.y}), dimensions ~${dimension}px`);

                                // Additional debug info - full QR bounds
                                LogManager.log(`QR corners: TL(${location.topLeft.x},${location.topLeft.y}), 
                                    TR(${location.topRight.x},${location.topRight.y}), 
                                    BL(${location.bottomLeft.x},${location.bottomLeft.y}), 
                                    BR(${location.bottomRight.x},${location.bottomRight.y})`);
                            } else {
                                LogManager.log(`QR location provided but coordinates are invalid`);
                            }
                        } catch (e) {
                            LogManager.error(`Error calculating QR dimensions: ${e.message}`);
                        }
                    } else {
                        LogManager.log(`No QR location data available for this code`);
                    }
                }

                // Update decoding status to active when QR codes are detected
                UI.updateDecodingStatus(true);

                // CRITICAL FIX: Increment the total QR codes counter in FountainDecoder directly
                // to ensure it's counted regardless of validation
                FountainDecoder.processingStats.totalQrDetected++;

                // Update the UI stats immediately
                UI.updateStats();

                // Log complete QR data for debugging
                if (Core.state.debugMode) {
                    const fullData = typeof data === 'string' ? data : JSON.stringify(data);
                    console.log("FULL QR CODE DATA:", fullData);
                    LogManager.log(`Full QR data (for debug): ${fullData.substring(0, 500)}${fullData.length > 500 ? '...' : ''}`);
                }

                // Try to detect JSON format first and display its structure
                if (typeof data === 'string' && data.startsWith('{') && data.endsWith('}')) {
                    try {
                        const parsed = JSON.parse(data);
                        LogManager.log(`QR JSON structure: ${Object.keys(parsed).join(', ')}`);

                        // Special handling for known formats
                        if (parsed.seed && !parsed.packetId) {
                            LogManager.log(`Found non-standard seed format. Contains: seed=${parsed.seed}`);
                            // If this appears to be a seed-based format but doesn't have expected chunk fields,
                            // try to extract and create compatible format
                            if (parsed.data || parsed.payload) {
                                const compatibleData = {
                                    packetId: parsed.seed || 0,
                                    data: parsed.data || parsed.payload || ''
                                };
                                LogManager.log(`Creating compatible chunk format from seed data`);
                                data = JSON.stringify(compatibleData);
                            }
                        }
                    } catch (e) {
                        LogManager.warn(`Failed to parse JSON from QR code: ${e.message}`);
                    }
                }
                // Check for fountain format (D: prefix)
                else if (typeof data === 'string' && data.startsWith('D:')) {
                    LogManager.success(`Detected fountain format with D: prefix`);
                    console.log("Fountain format detected:", data.substring(0, 100));
                }

                // We already incremented totalQrDetected in handleQRData
                // so don't do it again here to avoid double counting

                // Check if this looks like a Fountain chunk
                const isValidChunk = FountainDecoder.isValidChunk(data);

                if (isValidChunk) {
                    // Process chunk
                    const result = FountainDecoder.processChunk(data);

                    if (result.isNewChunk) {
                        Core.state.chunksRecovered++;
                        UI.showNotification(`New chunk recovered (${Core.state.chunksRecovered} total)`, 'success');
                    }

                    // Check if file is complete
                    if (result.isComplete) {
                        UI.showNotification('File recovery complete!', 'success');

                        // Enable download button
                        document.getElementById('downloadFileBtn').disabled = false;
                    }

                    // Update UI
                    UI.updateFileInfo(FountainDecoder.getFileInfo());
                    UI.updateChunkGrid(
                        FountainDecoder.getTotalChunks(),
                        FountainDecoder.getReceivedChunkIds()
                    );
                    UI.updateProgressBar(
                        FountainDecoder.getProgress()
                    );
                } else {
                    // For non-fountain regular QR code, check if we can extract useful data
                    if (Core.state.debugMode) {
                        LogManager.warn(`QR code did not match any known fountain format: ${typeof data === 'string' ? data.substring(0, 50) + (data.length > 50 ? '...' : '') : JSON.stringify(data)
                            }`);
                    }

                    // Check if this is a D: format directly (might be missed by isValidChunk)
                    if (typeof data === 'string' && data.startsWith('D:')) {
                        LogManager.warn(`Found D: prefix but wasn't validated as a fountain chunk. Attempting direct processing...`);

                        // Attempt forced processing by modifying the data format
                        try {
                            // Split the data into parts
                            const parts = data.split(':');
                            if (parts.length >= 6) {
                                const packetId = parseInt(parts[1]) || 0;
                                const numChunks = parseInt(parts[4]) || 10;
                                const packetData = parts.slice(6).join(':');

                                // Add directly to FountainDecoder's data structures
                                FountainDecoder.chunks.push({ id: packetId, data: packetData });
                                FountainDecoder.receivedPackets.add(packetId);
                                FountainDecoder.processingStats.dataPackets++;
                                FountainDecoder.lastUniquePacketTime = Date.now();

                                // Set metadata if needed
                                if (!FountainDecoder.fileMetadata) {
                                    FountainDecoder.fileMetadata = {
                                        totalChunks: numChunks,
                                        name: 'reconstructed-file.bin',
                                        type: 'application/octet-stream',
                                        size: 0
                                    };
                                }

                                LogManager.success(`Forced processing of D: format packet: ID=${packetId}`);
                                UI.showNotification(`Packet id ${packetId} recovered via direct processing`, 'success');

                                // Try to reconstruct the file
                                const isComplete = FountainDecoder.tryReconstructFile();
                                if (isComplete) {
                                    UI.showNotification('File recovery complete!', 'success');
                                    document.getElementById('downloadFileBtn').disabled = false;
                                }

                                // Update UI
                                UI.updateFileInfo(FountainDecoder.getFileInfo());
                                UI.updateChunkGrid(
                                    FountainDecoder.getTotalChunks(),
                                    FountainDecoder.getReceivedChunkIds()
                                );
                                UI.updateProgressBar(
                                    FountainDecoder.getProgress()
                                );
                                return;
                            }
                        } catch (e) {
                            console.error("Error during forced D: format processing:", e);
                        }
                    }

                    // Count invalid format if we get here
                    FountainDecoder.processingStats.invalidFormats++;

                    // Regular QR code
                    UI.showNotification(`QR Code: ${typeof data === 'string' ? data.substring(0, 30) + (data.length > 30 ? '...' : '') : JSON.stringify(data).substring(0, 30) + '...'
                        }`, 'info');
                    EventBus.emit('qrCodeDetected', data, location);

                    // Additional logging for the Event Bus notification
                    if (Core.state.debugMode) {
                        LogManager.log(`Emitted qrCodeDetected event for non-fountain QR code`);
                    }
                }

                // Update stats after processing
                UI.updateStats();
            }
        };
        // 6. Video Uploader for handling video file uploads
        const VideoUploader = {
            videoElement: null,
            canvasElement: null,
            canvasContext: null,
            videoFile: null,
            processInterval: null,
            processingActive: false,
            currentFrame: 0,

            init: function () {
                this.videoElement = document.getElementById('uploadedVideo');
                this.canvasElement = document.getElementById('videoCanvas');
                this.canvasContext = this.canvasElement.getContext('2d', { willReadFrequently: true });

                // Set up file input
                const fileInput = document.getElementById('videoFileInput');
                fileInput.addEventListener('change', (e) => this.handleFileSelect(e));

                // Set up control buttons
                document.getElementById('startProcessingBtn').addEventListener('click', () => this.startProcessing());
                document.getElementById('stopProcessingBtn').addEventListener('click', () => this.stopProcessing());

                // Set up video events
                this.videoElement.addEventListener('loadedmetadata', () => {
                    document.getElementById('startProcessingBtn').disabled = false;

                    // Size canvas to match video
                    this.canvasElement.width = this.videoElement.videoWidth;
                    this.canvasElement.height = this.videoElement.videoHeight;

                    LogManager.log(`Video loaded: ${this.videoElement.videoWidth}x${this.videoElement.videoHeight}`);
                });

                LogManager.log('Video uploader initialized');
            },

            handleFileSelect: function (event) {
                const files = event.target.files;

                if (files.length === 0) {
                    return;
                }

                const file = files[0];

                // Check if this is a video file
                if (!file.type.startsWith('video/')) {
                    UI.showNotification('Please select a video file', 'error');
                    return;
                }

                // Update UI
                document.getElementById('videoFileLabel').textContent = file.name;
                document.getElementById('videoOverlay').classList.add('hidden');

                // Create object URL for video
                const url = URL.createObjectURL(file);
                this.videoElement.src = url;

                // Store file reference
                this.videoFile = file;

                LogManager.log(`Video file selected: ${file.name} (${this.formatFileSize(file.size)})`);
            },

            formatFileSize: function (bytes) {
                if (bytes === 0) return '0 Bytes';

                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(1024));
                return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + ' ' + sizes[i];
            },

            startProcessing: function () {
                // Check if we have a video
                if (!this.videoFile) {
                    UI.showNotification('Please select a video file first', 'warning');
                    return;
                }

                // Start from beginning
                this.videoElement.currentTime = 0;
                this.currentFrame = 0;

                // Update state
                this.processingActive = true;

                // Update UI
                document.getElementById('startProcessingBtn').disabled = true;
                document.getElementById('stopProcessingBtn').disabled = false;
                document.getElementById('processingStatus').textContent = 'Active';
                document.getElementById('processingStatus').className = 'status-badge active';

                // Start playback
                this.videoElement.play();

                // Set up processing interval
                const frameRate = Core.state.scanRate;
                const interval = 1000 / frameRate;

                this.processInterval = setInterval(() => {
                    this.processVideoFrame();
                }, interval);

                LogManager.log(`Video processing started at ${frameRate} FPS`);
                UI.showNotification('Video processing started', 'info');
            },

            stopProcessing: function () {
                // Clear interval
                if (this.processInterval) {
                    clearInterval(this.processInterval);
                    this.processInterval = null;
                }

                // Pause video
                this.videoElement.pause();

                // Update state
                this.processingActive = false;

                // Update UI
                document.getElementById('startProcessingBtn').disabled = false;
                document.getElementById('stopProcessingBtn').disabled = true;
                document.getElementById('processingStatus').textContent = 'Inactive';
                document.getElementById('processingStatus').className = 'status-badge inactive';

                // Reset decoding status to inactive
                UI.updateDecodingStatus(false);

                LogManager.log('Video processing stopped');
                UI.showNotification('Video processing stopped', 'info');
            },

            processVideoFrame: function () {
                // Skip if video is not ready or paused or ended
                if (
                    this.videoElement.readyState !== this.videoElement.HAVE_ENOUGH_DATA ||
                    this.videoElement.paused ||
                    this.videoElement.ended
                ) {
                    // Check if video ended
                    if (this.videoElement.ended) {
                        this.stopProcessing();
                        LogManager.log('Video processing complete');
                        UI.showNotification('Video processing complete', 'success');
                    }
                    return;
                }

                // Get video dimensions
                const videoWidth = this.videoElement.videoWidth;
                const videoHeight = this.videoElement.videoHeight;

                // Draw video frame to canvas
                this.canvasContext.drawImage(this.videoElement, 0, 0, videoWidth, videoHeight);

                // Get frame data
                const imageData = this.canvasContext.getImageData(0, 0, videoWidth, videoHeight);

                // Process frame with selected image processing
                const processedImageData = CameraManager.preprocessImageData(imageData);

                // Increment frame counter
                Core.state.frameCounter++;
                this.currentFrame++;

                // Update last frame time
                Core.state.lastFrameTime = new Date();

                // Send to worker pool for QR detection
                WorkerPool.processFrame(processedImageData);

                // Update stats
                UI.updateStats();
            }
        };

        // 7. Fountain Decoder for QR code decoding and data reassembly
        const FountainDecoder = {
            chunks: [],
            receivedPackets: new Set(),
            receivedChunks: new Set(),
            fileMetadata: null,
            fileData: null,
            lastUniquePacketTime: 0,
            processingStats: {
                totalQrDetected: 0,
                uniqueChunksReceived: 0,
                duplicateChunks: 0,
                invalidFormats: 0,
                metadataChunks: 0,
                dataChunks: 0,
                dataPackets: 0
            },

            init: function () {
                this.chunks = [];
                this.receivedPackets = new Set();
                this.receivedChunks = new Set();
                this.dataPackets = 0;
                this.dataChunks = 0;
                this.fileMetadata = null;
                this.fileData = null;
                this.lastUniquePacketTime = Date.now();
                // Start timing for performance tracking
                this.start_time = null;

                // Enhanced tracking for LT with systematic extensions
                this.systematic_packets_received = 0;
                this.fountain_packets_received = 0;
                this.systematic_phase_complete = false;

                // Track frame statistics
                this.frames_scanned = 0;
                this.duplicate_frames = 0;
                this.invalid_frames = 0;
                this.decoding_efficiency = 0;

                this.processingStats = {
                    totalQrDetected: 0,
                    uniqueChunksReceived: 0,
                    duplicateChunks: 0,
                    invalidFormats: 0,
                    metadataChunks: 0,
                    dataPackets: 0
                };

                // Set up download button
                document.getElementById('downloadFileBtn').addEventListener('click', () => this.downloadFile());

                // Make sure the Save Chunks button is disabled by default
                const saveChunksBtn = document.getElementById('saveChunksBtn');
                if (saveChunksBtn) {
                    saveChunksBtn.disabled = true;
                }

                LogManager.log('Fountain decoder initialized');
            },

            // Save all chunks to individual files for debugging
            // Analyze chunk format for debugging
            // Extract the actual data from a chunk by processing format prefixes
            extractActualChunkData: function (chunkData) {
                if (!chunkData) return null;

                // Handle different formats

                // 1. Handle fountain format (D:...)
                if (chunkData.startsWith('D:')) {
                    const parts = chunkData.split(':');
                    if (parts.length >= 6) {
                        // The data is after the 6th colon in fountain format
                        return parts.slice(6).join(':');
                    }
                }

                // 2. Handle numeric prefix (like "38:...")
                if (/^\d+:/.test(chunkData)) {
                    const colonIndex = chunkData.indexOf(':');
                    if (colonIndex > 0) {
                        return chunkData.substring(colonIndex + 1);
                    }
                }

                // 3. Handle combined chunks (like "0:data|1:data|...")
                if (chunkData.includes('|') && chunkData.includes(':')) {
                    try {
                        const parts = chunkData.split('|');
                        const extractedParts = parts.map(part => {
                            const colonIdx = part.indexOf(':');
                            if (colonIdx > 0 && !isNaN(parseInt(part.substring(0, colonIdx)))) {
                                return part.substring(colonIdx + 1);
                            }
                            return part;
                        });
                        return extractedParts.join('\n---COMBINED CHUNK SEPARATOR---\n');
                    } catch (e) {
                        console.error("Error processing combined format:", e);
                    }
                }

                // 4. Handle JSON format
                if (chunkData.startsWith('{') && chunkData.endsWith('}')) {
                    try {
                        const parsed = JSON.parse(chunkData);
                        if (parsed.data) {
                            return parsed.data;
                        }
                    } catch (e) {
                        // Not valid JSON, ignore
                    }
                }

                // 5. Check for metadata prefix (M:...)
                if (chunkData.startsWith('M:')) {
                    const parts = chunkData.split(':');
                    if (parts.length >= 5) {
                        // Extract the metadata parts
                        try {
                            const metadata = {
                                version: parts[1],
                                filename: decodeURIComponent(parts[2]),
                                type: decodeURIComponent(parts[3]),
                                size: parts[4],
                                chunks: parts[5]
                            };
                            return "METADATA: " + JSON.stringify(metadata, null, 2);
                        } catch (e) {
                            console.error("Error parsing metadata:", e);
                        }
                    }
                }

                // No known format detected
                return null;
            },

            // Generate a simple checksum for data integrity verification
            simpleChecksum: function (data) {
                if (!data) return "empty";
                let hash = 0;
                for (let i = 0; i < Math.min(data.length, 10000); i++) {
                    hash = ((hash << 5) - hash) + data.charCodeAt(i);
                    hash = hash & hash; // Convert to 32bit integer
                }
                return hash.toString(16);
            },

            analyzeChunkFormat: function (chunkData) {
                if (!chunkData) return "Empty";

                if (chunkData.startsWith('{') && chunkData.endsWith('}')) {
                    try {
                        const parsed = JSON.parse(chunkData);
                        const keys = Object.keys(parsed);
                        return `JSON (keys: ${keys.join(', ')})`;
                    } catch (e) {
                        return "Invalid JSON";
                    }
                }

                if (chunkData.startsWith('D:')) {
                    const parts = chunkData.split(':');
                    if (parts.length >= 6) {
                        return `Fountain (packet: ${parts[1]}, seed: ${parts[2]}, numChunks: ${parts[4]}, degree: ${parts[5]})`;
                    }
                    return "Partial Fountain Format";
                }

                if (chunkData.startsWith('M:')) {
                    const parts = chunkData.split(':');
                    if (parts.length >= 7) {
                        return `Metadata (version: ${parts[1]}, chunks: ${parts[5]})`;
                    }
                    return "Partial Metadata Format";
                }

                if (/^\d+:/.test(chunkData)) {
                    const colonIndex = chunkData.indexOf(':');
                    const prefix = chunkData.substring(0, colonIndex);
                    return `Numeric Prefix (${prefix})`;
                }

                if (chunkData.includes('|') && chunkData.includes(':')) {
                    const pipes = chunkData.match(/\|/g).length;
                    return `Combined Format (${pipes + 1} chunks)`;
                }

                if (chunkData.includes('CHUNK:')) {
                    return "Custom CHUNK Format";
                }

                // Check for base64 patterns
                if (/^[A-Za-z0-9+/]*={0,2}$/.test(chunkData)) {
                    return "Likely Base64";
                }

                return "Unknown Format";
            },

            // Save all chunks with memory-efficient options
            saveAllChunks: function () {
                try {
                    if (!this.chunks || this.chunks.length === 0) {
                        LogManager.error("No chunks available to save");
                        return;
                    }

                    // Calculate total size and provide options
                    const totalSize = this.chunks.reduce((sum, c) => sum + (c.data ? c.data.length : 0), 0);
                    const sizeInKB = Math.round(totalSize / 1024);
                    const sizeWarning = sizeInKB > 5000 ?
                        ` WARNING: This is a large amount of data (${sizeInKB} KB). Consider using Preview mode.` :
                        "";

                    // Ask user for save mode
                    const saveModes = [
                        "full - Complete data (may use a lot of memory)",
                        "preview - First 500 chars of each chunk (memory efficient)",
                        "smart - Full data for small chunks (2000 chars), preview for large ones"
                    ];

                    const userChoice = "1";

                    if (!userChoice) return; // User cancelled

                    // Set save mode based on user choice
                    switch (userChoice.trim()) {
                        case "1":
                            this._saveMode = "full";
                            break;
                        case "2":
                            this._saveMode = "preview";
                            break;
                        case "3":
                            this._saveMode = "smart";
                            break;
                        default:
                            this._saveMode = "preview"; // Default to preview mode
                    }

                    try {
                        // Create a manifest file with overall information
                        const manifestContent =
                            `Debugging information for QR File Transfer\n` +
                            `Generated: ${new Date().toISOString()}\n` +
                            `Total received packets: ${this.chunks.length}\n` +
                            `Unique chunk indices received: ${this.receivedChunks.size}\n` +
                            `Received chunk indices: ${Array.from(this.receivedChunks).sort((a, b) => a - b).join(', ')}\n` +
                            `File metadata: ${JSON.stringify(this.fileMetadata, null, 2)}\n` +
                            `Processing stats: ${JSON.stringify(this.processingStats, null, 2)}\n` +
                            `All required chunks received: ${this.receivedChunks.size >= (this.fileMetadata?.totalChunks || 0)}\n` +
                            `${this.missingChunks && this.missingChunks.size > 0 ?
                                `Missing chunk indices: ${Array.from(this.missingChunks).sort((a, b) => a - b).join(', ')}` :
                                'No missing chunks!'}\n`;

                        // Add raw state info to the manifest
                        const rawState = {
                            fileData: this.fileData ? `${this.fileData.substring(0, 100)}... (${this.fileData.length} chars)` : null,
                            // Note: These are technically packets, each containing one or more chunks
                            receivedPackets: this.chunks.map(c => {
                                const chunkData = c.data || "";
                                const extractedData = this.extractActualChunkData(chunkData);
                                let decodedBase64 = null;

                                // Try to detect and decode base64 content
                                try {
                                    const cleanedForBase64 = chunkData.replace(/[^A-Za-z0-9+/=]/g, '');
                                    if (/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(cleanedForBase64)) {
                                        try {
                                            decodedBase64 = atob(cleanedForBase64);
                                        } catch (e) {
                                            console.log(`Failed to decode base64 in chunk ${c.id}: ${e.message}`);
                                        }
                                    }
                                } catch (e) {
                                    console.error(`Error processing chunk ${c.id} for base64: ${e.message}`);
                                }

                                // Format analysis result
                                const format = this.analyzeChunkFormat(chunkData);

                                // Format details with boolean flags
                                const formatDetails = {
                                    containsFountainMarker: chunkData.includes('D:'),
                                    containsMetadataMarker: chunkData.includes('M:'),
                                    containsNumericPrefix: /^\d+:/.test(chunkData),
                                    containsPipeSeparator: chunkData.includes('|')
                                };

                                return {
                                    id: c.id,
                                    dataLength: chunkData.length,
                                    format: format,
                                    formatDetails: formatDetails,
                                    preview: chunkData.substring(0, 30),
                                    detailedData: this._saveMode === 'full' || (this._saveMode === 'smart' && chunkData.length <= 2000) ?
                                        chunkData :
                                        chunkData.substring(0, 500) + (chunkData.length > 500 ? " [...truncated, full length: " + chunkData.length + " chars]" : "")
                                    // Removed extractedData and decodedBase64 fields that were always null
                                };
                            }),
                            receivedChunks: Array.from(this.receivedChunks).sort(),
                            processingData: {
                                // Add checksums of original data for verification
                                originalDataLength: this.fileData ? this.fileData.length : 0,
                                originalDataChecksum: this.fileData ? this.simpleChecksum(this.fileData) : null,
                                reconstructionMethod: this.fileData ? "Fountain" : "Not reconstructed",
                                lastError: this._lastError || null
                            }
                        };

                        // Add this to manifest
                        const fullManifest = manifestContent +
                            `\n\n------ DETAILED STATE INFO ------\n` +
                            JSON.stringify(rawState, null, 2);



                    } catch (error) {
                        LogManager.error(`Error saving chunks: ${error.message}`);
                        console.error("Error saving chunks:", error);
                    }
                } catch (outerError) {
                    console.error("Critical error in saveAllChunks:", outerError);
                    UI.showNotification('Error saving chunks: ' + (outerError.message || 'Unknown error'), 'error');
                }
            },

            isValidChunk: function (data) {
                // Basic validation - real implementation would check format
                try {
                    if (!data || typeof data !== 'string') {
                        LogManager.warn(`Invalid chunk: Not a string or empty: ${typeof data}`);
                        return false;
                    }

                    // Log full QR data for debugging
                    if (Core.state.debugMode) {
                        LogManager.log(`QR data format check: ${data.substring(0, 100)}${data.length > 100 ? '...' : ''}`);
                    }

                    // Check for JSON format
                    if (data.startsWith('{') && data.endsWith('}')) {
                        try {
                            const parsed = JSON.parse(data);

                            // Check for standard chunk format
                            const hasStandardFormat = parsed.hasOwnProperty('packetId') && parsed.hasOwnProperty('data');

                            // Check for seed-based format (which appears to be used in the QR codes)
                            const hasSeedFormat = parsed.hasOwnProperty('seed');

                            // Accept either format
                            const isValid = hasStandardFormat || hasSeedFormat;

                            if (Core.state.debugMode) {
                                if (isValid) {
                                    if (hasStandardFormat) {
                                        LogManager.success(`Valid JSON chunk: packetId=${parsed.packetId}`);
                                    } else if (hasSeedFormat) {
                                        LogManager.success(`Valid JSON seed-based chunk: seed=${parsed.seed}`);
                                    }
                                } else {
                                    LogManager.warn(`JSON format doesn't match expected patterns. Keys: ${Object.keys(parsed).join(', ')}`);
                                }
                            }

                            return isValid;
                        } catch (jsonError) {
                            LogManager.error(`JSON parse error: ${jsonError.message}`);
                            return false;
                        }
                    }

                    // Check for custom format (e.g. prefix:data)
                    if (data.includes('CHUNK:')) {
                        LogManager.success(`Valid chunk format: CHUNK: prefix found`);
                        return true;
                    }

                    // Check for fountain encoder format:
                    // D:counter:seed:seedBase:numChunks:degree:data
                    if (data.startsWith('D:')) {
                        const parts = data.split(':');
                        console.log("D: format detected - parts:", parts);

                        // Make the validation much more lenient - if it has the D: prefix, always process it
                        // We'll handle detailed validation in the process step
                        if (Core.state.debugMode) {
                            LogManager.success(`Found fountain data format with D: prefix, accepting it unconditionally`);

                            // Log more details about the detected format
                            try {
                                if (parts.length >= 6) {
                                    const counter = parseInt(parts[1]);
                                    const seed = parseInt(parts[2]);
                                    const seedBase = parseInt(parts[3]);
                                    const numChunks = parseInt(parts[4]);
                                    const degree = parseInt(parts[5]);

                                    console.log("Fountain data details:", {
                                        counter, seed, seedBase, numChunks, degree,
                                        dataStart: parts.length > 6 ? parts[6].substring(0, 20) + '...' : 'N/A'
                                    });
                                } else {
                                    console.log("Partial D: format with insufficient parts:", parts);
                                }
                            } catch (err) {
                                console.error("Error parsing fountain format:", err);
                            }
                        }

                        // Be completely permissive with the format - always accept it
                        return true;
                    }

                    // Check for metadata format: M:version:filename:type:...
                    if (data.startsWith('M:')) {
                        const parts = data.split(':');
                        const isValid = parts.length >= 5;

                        if (Core.state.debugMode) {
                            if (isValid) {
                                LogManager.success(`Valid metadata format: ${parts.length} parts`);
                            } else {
                                LogManager.warn(`Invalid metadata format: ${parts.length} parts (expected 5)`);
                            }
                        }

                        return isValid;
                    }

                    // Check for special seed-only format that might be used
                    if (data.startsWith('seed:')) {
                        LogManager.log(`Found seed-only format: ${data}`);
                        return true;
                    }

                    // Check for numeric prefix format (eg "38:data...")
                    if (/^\d+:/.test(data)) {
                        // Extract the ID and check if it's a valid number
                        const colonIndex = data.indexOf(':');
                        if (colonIndex > 0) {
                            const id = parseInt(data.substring(0, colonIndex));
                            if (!isNaN(id)) {
                                LogManager.success(`Valid numeric prefix format: ID=${id}`);
                                return true;
                            }
                        }
                    }

                    LogManager.warn(`Unrecognized QR format: ${data.substring(0, 30)}...`);
                    // Track invalid format errors
                    Core.state.qrErrorStats.invalidFormat++;
                    return false;
                } catch (e) {
                    LogManager.error(`Error validating chunk: ${e.message}`);

                    // Determine type of validation error for tracking
                    if (e.message.includes('integrity') || e.message.includes('checksum')) {
                        Core.state.qrErrorStats.failedIntegrity++;
                    } else if (e.message.includes('corrupted') || e.message.includes('correctable')) {
                        Core.state.qrErrorStats.notCorrectable++;
                    } else {
                        // Generic invalid format
                        Core.state.qrErrorStats.invalidFormat++;
                    }

                    return false;
                }
            },

            processChunk: function (data) {
                // IMPORTANT TERMINOLOGY CLARIFICATION:
                // - Packet/Frame: A single QR code containing data (what is passed to this function)
                // - Chunk: A piece of the original file with a specific index (0 to N-1)
                // - A packet may contain one chunk or multiple chunks
                // We're processing a packet here to extract one or more chunks

                let chunkData = null;
                let packetId = -1;
                let isMetadata = false;

                // Immediately check if this is a critical chunk ID like 0
                const firstBlockMatch = /^0:/.test(data);
                if (firstBlockMatch) {
                    console.log("!!! FOUND BLOCK 0 - CRITICAL FOR RECONSTRUCTION !!!");
                }

                // IMPORTANT: We already incremented totalQrDetected in handleQRData
                // DO NOT increment it again here to avoid duplicate counting
                console.log(`Current QR stats before processing: Total=${this.processingStats.totalQrDetected}, Unique=${this.processingStats.uniqueChunksReceived}`);

                // Parse chunk data
                try {
                    if (/^\d+:/.test(data)) {
                        // Numeric prefix format (like "38:data")
                        console.log("Detected numeric prefix format");

                        try {
                            // Extract the numeric ID and the data
                            const colonIndex = data.indexOf(':');
                            if (colonIndex > 0) {
                                // Parse the chunk index from the prefix
                                const chunkIndex = parseInt(data.substring(0, colonIndex));
                                chunkData = data.substring(colonIndex + 1);


                                console.error(`Numeric prefix format: Chunk index=${chunkIndex}, data length=${chunkData.length}`);
                                if (Core.state.debugMode) {
                                    console.log(`First 50 chars: ${chunkData.substring(0, 50)}`);
                                }

                                // Special emphasis on chunk 0
                                if (chunkIndex === 0) {
                                    console.log(`FOUND CRITICAL CHUNK 0! This is important for reconstruction.`);
                                    // Force an immediate update of missing chunks
                                    if (this.missingChunks && this.missingChunks.has(0)) {
                                        console.log("Marking chunk 0 as received in missing chunks tracking");
                                    }
                                }

                                // If we have no metadata yet, guess based on available chunks
                                if (!this.fileMetadata) {
                                    // Better estimation based on the highest chunk ID we've seen
                                    // This will be constantly refined as more chunks come in
                                    const highestID = Math.max(...Array.from(this.receivedChunks), packetId);
                                    const estimatedTotalChunks = Math.max(50, highestID * 1.5);

                                    this.fileMetadata = {
                                        totalChunks: Math.ceil(estimatedTotalChunks),
                                        name: 'reconstructed-file.xlsx', // Assume Excel based on the example
                                        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                                        size: 0
                                    };

                                    console.error(`Created estimated file metadata with ${Math.ceil(estimatedTotalChunks)} total chunks`);
                                }


                                this.processingStats.dataPackets++;
                                LogManager.success(`Successfully processed numeric prefix chunk: id=${packetId}`);
                            } else {
                                throw new Error("Invalid numeric prefix format");
                            }
                        } catch (error) {
                            console.error("Error processing numeric prefix format:", error);
                            LogManager.error(`Error processing numeric prefix: ${error.message}`);
                            throw error;
                        }
                    } else if (data.startsWith('D:')) {
                        // Fountain encoder data format
                        // D:counter:seed:seedBase:numChunks:degree:data
                        const parts = data.split(':');
                        console.log("Processing D: format data:", parts);

                        if (parts.length < 6) {
                            console.warn("Fountain format has too few parts:", parts.length);
                            throw new Error(`Invalid fountain data format: too few parts (${parts.length})`);
                        }

                        try {
                            packetId = parseInt(parts[1]);
                            const seed = parseInt(parts[2]);
                            const seedBase = parseInt(parts[3]);
                            const numChunks = parseInt(parts[4]);
                            const degree = parseInt(parts[5]);

                            if (isNaN(packetId) || isNaN(seed) || isNaN(numChunks)) {
                                console.error("Invalid numeric values in fountain format", {
                                    packetId, seed, numChunks, degree
                                });
                                throw new Error("Invalid numeric values in fountain format");
                            }

                            // The data starts at index 6 and might contain colons
                            if (parts.length >= 7) {
                                chunkData = parts.slice(6).join(':');
                                console.log("RAW CHUNK DATA:", chunkData.substring(0, 100) + (chunkData.length > 100 ? '...' : ''));
                            } else {
                                // Handle the case where there might not be data
                                chunkData = '';
                                console.warn("No data part found in fountain format");
                            }

                            // Determine if this is likely a systematic packet
                            // Systematic packets have degree 1 and packet_id < total_chunks
                            if (!this.systematic_phase_complete)
                                this.systematic_packets_received++;


                            // Check if systematic phase is now complete
                            if (!this.systematic_phase_complete && this.systematic_packets_received >= numChunks) {
                                this.systematic_phase_complete = true;
                                this.fountain_packets_received++;
                                LogManager.success("Systematic phase complete, now in fountain phase");
                                console.log("Systematic phase appears complete, entering fountain phase");
                            }

                            // Calculate decoding efficiency
                            if (this.processingStats.totalQrDetected > 0) {
                                this.decoding_efficiency = this.processingStats.uniqueChunksReceived / this.processingStats.totalQrDetected;
                            }


                            // This is the format from FountainEncoder.combineChunks: indices.map(index => `${index}:${chunks[index]}`).join("|")
                            const combinedChunks = chunkData.split('|');
                            console.log(`Found ${combinedChunks.length} chunks`);

                            // Process each chunk to extract index and data
                            const extractedChunks = [];
                            for (const chunk of combinedChunks) {
                                const separatorIndex = chunk.indexOf(':');
                                if (separatorIndex > 0) {
                                    const chunkIndex = parseInt(chunk.substring(0, separatorIndex));
                                    const chunkData = chunk.substring(separatorIndex + 1);


                                    // Check if we already have this chunk
                                    if (this.receivedChunks.has(chunkIndex)) {
                                        LogManager.log(`Duplicate chunk received: ${chunkIndex}`);
                                        this.processingStats.duplicateChunks++;


                                        const existingChunk = this.chunks.find(c => c.id === chunkIndex);
                                        if (existingChunk && (!existingChunk.data || existingChunk.data.length === 0)) {
                                            console.log("Found empty chunk 0, replacing with new data");
                                            existingChunk.data = chunkData;
                                            // Don't return here - we're updating the chunk
                                        } else {
                                            return { isNewChunk: false, isComplete: false };
                                        }

                                    } else {
                                        // Add chunk to collection
                                        this.chunks.push({ id: chunkIndex, data: chunkData });
                                        this.receivedChunks.add(chunkIndex);
                                        this.processingStats.uniqueChunksReceived++;
                                        this.lastUniqueChunkTime = Date.now();

                                        // Update missing chunks tracking
                                        this.updateMissingChunks(chunkIndex);

                                        // Force immediate UI update of missing chunks display
                                        setTimeout(() => {
                                            UI.updateChunkGrid(
                                                this.getTotalChunks(),
                                                this.getReceivedChunkIds()
                                            );
                                        }, 100);
                                    }

                                    // Special handling for chunk 0

                                    LogManager.log(`New chunk received: ${chunkIndex}`);
                                    extractedChunks.push({ index: chunkIndex, data: chunkData });
                                    console.log(`Extracted chunk ${chunkIndex}: ${chunkData.substring(0, 30)}...`);
                                }
                            }

                            // Use the original chunk data for further processing
                            console.log(`Successfully extracted ${extractedChunks.length} combined chunks`);



                            // Set total chunks in metadata if not set
                            if (!this.fileMetadata) {
                                this.fileMetadata = {
                                    totalChunks: numChunks,
                                    name: 'reconstructed-file.bin',
                                    type: 'application/octet-stream',
                                    size: 0
                                };
                                console.log(`Created file metadata with ${numChunks} total chunks`);
                            }

                            this.processingStats.dataPackets++;
                            LogManager.success(`Successfully processed fountain data packet: id=${packetId}, chunks=${numChunks}, degree=${degree}`);
                            console.log(`Fountain packet ${packetId}/${numChunks} processed successfully, data length: ${chunkData.length}`);
                        } catch (error) {
                            console.error("Error processing fountain format:", error);
                            LogManager.error(`Error processing fountain format: ${error.message}`);
                            throw error;
                        }
                    } else if (data.startsWith('M:')) {
                        // Metadata format: M:version:filename:type:size:chunks:...
                        const parts = data.split(':');
                        if (parts.length < 7) {
                            throw new Error('Invalid metadata format');
                        }
                        console.error(`Metadata: ${data}`);

                        const version = parts[1];
                        const filename = decodeURIComponent(parts[2]);
                        const fileType = decodeURIComponent(parts[3]);
                        const fileSize = parseInt(parts[4]);
                        const totalChunks = parseInt(parts[5]);

                        this.fileMetadata = {
                            name: filename,
                            type: fileType,
                            size: fileSize,
                            totalChunks: totalChunks,
                            version: version
                        };

                        // Initialize missing chunks tracking now that we know how many chunks to expect
                        this.initializeMissingChunks(totalChunks);


                        isMetadata = true;
                        this.processingStats.metadataChunks++;
                        LogManager.log(`Metadata received: ${filename}, ${totalChunks} chunks`);
                        console.log(`Missing chunks initialized: Expecting ${totalChunks} chunks to complete file`);
                        return { isNewChunk: true, isComplete: false };
                    } else if (data.startsWith('seed:')) {
                        // Special seed format
                        const parts = data.split(':');
                        packetId = parseInt(parts[1]);
                        chunkData = parts.slice(2).join(':');
                        LogManager.log(`Seed-based format: id=${packetId}`);
                        this.processingStats.dataPackets++;
                    }
                } catch (e) {
                    LogManager.error(`Error parsing chunk: ${e.message}`);
                    this.processingStats.invalidFormats++;
                    return { isNewChunk: false, isComplete: false };
                }

                // Try to reconstruct file
                const isComplete = this.tryReconstructFile();

                return { isNewChunk: true, isComplete: isComplete };
            },

            tryReconstructFile: function () {
                // Initialize transformations array for tracking data processing
                let transformations = [];

                // Check if we have metadata with total chunks
                if (!this.fileMetadata || !this.fileMetadata.totalChunks) {
                    console.log("Cannot reconstruct file: missing metadata or totalChunks information");
                    return false;
                }

                console.log(`Trying to reconstruct file: have ${this.receivedChunks.size} of ${this.fileMetadata.totalChunks} chunks`);

                // Check if we have all chunks
                if (this.receivedChunks.size < this.fileMetadata.totalChunks) {
                    return false;
                }

                console.log("Have all needed chunks, attempting reconstruction...");

                // IMPORTANT: First, try to decode fountain combined chunks
                try {
                    // Create array to track all original chunks
                    const originalChunks = new Array(this.fileMetadata.totalChunks).fill(null);
                    let extractedCount = 0;

                    // Go through all received chunks and extract embedded chunks
                    this.chunks.forEach(chunk => {
                        const chunkData = chunk.data;

                        // Check if this is a combined chunk (contains the '|' delimiter and ':' index markers)
                        if (typeof chunkData === 'string' && chunkData.includes('|') && chunkData.includes(':')) {
                            try {
                                // Split by pipe delimiter to get individual chunks
                                const combinedChunks = chunkData.split('|');

                                // Process each component chunk
                                for (const subChunk of combinedChunks) {
                                    const separatorIndex = subChunk.indexOf(':');
                                    if (separatorIndex > 0) {
                                        // Extract chunk index and data
                                        const chunkIndex = parseInt(subChunk.substring(0, separatorIndex));
                                        const chunkData = subChunk.substring(separatorIndex + 1);

                                        // Store in the original chunks array if index is valid
                                        if (!isNaN(chunkIndex) && chunkIndex >= 0 && chunkIndex < this.fileMetadata.totalChunks) {
                                            originalChunks[chunkIndex] = chunkData;
                                            extractedCount++;
                                            console.log(`Placed extracted chunk at index ${chunkIndex}`);
                                        }
                                    }
                                }
                            } catch (error) {
                                console.error("Error processing combined chunks:", error);
                            }
                        } else {
                            // This might be a direct individual chunk, try to use it as-is
                            console.log("Chunk doesn't appear to be in combined format, using as-is");
                        }
                    });

                    // Check if we have all original chunks
                    const missingChunks = originalChunks.filter(c => c === null).length;
                    console.log(`Fountain decoding extracted ${extractedCount} chunks, missing ${missingChunks} of ${this.fileMetadata.totalChunks}`);

                    if (missingChunks === 0) {
                        // We have all the original chunks, we can reconstruct the file
                        let fileContent = originalChunks.join('');

                        // Store reconstructed file
                        this.fileData = fileContent;
                        console.log(`File successfully reconstructed from fountain chunks: ${fileContent.length} characters`);
                        LogManager.success('File successfully reconstructed from fountain chunks');

                        // Stop all background tasks since we've successfully reconstructed the file
                        Core.stopAllBackgroundTasks();

                        // Enable the Save Chunks button since we have data
                        if (document.getElementById('saveChunksBtn')) {
                            document.getElementById('saveChunksBtn').disabled = false;
                        }
                        return true;
                    }
                } catch (error) {
                    console.error("Error in fountain reconstruction:", error);
                }

                // Fallback: Try traditional reconstruction method
                console.log("Fountain reconstruction failed or incomplete, trying traditional method");

                // Sort chunks by ID (packets actually)
                this.chunks.sort((a, b) => a.id - b.id);
                console.log(`Sorted ${this.chunks.length} packets by ID`);

                // Check for missing chunks based on chunk indices in receivedChunks
                // IMPORTANT: this.chunks contains PACKETS with their own IDs
                // receivedChunks contains the actual CHUNK INDICES (0 to N-1)
                const missingChunks = [];

                // Identify missing chunks by looking at which indices are not in receivedChunks
                for (let i = 0; i < this.fileMetadata.totalChunks; i++) {
                    if (!this.receivedChunks.has(i)) {
                        console.warn(`MISSING CHUNK at index ${i}`);
                        missingChunks.push(i);
                    }
                }

                // Special handling for missing chunk 0 scenario
                if (missingChunks.includes(0)) {
                    console.error("CRITICAL ERROR: Missing chunk at index 0. This chunk contains essential file information.");
                    LogManager.error("CRITICAL: Missing chunk at index 0. This chunk contains essential file information.");

                    // Now the condition is simpler since we're directly using receivedChunks to check
                    // Display a warning in the UI only if chunk 0 is definitely missing
                    UI.showNotification("Missing first QR code (index 0). Please scan this code first for proper file reconstruction.", "error", 10000);

                    // Create or update a warning element in the UI
                    const warningContainerId = 'missingChunk0Warning';
                    let warningContainer = document.getElementById(warningContainerId);

                    if (!warningContainer) {
                        warningContainer = document.createElement('div');
                        warningContainer.id = warningContainerId;
                        warningContainer.className = 'error-tracking-container pulse-animation';
                        warningContainer.style.marginTop = '15px';
                        warningContainer.style.padding = '15px';
                        warningContainer.style.backgroundColor = 'rgba(220, 38, 38, 0.1)';
                        warningContainer.style.border = '2px solid var(--danger-color)';
                        warningContainer.style.borderRadius = '8px';
                        warningContainer.style.display = 'flex';
                        warningContainer.style.flexDirection = 'column';
                        warningContainer.style.gap = '10px';

                        // Add to the UI after the progress container
                        const progressContainer = document.querySelector('.progress-container');
                        if (progressContainer && progressContainer.parentNode) {
                            progressContainer.parentNode.insertBefore(warningContainer, progressContainer.nextSibling);
                        } else {
                            // Fallback to adding to the info panel
                            const infoPanel = document.querySelector('.info-panel');
                            if (infoPanel) {
                                infoPanel.appendChild(warningContainer);
                            }
                        }
                    }

                    // Update warning content
                    warningContainer.innerHTML = `
                        <h3 style="color: var(--danger-color); margin-bottom: 10px;"> Missing Critical QR Code (Index 0)</h3>
                        <p>The first QR code (index 0) contains essential information needed to reconstruct the file properly.</p>
                        <div style="margin-top: 10px;">
                            <strong>How to fix this issue:</strong>
                            <ul style="margin-top: 5px; margin-left: 20px;">
                                <li>Ensure you scan the QR code labeled as "0" or "1 of X" first</li>
                                <li>If scanning from a screen, try adjusting brightness or contrast</li>
                                <li>If scanning from paper, ensure good lighting and no reflections</li>
                                <li>Try increasing the distance between the camera and QR code</li>
                            </ul>
                        </div>
                        <div style="margin-top: 10px;">
                            <strong>Recovery status:</strong> 
                            <span style="color: var(--warning-color);">Partial recovery may be possible but file integrity cannot be guaranteed</span>
                        </div>
                    `;
                } else if (missingChunks.length > 0) {
                    // Handle other missing chunks (not index 0)
                    console.warn(`Missing ${missingChunks.length} chunks: ${missingChunks.join(', ')}`);
                    LogManager.warn(`Missing ${missingChunks.length} chunks: ${missingChunks.join(', ')}`);

                    // Remove the missing chunk 0 warning if it exists (since chunk 0 is now present)
                    const warningContainer = document.getElementById('missingChunk0Warning');
                    if (warningContainer) {
                        warningContainer.remove();
                    }
                } else {
                    // All chunks present, remove any warnings
                    const warningContainer = document.getElementById('missingChunk0Warning');
                    if (warningContainer) {
                        warningContainer.remove();
                    }
                }

                // Log detailed info about each chunk
                const chunkInfo = {};
                this.chunks.forEach(chunk => {
                    chunkInfo[chunk.id] = {
                        length: chunk.data ? chunk.data.length : 0,
                        start: chunk.data ? chunk.data.substring(0, 20) : 'null',
                        end: chunk.data ? chunk.data.substring(chunk.data.length - 20) : 'null'
                    };
                });
                console.log("CHUNK DATA INFO:", chunkInfo);

                // Concatenate chunk data, ensuring proper ordering
                let orderedChunks = new Array(this.fileMetadata.totalChunks).fill(null);

                // First, try to identify chunks by their actual index to ensure proper ordering
                this.chunks.forEach(chunk => {
                    if (chunk.id >= 0 && chunk.id < this.fileMetadata.totalChunks) {
                        if (orderedChunks[chunk.id] === null) {
                            orderedChunks[chunk.id] = chunk.data;
                            console.log(`Placed chunk at index ${chunk.id} (ID-based assignment)`);
                        } else {
                            console.log(`Duplicate chunk for index ${chunk.id}, keeping first occurrence`);
                        }
                    }
                });

                // CRITICAL FIX: Special attention to the first chunk, which might have been missed
                // This is especially critical because the first chunk often contains header information
                if (orderedChunks[0] === null) {
                    console.warn("CRITICAL: First chunk (index 0) is missing! Attempting to recover...");
                    LogManager.warn("First chunk (index 0) is missing! Attempting recovery...");

                    // Track recovery attempts for detailed reporting
                    const recoveryAttempts = [];
                    let recoverySuccess = false;
                    let recoveryMethod = "";

                    // First, explicitly check if we have any chunk with ID 0
                    const explicitZeroChunk = this.chunks.find(chunk => chunk.id === 0);
                    if (explicitZeroChunk) {
                        console.log("Found explicit chunk with ID 0, using it");
                        orderedChunks[0] = explicitZeroChunk.data;
                        recoverySuccess = true;
                        recoveryMethod = "Found explicit chunk with ID 0";
                        recoveryAttempts.push({ method: "Explicit ID", result: "Success", details: "Found chunk explicitly marked as ID 0" });
                    } else {
                        recoveryAttempts.push({ method: "Explicit ID", result: "Failed", details: "No chunk explicitly marked as ID 0 found" });

                        // Check if any chunk contains metadata that suggests it might be the first chunk
                        // This includes signatures, headers, or special format patterns
                        console.log("Checking for chunks with metadata signatures that suggest it could be chunk 0...");

                        // Common file signatures for various file types
                        const fileSignatures = {
                            // Excel and Office files
                            excel: ['UEsDB', 'PK', '[Content_Types].xml'],
                            // PDF signatures
                            pdf: ['%PDF', 'PDF-'],
                            // Image signatures (base64)
                            image: ['/9j/', 'iVBOR', 'R0lGOD', 'UklGR'],
                            // Text file common headers
                            text: ['<!DOCTYPE', '<html', '<?xml', '{', '['],
                            // JSON common patterns
                            json: ['{', '{"', '[', '[{'],
                            // CSV common patterns
                            csv: ['ID,', 'Name,', 'Date,', 'Time,']
                        };

                        // Look through all chunks to see if any might be the first one
                        // Sort chunks by ID to examine lowest IDs first
                        const sortedChunks = [...this.chunks].sort((a, b) => a.id - b.id);
                        let signatureFound = false;

                        // First, try to detect by file signatures from known file types
                        for (const chunk of sortedChunks) {
                            if (chunk.data && typeof chunk.data === 'string' && chunk.data.length > 0) {
                                const chunkStart = chunk.data.substring(0, 50);

                                // Check for file signatures
                                for (const [fileType, signatures] of Object.entries(fileSignatures)) {
                                    for (const signature of signatures) {
                                        if (chunkStart.includes(signature)) {
                                            console.log(`Chunk ${chunk.id} has ${fileType} file signature '${signature}', using as first chunk`);
                                            LogManager.log(`Recovery: Chunk ${chunk.id} has ${fileType} signature, using as chunk 0`);
                                            orderedChunks[0] = chunk.data;
                                            recoverySuccess = true;
                                            recoveryMethod = `Detected ${fileType} file signature`;
                                            signatureFound = true;
                                            recoveryAttempts.push({
                                                method: "File Signature",
                                                result: "Success",
                                                details: `Detected ${fileType} file signature in chunk ${chunk.id}`
                                            });
                                            break;
                                        }
                                    }
                                    if (signatureFound) break;
                                }
                                if (signatureFound) break;
                            }
                        }

                        // If we couldn't find by signature, try by low chunk ID 
                        if (!signatureFound) {
                            recoveryAttempts.push({ method: "File Signature", result: "Failed", details: "No known file signatures detected in any chunks" });

                            for (const chunk of sortedChunks) {
                                // First couple of chunks are likely candidates for start data
                                if (chunk.id <= 5 && chunk.data) {
                                    console.log(`Examining low ID chunk ${chunk.id} as possible first chunk`);

                                    // If this is a low chunk ID, it's likely to be close to the start
                                    if (chunk.id <= 2) {
                                        console.log(`Using low ID chunk ${chunk.id} as the first chunk`);
                                        LogManager.log(`Recovery: Using low ID chunk ${chunk.id} as chunk 0`);
                                        orderedChunks[0] = chunk.data;
                                        recoverySuccess = true;
                                        recoveryMethod = `Used low ID chunk ${chunk.id}`;
                                        recoveryAttempts.push({
                                            method: "Low ID Proximity",
                                            result: "Success",
                                            details: `Used chunk with low ID (${chunk.id}) as substitute for chunk 0`
                                        });
                                        break;
                                    }
                                }
                            }

                            // If we still don't have a first chunk, try the lowest ID chunk we have
                            if (orderedChunks[0] === null && sortedChunks.length > 0) {
                                recoveryAttempts.push({ method: "Low ID Proximity", result: "Failed", details: "No suitable low ID chunks found" });

                                const lowestChunk = sortedChunks[0];
                                console.log(`Last resort: Using lowest ID chunk (${lowestChunk.id}) as the first chunk`);
                                LogManager.log(`Recovery: Last resort using lowest ID chunk ${lowestChunk.id} as chunk 0`);
                                orderedChunks[0] = lowestChunk.data;
                                recoverySuccess = true;
                                recoveryMethod = `Last resort: used lowest available ID (${lowestChunk.id})`;
                                recoveryAttempts.push({
                                    method: "Last Resort",
                                    result: "Success",
                                    details: `Used lowest available chunk ID (${lowestChunk.id}) as last resort`
                                });
                            } else if (orderedChunks[0] === null) {
                                // Complete failure - we couldn't recover at all
                                recoveryAttempts.push({ method: "Last Resort", result: "Failed", details: "No chunks available to use as substitute" });
                                recoverySuccess = false;
                                recoveryMethod = "All recovery methods failed";
                                console.error("CRITICAL ERROR: Could not recover chunk 0 by any method");
                                LogManager.error("CRITICAL: All recovery methods for chunk 0 failed");
                            }
                        }
                    }

                    // Update the UI with recovery information if we have a warning container
                    const warningContainer = document.getElementById('missingChunk0Warning');
                    if (warningContainer) {
                        const recoveryStatusDiv = warningContainer.querySelector('div:last-child');

                        if (recoveryStatusDiv) {
                            // Update recovery status based on success
                            if (recoverySuccess) {
                                recoveryStatusDiv.innerHTML = `
                                    <strong>Recovery status:</strong> 
                                    <span style="color: var(--warning-color);">Attempted recovery using ${recoveryMethod}</span>
                                    <div style="margin-top: 5px; font-style: italic; color: var(--warning-color);">
                                        File might be partially recovered but integrity cannot be guaranteed
                                    </div>
                                `;
                            } else {
                                recoveryStatusDiv.innerHTML = `
                                    <strong>Recovery status:</strong> 
                                    <span style="color: var(--danger-color);">Failed to recover chunk 0</span>
                                    <div style="margin-top: 5px; font-style: italic; color: var(--danger-color);">
                                        File reconstruction is likely to fail or produce corrupted results
                                    </div>
                                `;
                            }
                        }

                        // Add a button to view detailed recovery information
                        const detailsButton = document.createElement('button');
                        detailsButton.style.marginTop = '10px';
                        detailsButton.style.padding = '8px 12px';
                        detailsButton.style.backgroundColor = 'var(--primary-color)';
                        detailsButton.style.color = 'white';
                        detailsButton.style.border = 'none';
                        detailsButton.style.borderRadius = '4px';
                        detailsButton.style.cursor = 'pointer';
                        detailsButton.textContent = 'View Recovery Details';

                        detailsButton.onclick = function () {
                            console.log("Recovery attempts:", recoveryAttempts);

                            // Create and display a modal with recovery details
                            const modal = document.createElement('div');
                            modal.style.position = 'fixed';
                            modal.style.top = '0';
                            modal.style.left = '0';
                            modal.style.width = '100%';
                            modal.style.height = '100%';
                            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                            modal.style.display = 'flex';
                            modal.style.justifyContent = 'center';
                            modal.style.alignItems = 'center';
                            modal.style.zIndex = '1000';

                            const modalContent = document.createElement('div');
                            modalContent.style.backgroundColor = 'white';
                            modalContent.style.padding = '20px';
                            modalContent.style.borderRadius = '8px';
                            modalContent.style.width = '80%';
                            modalContent.style.maxWidth = '600px';
                            modalContent.style.maxHeight = '80%';
                            modalContent.style.overflow = 'auto';

                            let detailsHtml = `
                                <h3>Chunk 0 Recovery Details</h3>
                                <p>The following recovery methods were attempted:</p>
                                <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                                    <thead>
                                        <tr>
                                            <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Method</th>
                                            <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Result</th>
                                            <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Details</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                            `;

                            recoveryAttempts.forEach(attempt => {
                                const resultColor = attempt.result === 'Success' ? 'var(--success-color)' : 'var(--danger-color)';
                                detailsHtml += `
                                    <tr>
                                        <td style="border: 1px solid #ddd; padding: 8px;">${attempt.method}</td>
                                        <td style="border: 1px solid #ddd; padding: 8px; color: ${resultColor};">${attempt.result}</td>
                                        <td style="border: 1px solid #ddd; padding: 8px;">${attempt.details}</td>
                                    </tr>
                                `;
                            });

                            detailsHtml += `
                                    </tbody>
                                </table>
                                <p style="margin-top: 15px;">Final recovery status: 
                                    <span style="color: ${recoverySuccess ? 'var(--warning-color)' : 'var(--danger-color)'};">
                                        ${recoverySuccess ? 'Attempted recovery but data integrity may be compromised' : 'Failed to recover chunk 0'}
                                    </span>
                                </p>
                                <div style="text-align: right; margin-top: 20px;">
                                    <button id="closeRecoveryDetails" style="padding: 8px 16px; background-color: var(--primary-color); color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>
                                </div>
                            `;

                            modalContent.innerHTML = detailsHtml;
                            modal.appendChild(modalContent);
                            document.body.appendChild(modal);

                            // Add close button functionality
                            document.getElementById('closeRecoveryDetails').addEventListener('click', function () {
                                document.body.removeChild(modal);
                            });
                        };

                        // Add the button to the warning container
                        warningContainer.appendChild(detailsButton);
                    }

                    // Log recovery information
                    console.log("Recovery attempts summary:", recoveryAttempts);
                    LogManager.log(`Chunk 0 recovery ${recoverySuccess ? 'attempted' : 'failed'}: ${recoveryMethod}`);
                }

                // Check for null chunks
                const nullChunks = orderedChunks.filter(c => c === null).length;
                if (nullChunks > 0) {
                    console.warn(`WARNING: ${nullChunks} chunks are missing in the ordered array`);
                    // Log which indices are missing
                    orderedChunks.forEach((chunk, index) => {
                        if (chunk === null) {
                            console.warn(`Missing chunk at index ${index}`);
                        }
                    });
                }

                // Filter out null chunks
                const validChunks = orderedChunks.filter(c => c !== null);
                console.log(`Using ${validChunks.length} valid chunks out of ${this.fileMetadata.totalChunks} total`);

                // Debug: Print the first few characters of each chunk to verify order
                validChunks.forEach((chunk, index) => {
                    if (chunk) {
                        const preview = chunk.substring(0, 20).replace(/\s+/g, ' ');
                        console.log(`Chunk ${index} start: ${preview}...`);
                    }
                });

                // Before joining, do extensive cleaning of the chunks
                const cleanedChunks = validChunks.map((chunk, idx) => {
                    if (typeof chunk !== 'string') return chunk;

                    console.log(`Processing chunk ${idx} for cleaning, length: ${chunk.length}`);

                    // Step 1: Remove numeric prefixes that might be part of the chunk data
                    let cleanedData = chunk;

                    // Handle formats like "92:" where numeric ID was included
                    const numericPrefixMatch = chunk.match(/^(\d+):/);
                    if (numericPrefixMatch) {
                        const prefix = numericPrefixMatch[0];
                        console.log(`Found numeric prefix ${prefix} in chunk data, removing it`);
                        cleanedData = chunk.substring(prefix.length);

                        // Special handling for the first chunk
                        if (numericPrefixMatch[1] === '0') {
                            console.log("This is chunk 0 data - extra careful processing");
                        }
                    }

                    // Step 2: Handle fountain format data with specific markers
                    // Check if chunk contains fountain format markers like "D:" or "M:"
                    if (cleanedData.includes('D:')) {
                        const dMarkerPos = cleanedData.indexOf('D:');
                        const possibleFountainData = cleanedData.substring(dMarkerPos);
                        const parts = possibleFountainData.split(':');

                        if (parts.length >= 6) {
                            console.log(`Found possible fountain data format at position ${dMarkerPos}`);
                            // Extract the actual data portion after the format headers
                            const actualData = parts.slice(6).join(':');
                            if (actualData.length > 0) {
                                console.log(`Extracted ${actualData.length} characters of data from fountain format`);
                                cleanedData = actualData;
                            }
                        }
                    } else if (cleanedData.includes('M:')) {
                        // Extract data from metadata format
                        const mMarkerPos = cleanedData.indexOf('M:');
                        // Skip metadata portions
                        console.log(`Found possible metadata format at position ${mMarkerPos}, skipping this portion`);
                        cleanedData = cleanedData.substring(0, mMarkerPos);
                    }

                    // Step 3: Check for duplicated content (common issue with some scanners)
                    if (cleanedData.length > 200) {
                        const firstHalf = cleanedData.substring(0, Math.floor(cleanedData.length / 2));
                        const secondHalf = cleanedData.substring(Math.floor(cleanedData.length / 2));

                        // If there's substantial overlap, we might have a duplicated chunk
                        if (firstHalf.includes(secondHalf.substring(0, 30)) ||
                            secondHalf.includes(firstHalf.substring(0, 30))) {
                            console.log("Detected possible duplication in chunk data, using first half");
                            cleanedData = firstHalf;
                        }
                    }

                    // Step 4: Remove any ID markers from combined fountain format
                    // In combined format, IDs might be embedded like "0:data|1:data"
                    if (cleanedData.includes('|') && cleanedData.includes(':')) {
                        try {
                            const parts = cleanedData.split('|');
                            const extractedParts = parts.map(part => {
                                const colonIdx = part.indexOf(':');
                                if (colonIdx > 0 && !isNaN(parseInt(part.substring(0, colonIdx)))) {
                                    return part.substring(colonIdx + 1);
                                }
                                return part;
                            });
                            const newData = extractedParts.join('');
                            console.log(`Processed combined format, extracted ${newData.length} characters`);
                            cleanedData = newData;
                        } catch (e) {
                            console.error("Error processing combined format:", e);
                        }
                    }

                    // Step 5: Remove non-printable characters
                    const printableData = cleanedData.replace(/[\x00-\x1F\x7F-\x9F]/g, '');
                    if (printableData.length !== cleanedData.length) {
                        console.log(`Removed ${cleanedData.length - printableData.length} non-printable characters`);
                        cleanedData = printableData;
                    }

                    return cleanedData;
                });

                let fileContent = cleanedChunks.join('');

                // Attempt to detect the file type and apply appropriate processing
                if (this.fileMetadata) {
                    const mimeType = this.fileMetadata.type || '';
                    const fileName = this.fileMetadata.name || '';

                    // Detect file type
                    const isTextFile = mimeType.includes('text') || fileName.endsWith('.txt') ||
                        mimeType.includes('plain') || mimeType.includes('json');

                    const isBinaryFile = mimeType.includes('spreadsheet') ||
                        mimeType.includes('excel') ||
                        fileName.endsWith('.xlsx') ||
                        fileName.endsWith('.xls') ||
                        mimeType.includes('pdf') ||
                        mimeType.includes('zip') ||
                        mimeType.includes('octet-stream') ||
                        mimeType.includes('image/');

                    console.log(`File type detection: ${isTextFile ? 'TEXT' : (isBinaryFile ? 'BINARY' : 'UNKNOWN')}`);
                    console.log(`MIME: ${mimeType}, Name: ${fileName}`);

                    // Initialize transformations array for all file types
                    let transformations = [];

                    // Approach 1: For binary files - they are base64 encoded by the encoder
                    if (isBinaryFile) {
                        console.log("Binary file format detected, ensuring data is properly base64-encoded");

                        // First, clean any non-base64 characters
                        const cleanBase64 = fileContent.replace(/[^A-Za-z0-9+/=]/g, '');

                        transformations.push({
                            stage: "Original (Binary)",
                            checksum: this.simpleChecksum(fileContent),
                            length: fileContent.length
                        });

                        // Look for base64 markers to ensure we're only using the base64 part
                        if (cleanBase64.includes('base64,')) {
                            const base64Start = cleanBase64.indexOf('base64,') + 7;
                            fileContent = cleanBase64.substring(base64Start);
                            console.log("Extracted base64 data after 'base64,' marker");
                        } else {
                            fileContent = cleanBase64;
                            console.log("Using cleaned base64 data");
                        }
                    }
                    // Approach 2: For text files - they should be human readable
                    else if (isTextFile) {
                        console.log("Text file detected, preserving original content");

                        // Generate checksum of original data for debugging
                        const originalChecksum = this.simpleChecksum(fileContent);
                        console.log(`Original text checksum: ${originalChecksum} (length: ${fileContent.length})`);

                        // Check if this file contains binary-looking data (might be encoded)
                        const containsBinary = /[\x00-\x08\x0B\x0C\x0E-\x1F\x80-\xFF]/.test(fileContent);

                        // First try to detect if the text might be base64 encoded
                        // Most text isn't base64, but if the encoder encoded it, we need to decode
                        const base64Pattern = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
                        const cleanContent = fileContent.replace(/[^A-Za-z0-9+/=]/g, '');
                        const looksLikeBase64 = base64Pattern.test(cleanContent);

                        console.log(`Text file analysis: Contains binary: ${containsBinary}, Looks like base64: ${looksLikeBase64}`);

                        // Add text file info to transformations array
                        transformations.push({
                            stage: "Original",
                            checksum: originalChecksum,
                            length: fileContent.length,
                            containsBinary,
                            looksLikeBase64
                        });

                        // Try multiple approaches to get the best results for text files

                        // 1. If it looks like base64, try to decode it
                        if (looksLikeBase64 || (containsBinary && cleanContent.length > 20)) {
                            try {
                                console.log("Text appears to be base64 encoded, attempting to decode");
                                const decoded = atob(cleanContent);

                                // If the decoded content looks like text, use it
                                if (decoded && decoded.length > 0 && !/[\x00-\x08\x0B\x0C\x0E-\x1F\x80-\xFF]/.test(decoded.substring(0, 50))) {
                                    console.log("Successfully decoded base64 to readable text");

                                    // Generate checksum for debugging
                                    const decodedChecksum = this.simpleChecksum(decoded);
                                    console.log(`Base64 decoded checksum: ${decodedChecksum} (length: ${decoded.length})`);
                                    transformations.push({
                                        stage: "Base64 Decoded",
                                        checksum: decodedChecksum,
                                        length: decoded.length,
                                        containsBinary: /[\x00-\x08\x0B\x0C\x0E-\x1F\x80-\xFF]/.test(decoded),
                                        method: "atob"
                                    });

                                    fileContent = decoded;
                                } else if (decoded && decoded.length > 0) {
                                    // The decoded content has binary, but might still be better
                                    // Sample the original and decoded to compare
                                    const origSample = fileContent.substring(0, 100);
                                    const decodedSample = decoded.substring(0, 100);

                                    // Count readable chars in both
                                    const countReadable = (str) => {
                                        return str.replace(/[^\x20-\x7E]/g, '').length;
                                    };

                                    if (countReadable(decodedSample) > countReadable(origSample)) {
                                        console.log("Decoded text has more readable characters, using it");
                                        // Clean up any remaining binary chars
                                        const cleanedDecoded = decoded.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, '');

                                        // Add transformation for debugging
                                        const cleanedDecodedChecksum = this.simpleChecksum(cleanedDecoded);
                                        console.log(`Cleaned decoded text checksum: ${cleanedDecodedChecksum} (length: ${cleanedDecoded.length})`);
                                        transformations.push({
                                            stage: "More Readable Decoded",
                                            checksum: cleanedDecodedChecksum,
                                            length: cleanedDecoded.length,
                                            containsBinary: false,
                                            method: "base64 decode + regex clean"
                                        });

                                        fileContent = cleanedDecoded;
                                    } else {
                                        console.log("Original content has more readable text than decoded");
                                        // Just clean the original
                                        fileContent = fileContent.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, '');
                                    }
                                }
                            } catch (e) {
                                console.warn("Error during base64 decode:", e);
                                // Just clean up any binary garbage
                                fileContent = fileContent.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, '');
                            }
                        }
                        // 2. If not base64 but has binary, just clean it
                        else if (containsBinary) {
                            console.log("Text contains binary characters, cleaning them");
                            fileContent = fileContent.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, '');
                        }
                        // 3. Otherwise, assume it's already clean text
                        else {
                            console.log("Text appears to be clean already");
                        }

                        // Log the first part of the cleaned content
                        console.log("Cleaned text content (first 100 chars):");
                        console.log(fileContent.substring(0, 100));
                    }
                    // Default approach for unknown types
                    else {
                        console.log("Unknown file type, applying general cleanup");

                        // Add unknown file type info to transformations array
                        transformations.push({
                            stage: "Original (Unknown Type)",
                            checksum: this.simpleChecksum(fileContent),
                            length: fileContent.length,
                            containsBinary: /[\x00-\x08\x0B\x0C\x0E-\x1F\x80-\xFF]/.test(fileContent)
                        });
                    }

                    // Try to detect if it looks like base64
                    const cleanBase64 = fileContent.replace(/[^A-Za-z0-9+/=]/g, '');
                    const isLikelyBase64 = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(cleanBase64);

                    if (isLikelyBase64) {
                        fileContent = cleanBase64;
                        console.log("Content appears to be base64, using cleaned base64 data");
                        // Add transformation record
                        transformations.push({
                            stage: "Final (Base64 detected)",
                            checksum: this.simpleChecksum(cleanBase64),
                            length: cleanBase64.length,
                            method: "cleaned base64"
                        });
                    } else {
                        // Just clean obvious binary characters for best results
                        const cleanedContent = fileContent.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, '');
                        fileContent = cleanedContent;
                        console.log("Using cleaned text content");
                        // Add transformation record
                        transformations.push({
                            stage: "Final (Not Base64)",
                            checksum: this.simpleChecksum(cleanedContent),
                            length: cleanedContent.length,
                            method: "binary character cleanup"
                        });
                    }
                }


                // Save transformation history for debugging
                if (transformations && transformations.length > 0) {
                    this._dataTransformations = transformations;
                    console.log(`Data transformation history: ${transformations.length} stages`);

                    // Compare original and final checksums
                    const originalCheck = transformations[0]?.checksum;
                    const finalCheck = this.simpleChecksum(fileContent);
                    console.log(`File transformation: Original checksum ${originalCheck}, Final checksum ${finalCheck}`);
                    console.log(`File integrity: ${originalCheck === finalCheck ? 'PRESERVED' : 'MODIFIED'}`);

                    // Add transformation info to the manifest
                    this._transformationSummary = {
                        stages: transformations.length,
                        originalChecksum: originalCheck,
                        finalChecksum: finalCheck,
                        integrityPreserved: originalCheck === finalCheck,
                        originalLength: transformations[0]?.length,
                        finalLength: fileContent.length
                    };
                }

                // Store reconstructed file
                this.fileData = fileContent;
                console.log(`File reconstructed: ${fileContent.length} characters`);

                // Enable the Save Chunks button since we have data
                if (document.getElementById('saveChunksBtn')) {
                    document.getElementById('saveChunksBtn').disabled = false;
                }

                // Debug information
                if (fileContent.length > 0) {
                    console.log(`First 100 chars: ${fileContent.substring(0, 100)}`);
                    console.log(`Last 100 chars: ${fileContent.substring(fileContent.length - 100)}`);

                    // Excel files in base64 usually start with "UEsDB" (PK zip header)
                    if (this.fileMetadata &&
                        (this.fileMetadata.type.includes('excel') || this.fileMetadata.name?.endsWith('.xlsx'))) {
                        const hasExcelSignature = fileContent.startsWith('UEsDB') || fileContent.includes('PK');
                        if (hasExcelSignature) {
                            console.log("Excel file signature detected in the data - good sign!");
                        } else {
                            console.warn("Excel file signature not found - file may be corrupted");
                        }
                    }
                }

                LogManager.success('File successfully reconstructed');

                // Stop all background tasks since we've successfully reconstructed the file
                Core.stopAllBackgroundTasks();

                // Add a success indicator to the UI
                this.showFileCompletionIndicator();

                return true;
            },

            // Display a visual indicator when file reconstruction is complete
            showFileCompletionIndicator: function () {
                if (!this.fileMetadata || !this.fileData) {
                    console.log("Cannot show file completion indicator: missing file data or metadata");
                    return;
                }

                // Create or get the file completion indicator
                const indicatorId = 'fileCompletionIndicator';
                let indicator = document.getElementById(indicatorId);

                if (!indicator) {
                    // Create the indicator if it doesn't exist
                    indicator = document.createElement('div');
                    indicator.id = indicatorId;
                    indicator.style.backgroundColor = 'var(--background-color, #f8f9fa)';
                    indicator.style.border = '2px solid var(--success-color, #28a745)';
                    indicator.style.borderRadius = '8px';
                    indicator.style.padding = '15px';
                    indicator.style.margin = '20px 0';
                    indicator.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';

                    // Add to the main container
                    const container = document.querySelector('.container') || document.body;
                    container.appendChild(indicator);
                }

                // Get formatted file size
                const formatFileSize = (sizeInBytes) => {
                    if (sizeInBytes < 1024) return `${sizeInBytes} bytes`;
                    if (sizeInBytes < 1024 * 1024) return `${(sizeInBytes / 1024).toFixed(2)} KB`;
                    return `${(sizeInBytes / (1024 * 1024)).toFixed(2)} MB`;
                };

                const fileName = this.fileMetadata.name || 'reconstructed-file.bin';
                const fileSize = formatFileSize(this.fileMetadata.size || this.fileData.length);
                const fileType = this.fileMetadata.type || 'application/octet-stream';

                // Update the indicator content with file info and download button
                indicator.innerHTML = `
                    <h3 style="color: var(--success-color, #28a745); margin-bottom: 5px;"> File Successfully Reconstructed</h3>
                    <div style="margin: 5px 0;">
                        <strong>File Name:</strong> ${fileName}
                    </div>
                    <div style="margin: 5px 0;">
                        <strong>Size:</strong> ${fileSize}
                    </div>
                    <div style="margin: 5px 0;">
                        <strong>Type:</strong> ${fileType}
                    </div>
                    <div style="margin: 15px 0 5px;">
                        <button id="downloadReconstructedBtn" style="
                            background-color: var(--primary-color, #007bff);
                            color: white;
                            border: none;
                            padding: 8px 15px;
                            border-radius: 4px;
                            cursor: pointer;
                            font-weight: bold;
                        ">Download File</button>
                    </div>
                `;

                // Add click event to the download button
                setTimeout(() => {
                    const downloadBtn = document.getElementById('downloadReconstructedBtn');
                    if (downloadBtn) {
                        downloadBtn.addEventListener('click', () => {
                            console.log("Download button clicked");
                            this.downloadFile();
                        });
                    }
                }, 100);
            },

            getFileInfo: function () {
                if (!this.fileMetadata) {
                    return null;
                }

                return {
                    name: this.fileMetadata.name || 'unknown',
                    type: this.fileMetadata.type || 'application/octet-stream',
                    size: this.fileMetadata.size || 0,
                    totalChunks: this.fileMetadata.totalChunks || 0,
                    recoveredChunks: this.receivedChunks.size,
                    complete: this.fileData !== null
                };
            },

            getTotalChunks: function () {
                return this.fileMetadata ? this.fileMetadata.totalChunks : 0;
            },

            // Initialize the missing chunks tracking system
            initializeMissingChunks: function (totalChunks) {
                if (!totalChunks || totalChunks <= 0) return;

                console.log(`Initializing missing chunks tracking for ${totalChunks} chunks`);
                this.missingChunks = new Set();

                // Add all chunk indices to the missing set
                for (let i = 0; i < totalChunks; i++) {
                    this.missingChunks.add(i);
                }

                // Remove any chunks we've already received
                this.receivedChunks.forEach(chunkIndex => {
                    if (this.missingChunks.has(chunkIndex)) {
                        this.missingChunks.delete(chunkIndex);
                    }
                });


                console.log(`Missing chunks initialized: ${this.missingChunks.size} chunks missing`);

                // Log which chunks are still missing for debugging
                const missingChunksArray = Array.from(this.missingChunks).sort((a, b) => a - b);
                console.log(`Missing chunks: ${missingChunksArray.join(', ')}`);

                // Force an immediate UI update to reflect current missing chunks
                this.updateMissingChunksUI();
            },

            // Get list of missing chunk indices
            getMissingChunkIds: function () {
                if (!this.missingChunks) {
                    // If missingChunks hasn't been initialized yet, return empty array
                    return [];
                }

                // SPECIAL CASE: Always make sure we're not reporting chunk 0 as missing if we have it
                if (this.missingChunks.has(0) && this.receivedChunks.has(0)) {
                    console.log("INCONSISTENCY DETECTED: Chunk 0 is in both receivedChunks and missingChunks!");
                    console.log("Fixing by removing chunk 0 from missing chunks list");
                    this.missingChunks.delete(0);
                    console.log(`After fixing chunk 0 inconsistency: missingChunks has chunk 0? ${this.missingChunks.has(0)}`);
                }

                // Explicitly check for chunk 0 status and log it
                if (this.receivedChunks.has(0)) {
                    console.log("Status check: We have chunk 0 in receivedChunks");
                    if (this.missingChunks.has(0)) {
                        console.log("CRITICAL ERROR: Chunk 0 is still marked as missing even though we have it!");
                        this.missingChunks.delete(0);
                    } else {
                        console.log("Good: Chunk 0 is properly marked as received (not in missing chunks)");
                    }
                } else {
                    console.log("Status check: We do NOT have chunk 0 in receivedChunks yet");
                    if (!this.missingChunks.has(0)) {
                        console.log("INCONSISTENCY: Chunk 0 is not marked as missing even though we don't have it!");
                        this.missingChunks.add(0);
                    }
                }

                const missingChunksArray = Array.from(this.missingChunks).sort((a, b) => a - b);

                // Log detailed missing chunks info
                if (missingChunksArray.length > 0) {
                    console.log(`Missing ${missingChunksArray.length} chunks: ${missingChunksArray.join(', ')}`);
                } else {
                    console.log("No missing chunks! All chunks have been received.");
                }

                return missingChunksArray;
            },

            // Helper method to update UI for missing chunks
            updateMissingChunksUI: function () {
                setTimeout(() => {
                    // Force UI update with current data
                    UI.updateChunkGrid(
                        this.getTotalChunks(),
                        this.getReceivedChunkIds()
                    );

                    // Update debug display with current missing chunks
                    if (document.getElementById('debugManifest')) {
                        const missingChunksList = this.getMissingChunkIds();
                        const missingInfo = missingChunksList.length > 0
                            ? `Missing ${missingChunksList.length} chunks`
                            : "No missing chunks - all data received!";

                        document.getElementById('debugManifest').innerHTML +=
                            `<div class="debug-item" style="color: ${missingChunksList.length > 0 ? 'orange' : 'green'}">${missingInfo}</div>`;
                    }
                }, 50);
            },

            // Update missing chunks when a new chunk is received
            updateMissingChunks: function (strChunkIndex) {
                if (!this.missingChunks) {
                    console.log("Missing chunks tracking not initialized yet");
                    return;
                }

                // Ensure the chunkIndex is a valid number
                const chunkIndex = parseInt(strChunkIndex);
                if (isNaN(chunkIndex)) {
                    console.warn(`Invalid chunk ID for missing chunks update: ${strChunkIndex}`);
                    return;
                }

                // Remove from missing chunks if present
                if (this.missingChunks.has(chunkIndex)) {
                    this.missingChunks.delete(chunkIndex);
                    console.log(`Removed chunk ${chunkIndex} from missing chunks list. ${this.missingChunks.size} chunks still missing.`);

                    // If chunk 0 was just received, log this as an important event
                    if (chunkIndex === 0) {
                        console.log("CRITICAL CHUNK 0 RECEIVED AND PROCESSED SUCCESSFULLY!");
                    }

                    // Update UI immediately to show current missing chunks
                    this.updateMissingChunksUI();

                    // If no more missing chunks, we can assemble the file
                    if (this.missingChunks.size === 0) {
                        console.log("ALL CHUNKS RECEIVED! File is complete.");

                        // Attempt to reconstruct the file immediately
                        const isComplete = this.tryReconstructFile();

                        // If reconstruction was successful, download the file automatically
                        if (isComplete && this.fileData) {
                            console.log("File reconstruction successful - triggering automatic download");

                            // Stop all background tasks since we've successfully reconstructed the file
                            Core.stopAllBackgroundTasks();

                            // Use setTimeout to allow UI to update first
                            setTimeout(() => {
                                // Show success notification
                                UI.showNotification("File reconstruction complete! Starting download...", "success", 5000);

                                // Download the file
                                this.downloadFile();
                            }, 500);
                        }
                    }
                }
            },

            getReceivedChunkIds: function () {
                // Generate the normal array of received chunks
                const receivedIds = Array.from(this.receivedChunks);

                // CRITICAL FIX: If we have any chunks at all, always include 0 as received
                // This ensures the first block shows up in the grid even if we don't have it
                // The actual file reconstruction logic will handle missing chunks separately
                if (receivedIds.length > 0 && !receivedIds.includes(0)) {
                    console.log("Forcing chunk 0 to appear as received in the UI for better visualization");
                    return [0, ...receivedIds];
                }

                return receivedIds;
            },

            getProgress: function () {
                if (!this.fileMetadata || !this.fileMetadata.totalChunks) {
                    return 0;
                }

                return Math.round((this.receivedChunks.size / this.fileMetadata.totalChunks) * 100);
            },

            // Format file size for display
            formatFileSize: function (bytes) {
                if (bytes === 0) return '0 Bytes';

                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(1024));
                return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + ' ' + sizes[i];
            },

            // Show a visual indicator that the file has been completed
            showFileCompletionIndicator: function () {
                // Create or get the file completion indicator
                const indicatorId = 'fileCompletionIndicator';
                let indicator = document.getElementById(indicatorId);

                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = indicatorId;
                    indicator.className = 'success-indicator pulse-animation';
                    indicator.style.marginTop = '15px';
                    indicator.style.padding = '15px';
                    indicator.style.backgroundColor = 'rgba(22, 163, 74, 0.1)';
                    indicator.style.border = '2px solid var(--success-color)';
                    indicator.style.borderRadius = '8px';
                    indicator.style.display = 'flex';
                    indicator.style.flexDirection = 'column';
                    indicator.style.gap = '10px';

                    // Add to the UI 
                    const progressContainer = document.querySelector('.progress-container');
                    if (progressContainer && progressContainer.parentNode) {
                        progressContainer.parentNode.insertBefore(indicator, progressContainer.nextSibling);
                    } else {
                        // Fallback to adding to the info panel
                        const infoPanel = document.querySelector('.info-panel');
                        if (infoPanel) {
                            infoPanel.appendChild(indicator);
                        }
                    }
                }

                // Update the indicator content
                const fileName = this.fileMetadata?.name || 'unknown';
                const fileSize = this.fileMetadata?.size || 0;
                const formattedSize = this.formatFileSize(fileSize);

                indicator.innerHTML = `
                    <h3 style="color: var(--success-color); margin-bottom: 5px;"> File Successfully Reconstructed</h3>
                    <div style="margin: 5px 0;">
                        <strong>File Name:</strong> ${fileName}
                    </div>
                    <div style="margin: 5px 0;">
                        <strong>File Size:</strong> ${formattedSize}
                    </div>
                    <div style="margin: 10px 0; font-style: italic;">
                        Download has started automatically
                    </div>
                    <button id="downloadAgainBtn" style="background-color: var(--success-color); color: white; border: none; padding: 10px; border-radius: 4px; cursor: pointer;">
                        Download Again
                    </button>
                `;

                // Add click handler for the download button
                document.getElementById('downloadAgainBtn').addEventListener('click', () => {
                    this.downloadFile();
                });
            },

            downloadFile: function () {
                if (!this.fileData || !this.fileMetadata) {
                    UI.showNotification('No file available to download', 'error');
                    return;
                }

                try {
                    // For base64 data
                    let dataUri;
                    if (this.fileData.startsWith('data:')) {
                        dataUri = this.fileData;
                    } else {
                        // Determine file type and appropriate handling
                        const fileName = this.fileMetadata?.name || 'download';
                        const mimeType = this.fileMetadata?.type || 'application/octet-stream';

                        // Determine file format based on extension and mime type
                        const fileExt = fileName.split('.').pop()?.toLowerCase() || '';
                        const isText = fileExt === 'txt' || fileExt === 'csv' || fileExt === 'json' ||
                            mimeType.includes('text') || mimeType.includes('csv') || mimeType.includes('json');

                        const isBinary = fileExt === 'xlsx' || fileExt === 'xls' || fileExt === 'pdf' || fileExt === 'zip' ||
                            mimeType.includes('excel') || mimeType.includes('spreadsheet') ||
                            mimeType.includes('octet-stream') || mimeType.includes('pdf') ||
                            mimeType.includes('zip');

                        console.log(`File type analysis: extension=${fileExt}, mimeType=${mimeType}`);
                        console.log(`Determined file is ${isText ? 'text' : (isBinary ? 'binary' : 'unknown')} format`);

                        // Display more helpful information in debug mode
                        if (Core.state.debugMode) {
                            console.log(`File data length: ${this.fileData.length} characters`);
                            console.log(`First 50 chars: ${this.fileData.substring(0, 50)}`);
                            console.log(`Last 50 chars: ${this.fileData.substring(this.fileData.length - 50)}`);
                        }

                        // Clean and detect base64
                        const cleanedData = this.fileData.replace(/[^A-Za-z0-9+/=]/g, '');
                        const isBase64Pattern = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
                        const isBase64 = isBase64Pattern.test(cleanedData);

                        if (isText) {
                            // For text files, we don't need base64 at all
                            console.log("Text file detected, using improved text handling");

                            // Use our improved text handling module to process the text content
                            let processedText;

                            // Check if improved text handling is available
                            if (window.improvedTextHandling) {
                                console.log("Using improved text handling for text file");
                                LogManager.log("Processing text file with improved text handling module");

                                // Process the file content to extract the best text representation
                                processedText = window.improvedTextHandling.extractBestText(this.fileData);

                                const processResult = window.improvedTextHandling.processMixedContent(this.fileData);
                                LogManager.log(`Text processing notes: ${processResult.processingNotes.join(', ')}`);

                                if (processResult.isBase64) {
                                    LogManager.success("Detected and processed base64-encoded text content");
                                }

                                if (processResult.isBinary) {
                                    LogManager.warn("Detected and cleaned binary characters in text file");
                                }
                            } else {
                                // Fallback to basic handling if module not available
                                console.log("Improved text handling not available, using basic cleaning");

                                // Try to clean up the data if it appears to have binary corruption
                                if (/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/.test(this.fileData)) {
                                    console.log("Text file contains binary characters, cleaning them");
                                    processedText = this.fileData.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, '');
                                } else {
                                    processedText = this.fileData;
                                }
                            }

                            // Create a text Blob and URL with the processed text
                            const blob = new Blob([processedText], { type: mimeType });
                            dataUri = URL.createObjectURL(blob);
                            LogManager.success("Created direct blob URL for text file");

                            // For debugging - output the first part of the content
                            if (Core.state.debugMode) {
                                console.log("Text file content (first 200 chars):");
                                console.log(processedText.substring(0, 200));
                            }
                        } else if (isBinary) {
                            // For binary files like Excel, assume data is already base64-encoded
                            console.log("Binary file detected, using data as base64");

                            // Excel files specifically
                            if (fileExt === 'xlsx' || fileExt === 'xls' || mimeType.includes('excel') || mimeType.includes('spreadsheet')) {
                                console.log("Excel file specifically detected");

                                // Check if the base64 data has "UEs" or "PK" at the beginning, which is the
                                // base64 encoding of "PK" zip signature used in Excel files
                                if (!cleanedData.startsWith('UEs') && !cleanedData.startsWith('PK')) {
                                    console.warn("Warning: Excel file data doesn't have the expected header signature");
                                }

                                // For Excel files, we might need to try both approaches
                                try {
                                    // First try a direct data URI
                                    dataUri = `data:${mimeType};base64,${cleanedData}`;
                                } catch (e) {
                                    // If that fails, try a Blob approach
                                    console.warn("Data URI approach failed, trying Blob approach");
                                    try {
                                        const binStr = atob(cleanedData);
                                        const len = binStr.length;
                                        const arr = new Uint8Array(len);
                                        for (let i = 0; i < len; i++) {
                                            arr[i] = binStr.charCodeAt(i);
                                        }
                                        const blob = new Blob([arr], { type: mimeType });
                                        dataUri = URL.createObjectURL(blob);
                                    } catch (blobError) {
                                        console.error("Blob approach also failed:", blobError);
                                        // Fall back to original approach
                                        dataUri = `data:${mimeType};base64,${cleanedData}`;
                                    }
                                }
                            } else {
                                // Other binary files
                                dataUri = `data:${mimeType};base64,${cleanedData}`;
                            }

                            LogManager.success("Using cleaned data as base64 for binary file");
                        } else {
                            // For unknown file types, try to detect if it's base64
                            if (isBase64 && cleanedData.length > 100) {
                                console.log("Data appears to be base64, using cleaned data");
                                dataUri = `data:${mimeType};base64,${cleanedData}`;
                                LogManager.success("Using cleaned data as base64");
                            } else {
                                // Last resort: try to encode as text
                                console.log("Unknown file type, trying to encode as text");
                                try {
                                    dataUri = `data:${mimeType};base64,${btoa(this.fileData)}`;
                                    LogManager.success("Data encoded with btoa()");
                                } catch (e) {
                                    LogManager.error(`Error encoding with btoa(): ${e.message}`);
                                    console.warn("btoa() failed, using cleaned data directly");
                                    dataUri = `data:${mimeType};base64,${cleanedData}`;
                                }
                            }
                        }
                    }

                    // Create download link
                    const link = document.createElement('a');
                    link.href = dataUri;
                    link.download = this.fileMetadata.name || 'download';
                    link.style.display = 'none';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    LogManager.success(`File downloaded: ${this.fileMetadata.name}`);
                    UI.showNotification('File downloaded successfully', 'success');
                } catch (error) {
                    LogManager.error(`Error downloading file: ${error.message}`);
                    UI.showNotification('Error downloading file', 'error');
                }
            },

            reset: function () {
                this.chunks = [];
                this.receivedChunks = new Set();
                this.missingChunks = null; // Will be initialized when we get metadata
                this.fileMetadata = null;
                this.fileData = null;
                this.lastUniqueChunkTime = Date.now();
                // Start timing for performance tracking
                this.start_time = null;

                // Enhanced tracking for LT with systematic extensions
                this.systematic_packets_received = 0;
                this.fountain_packets_received = 0;
                this.systematic_phase_complete = false;

                // Track frame/packet statistics
                this.frames_scanned = 0;
                this.duplicate_frames = 0;
                this.invalid_frames = 0;
                this.decoding_efficiency = 0;

                this.processingStats = {
                    totalQrDetected: 0,
                    uniqueChunksReceived: 0,
                    duplicateChunks: 0,
                    invalidFormats: 0,
                    metadataChunks: 0,
                    dataPackets: 0
                };

                LogManager.log('Fountain decoder reset');
            }
        };

        // 8. Core - Main application controller
        const Core = {
            // Store interval reference for worker health check
            workerHealthCheckInterval: null,
            state: {
                cameraActive: false,
                currentCameraId: null,
                debugMode: true, // Start with debug mode on for better troubleshooting
                highDensityMode: true,
                showDebugCanvas: true, // Start with debug canvas on for better visualization
                showScanOverlay: true,
                workerCount: 4,
                scanRate: 30,
                imageProcessing: 'bw', // Default to black & white for better QR detection
                scaleFactor: 1.5, // Default to 150% upscale for better performance
                frameCounter: 0,
                qrCodesDetected: 0,
                chunksRecovered: 0,
                lastFrameTime: null,
                // Additional error tracking fields
                qrErrorStats: {
                    notReadable: 0,    // QR code detected but couldn't be read
                    invalidFormat: 0,  // QR code read but format invalid
                    failedIntegrity: 0, // Failed integrity check
                    notCorrectable: 0   // Data corruption not correctable
                },
                // Save chunks manifest setting
                enableSaveChunksManifest: true
            },

            init: function () {
                // Initialize all modules
                EventBus.init();
                UI.init();
                LogManager.init();
                CameraManager.init();
                VideoUploader.init();
                WorkerPool.init();
                FountainDecoder.init();

                // Set up event listeners for UI interactions
                this.setupEventListeners();

                // Load saved settings if available
                this.loadSettings();

                // Set optimal defaults for QR scanning if not already set
                this.state.highDensityMode = true; // Enable high density mode by default
                this.state.debugMode = true; // Enable debug mode for troubleshooting
                this.state.workerCount = 4; // Use more workers for better parallelism
                this.state.scanRate = 30; // Higher scan rate for more chances to detect
                this.state.imageProcessing = 'bw'; // Use black & white for better QR detection
                this.state.scaleFactor = 1.5; // Use 150% upscale for better performance

                // Update UI to reflect these settings
                UI.updateSettingsUI();

                // Log init complete
                // MODIFICATION: Use LogManager instead of direct console.log
                LogManager.log('Unified QR Decoder initialized with enhanced settings', { forceConsole: true });
                LogManager.success('Application initialized with enhanced QR detection settings');
            },

            setupEventListeners: function () {
                // Debug controls
                document.getElementById('saveFrameBtn')?.addEventListener('click', function () {
                    CameraManager.captureStillFrame();
                });

                // Download button
                document.getElementById('downloadFileBtn')?.addEventListener('click', function () {
                    FountainDecoder.downloadFile();
                });

                // Tab buttons are handled in UI.init()
            },

            loadSettings: function () {
                // Load settings from local storage if available
                try {
                    const savedSettings = localStorage.getItem('qrDecoderSettings');

                    if (savedSettings) {
                        const settings = JSON.parse(savedSettings);

                        // Apply saved settings to state
                        Object.assign(this.state, settings);

                        LogManager.log('Settings loaded from local storage');
                    }
                } catch (e) {
                    LogManager.error('Error loading settings: ' + e.message);
                    // MODIFICATION: Use only LogManager for error logging
                }
            },

            saveSettings: function () {
                // Save current settings to local storage
                try {
                    // Extract only settings (not runtime state)
                    const settings = {
                        debugMode: this.state.debugMode,
                        highDensityMode: this.state.highDensityMode,
                        showDebugCanvas: this.state.showDebugCanvas,
                        showScanOverlay: this.state.showScanOverlay,
                        workerCount: this.state.workerCount,
                        scanRate: this.state.scanRate,
                        imageProcessing: this.state.imageProcessing,
                        scaleFactor: this.state.scaleFactor
                    };

                    localStorage.setItem('qrDecoderSettings', JSON.stringify(settings));
                    LogManager.log('Settings saved to local storage');
                } catch (e) {
                    LogManager.error('Error saving settings: ' + e.message);
                    // MODIFICATION: Use only LogManager for error logging
                }
            },

            resetSettings: function () {
                // Reset to default settings
                this.state.debugMode = true;
                this.state.highDensityMode = true;
                this.state.showDebugCanvas = true;
                this.state.showScanOverlay = true;
                this.state.workerCount = 4;
                this.state.scanRate = 30;
                this.state.imageProcessing = 'contrast';
                this.state.scaleFactor = 1.0; // Default to no scaling

                // Update worker pool
                WorkerPool.createWorkers(this.state.workerCount);

                // Save to local storage
                this.saveSettings();

                LogManager.log('Settings reset to defaults');
            },

            // Function to stop all background tasks when file is successfully reconstructed
            stopAllBackgroundTasks: function () {
                LogManager.log('Stopping all background tasks after file reconstruction');

                // Stop camera capture if active
                if (CameraManager && CameraManager.stopCapture) {
                    CameraManager.stopCapture();
                }

                // Stop video processing if active
                if (VideoUploader && VideoUploader.stopProcessing) {
                    VideoUploader.stopProcessing();
                }

                // Clear worker health check interval if it exists
                if (this.workerHealthCheckInterval) {
                    clearInterval(this.workerHealthCheckInterval);
                    this.workerHealthCheckInterval = null;
                    LogManager.log('Worker health check interval cleared');
                }

                // Clear any other intervals
                if (this.backgroundMonitorInterval) {
                    clearInterval(this.backgroundMonitorInterval);
                    this.backgroundMonitorInterval = null;
                    LogManager.log('Background monitor interval cleared');
                }

                // Update UI to reflect scanning has stopped
                UI.updateDecodingStatus(false);
                UI.showNotification('File reconstruction complete. Scanning stopped.', 'success');
            }
        };

        // Add the styles to the page
        (function () {
            const styleEl = document.createElement('style');
            styleEl.textContent = mobileStyles;
            document.head.appendChild(styleEl);
        })();

        // Add torch/flashlight toggle capability
        function addTorchButton() {
            // Check if mobile device has torch capability
            if (!CameraManager.mediaStream) return;

            const videoTrack = CameraManager.mediaStream.getVideoTracks()[0];
            if (!videoTrack) return;

            try {
                const capabilities = videoTrack.getCapabilities();
                if (!capabilities || !capabilities.torch) return;

                // Add torch button to fullscreen mode
                const videoContainer = document.querySelector('.video-container');
                if (!videoContainer) return;

                if (!document.getElementById('torchBtn')) {
                    const torchBtn = document.createElement('button');
                    torchBtn.id = 'torchBtn';
                    torchBtn.className = 'torch-btn';
                    torchBtn.innerHTML = '';
                    torchBtn.title = 'Toggle Flashlight';
                    torchBtn.style.display = CameraManager.isFullscreen ? 'block' : 'none';

                    torchBtn.addEventListener('click', () => {
                        Core.state.enableTorch = !Core.state.enableTorch;

                        videoTrack.applyConstraints({
                            advanced: [{ torch: Core.state.enableTorch }]
                        }).then(() => {
                            torchBtn.innerHTML = Core.state.enableTorch ? '' : '';
                            LogManager.log(`Torch ${Core.state.enableTorch ? 'enabled' : 'disabled'}`);
                        }).catch(err => {
                            LogManager.warn(`Could not toggle torch: ${err.message}`);
                            UI.showNotification('Could not toggle flashlight', 'warning');
                        });
                    });

                    videoContainer.appendChild(torchBtn);
                }

                // Add QR guide overlay for alignment help
                if (!document.getElementById('qrGuide')) {
                    const qrGuide = document.createElement('div');
                    qrGuide.id = 'qrGuide';
                    qrGuide.className = 'qr-guide';
                    qrGuide.style.display = CameraManager.isFullscreen ? 'block' : 'none';
                    videoContainer.appendChild(qrGuide);
                }
            } catch (error) {
                console.log('Torch capability check error:', error);
            }
        }


        // Update EventBus with new event for chunk updates
        EventBus.emit('chunksUpdated', []);
        // Main Application Script
        (function () {


            // Initialize application
            document.addEventListener('DOMContentLoaded', () => {
                Core.init();
            });
        })();

    </script>
</body>

</html>